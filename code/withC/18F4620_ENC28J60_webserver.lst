CCS PCH C Compiler, Version 4.100, 46564               12-Á.¤.-10 14:35

               Filename: C:\Users\dorakengi\Desktop\HW\18F4620_ENC28J60_webserver.lst

               ROM used: 43196 bytes (66%)
                         Largest free fragment is 22338
               RAM used: 892 (22%) at main() level
                         1078 (27%) worst case
               Stack:    15 worst case (14 in main + 1 for interrupts)

*
00000:  GOTO   A37A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   00B4
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                      EX_ST_WESERVER.C                             //// 
.................... ////                                                                   //// 
.................... //// An example program demonstrating using Microchip's TCP/IP stack   //// 
.................... //// with CCS's PCH C Compiler.                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// ABOUT CCS TCP/IP EXAMPLES:                                        //// 
.................... ////                                                                   //// 
.................... //// Connect your prototype board to serial cable, and open a serial   //// 
.................... //// connection at 9600bps.  With this link you can change all the     //// 
.................... //// ethernet and PPP settings.  You can also see the current status   //// 
.................... //// of the TCP/IP link.  Pressing any key will bring up the menu.     //// 
.................... ////                                                                   //// 
.................... //// If you are using PPP, you will need to initiate and disconnect a  //// 
.................... //// PPP connection using this serial link.  Until PPP is connected    //// 
.................... //// the board will not be connected to TCP/IP.                        //// 
.................... ////                                                                   //// 
.................... //// If the LCD is enabled in the code (it is enabled by default), the //// 
.................... //// last line displayed will be IP address of the unit.  If your      //// 
.................... //// ISP / Network doesn't filter ICMP/PING you can use the PING       //// 
.................... //// utility to test your connection.  If the last line doesn't        //// 
.................... //// display the IP address then the unit is connected (PPP not        //// 
.................... //// connected, ethernet cable not connected, a problem with ethernet  //// 
.................... //// DHCP, etc).                                                       //// 
.................... ////                                                                   //// 
.................... //// CAUTION: All settings are saved to the external EEPROM.  If you   //// 
.................... //// are using the Microchip PICDEM.net board that has an example      //// 
.................... //// file-system with webpages it will be deleted/corrupted by these   //// 
.................... //// examples.                                                         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// Sep 20, 2006 -                                                    //// 
.................... ////     Updated and tested with Microchip's 3.02 stack.               //// 
.................... ////                                                                   //// 
.................... //// Apr 28, 2006 -                                                    //// 
.................... ////     Tested on PCH 3.249                                           //// 
.................... ////     Fixed broken link for CCS logo                                //// 
.................... ////     Added test routine                                            //// 
.................... ////     Changed to 18F4620                                            //// 
.................... ////                                                                   //// 
.................... //// Mar 06, 2006 -                                                    //// 
.................... ////     Updated for CCS PICENS Board                                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //quick auto configure for different tcp/ip demo boards 
.................... #define STACK_USE_CCS_PICNET        0  //PICNET rev 0-2 board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F6620 
.................... #define STACK_USE_CCS_PICNET3       0  //PICNET rv 3 and up board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F8622 
.................... #define STACK_USE_CCS_PICENS        1  //CCS PICENS (Embedded Ethernet) development kit.  18F4620 + ENC28J60 
.................... #define STACK_USE_CCS_PICEEC        0  //CCS PICEEC (Embedded Ethernet) development kit.  18F67J60 
.................... #define STACK_USE_CCS_EWL5V         0  //CCS 5V EZ Web Lynx Device 
.................... #define STACK_USE_CCS_EWL3V         0  //CCS 3.3V EZ Web Lynx Device 
....................  
.................... //You must set one (and only) one of these to TRUE to tell the stack what hardware layer you are using 
.................... #define STACK_USE_MAC   1      //use the nic card 
.................... #define STACK_USE_PPP   0      //use PPP on modem 
.................... #define STACK_USE_SLIP  0      //use slip (NOT TESTED) 
....................  
.................... /// *** END USER CONFIGURABLE DEFINITIONS 
....................  
.................... #if STACK_USE_CCS_EWL5V || STACK_USE_CCS_EWL3V 
....................    #define STACK_USE_CCS_EWL  1 
.................... #else 
....................    #define STACK_USE_CCS_EWL  0 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL5V+STACK_USE_CCS_EWL3V >1) 
....................  #error You can only use one hardware definition 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL5V+STACK_USE_CCS_EWL3V==0) 
....................  #error You must define one hardware definition 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET3 
....................  #undef STACK_USE_CCS_PICNET 
....................  #define STACK_USE_CCS_PICNET 1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET3 
....................  #include <18f6722.h> 
....................  #use delay(clock=40000000) 
....................  #fuses H4 
....................  #fuses CCP2C1 
....................  #fuses MCLR 
....................  #fuses NOPROTECT 
.................... #elif STACK_USE_CCS_PICNET 
....................  #include <18f6720.h> 
....................  #use delay(clock=20000000) //CCS picnet is 20Mhz 
....................  #fuses HS 
....................  #fuses CCP2C1 
....................  #fuses NOPROTECT 
.................... #elif STACK_USE_CCS_PICENS 
....................  #include <18f4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
....................  #use delay(clock=40000000) 
*
00A04:  MOVLW  03
00A06:  MOVWF  FEA
00A08:  MOVLW  A7
00A0A:  MOVWF  FE9
00A0C:  MOVF   FEF,W
00A0E:  BZ    0A2C
00A10:  MOVLW  0C
00A12:  MOVWF  01
00A14:  CLRF   00
00A16:  DECFSZ 00,F
00A18:  BRA    0A16
00A1A:  DECFSZ 01,F
00A1C:  BRA    0A14
00A1E:  MOVLW  F7
00A20:  MOVWF  00
00A22:  DECFSZ 00,F
00A24:  BRA    0A22
00A26:  BRA    0A28
00A28:  DECFSZ FEF,F
00A2A:  BRA    0A10
00A2C:  RETLW  00
*
01EAC:  MOVLW  02
01EAE:  MOVLB  3
01EB0:  SUBWF  xBD,F
01EB2:  BNC   1ECC
01EB4:  MOVLW  03
01EB6:  MOVWF  FEA
01EB8:  MOVLW  BD
01EBA:  MOVWF  FE9
01EBC:  MOVF   FEF,W
01EBE:  BZ    1ECC
01EC0:  MOVLW  02
01EC2:  MOVWF  00
01EC4:  DECFSZ 00,F
01EC6:  BRA    1EC4
01EC8:  DECFSZ FEF,F
01ECA:  BRA    1EC0
01ECC:  MOVLB  0
01ECE:  RETLW  00
....................  #fuses H4 
....................  #fuses NOFCMEN 
....................  #fuses NOXINST 
....................  #fuses NOIESO 
....................  #fuses NOPBADEN 
....................  #fuses MCLR 
....................  #fuses NOPROTECT 
.................... #elif STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V 
....................  #include <18F67J60.H> 
....................  #use delay(clock=25M) 
....................  #fuses HS 
....................  #fuses NOIESO 
....................  #fuses NOFCMEN 
....................  #fuses PRIMARY 
....................  #fuses ETHLED 
....................  #fuses NOPROTECT 
.................... #elif STACK_USE_CCS_EWL5V 
....................  #include <18F2685.H> 
....................  #use delay(clock=25M) 
....................  #fuses HS 
....................  #fuses NOPBADEN 
....................  #fuses MCLR 
.................... #endif 
....................  
.................... #fuses NOWDT 
.................... #fuses NODEBUG 
.................... #fuses NOSTVREN 
....................  
.................... #if !(STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V) 
....................  #fuses PUT 
....................  #fuses NOLVP 
....................  #fuses NOBROWNOUT 
....................  #fuses NOCPD 
....................  #fuses WRT 
....................  #fuses NOWRTD 
....................  #fuses NOEBTR 
....................  #fuses NOCPB 
....................  #fuses NOEBTRB 
....................  #fuses WRTB 
.................... #endif 
....................  
.................... #define STACK_USE_SERIAL         TRUE 
....................  
.................... //set to true to put out information on the LCD screen 
.................... #if STACK_USE_CCS_EWL 
....................  //due to limited IO space on the ezweblynx, we will not use LCD 
....................  #define STACK_USE_PICDEM_LCD     FALSE      
.................... #else 
....................  #define STACK_USE_PICDEM_LCD     TRUE 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_MAC 
....................  #define STACK_USE_DHCP       TRUE  //for auto resolution of IP address 
....................  #define STACK_USE_ARP        TRUE  //needed to resolve MAC addresses of IP addresses 
....................  #define STACK_USE_UDP        TRUE  //needed for dhcp and announce 
....................  #define STACK_USE_ANNOUNCE   TRUE  //announce our IP periodically to the network 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS||STACK_USE_CCS_EWL5V) && STACK_USE_MAC 
....................  #define STACK_USE_MCPENC  TRUE     //tell the stack to use the ENC28J60 driver 
.................... #else 
....................  #define STACK_USE_MCPENC  FALSE    //tell the stack to use the Realtek driver 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V) && STACK_USE_MAC 
....................  #define STACK_USE_MCPINC  TRUE 
.................... #else 
....................  #define STACK_USE_MCPINC  FALSE 
.................... #endif 
....................  
.................... //use a ds1631 temperature sensor.  Note that on the EZ Web Lynx, 
.................... //the temperature sensor's i2c lines are on B6/B7.  Remove the ICD cable 
.................... //or the sensor won't function. 
.................... #if STACK_USE_CCS_EWL 
....................  #define STACK_USE_TEMP    TRUE 
.................... #endif 
....................  
....................  
.................... #define STACK_USE_ICMP        TRUE   //Enabled for ping support 
.................... #define STACK_USE_TCP         TRUE   //To send TCP packets (talk to HTTP clients) 
.................... #define STACK_USE_HTTP        TRUE   //Enable the CCS webserver 
.................... #define STACK_USE_IP_GLEANING FALSE  //Disable Microchip's propietary auto-IP configuration 
....................  
.................... #include "tcpip/stacktsk.c"    //include Microchip's TCP/IP stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_CCS_PICENS 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #elif STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V 
....................       //no hardware definitions - everything is internal 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
....................  
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
06F98:  MOVFF  3A8,3AD
06F9C:  MOVFF  3A7,3AC
....................    sc2=s2; 
06FA0:  MOVFF  3AA,3AF
06FA4:  MOVFF  3A9,3AE
....................    if(sc2<sc1 && sc1 <sc2 +n) 
06FA8:  MOVLB  3
06FAA:  MOVF   xAF,W
06FAC:  SUBWF  xAD,W
06FAE:  BNC   7016
06FB0:  BNZ   6FB8
06FB2:  MOVF   xAC,W
06FB4:  SUBWF  xAE,W
06FB6:  BC    7016
06FB8:  MOVF   xAB,W
06FBA:  ADDWF  xAE,W
06FBC:  MOVWF  01
06FBE:  MOVLW  00
06FC0:  ADDWFC xAF,W
06FC2:  MOVWF  03
06FC4:  MOVF   xAD,W
06FC6:  SUBWF  03,W
06FC8:  BNC   7016
06FCA:  BNZ   6FD2
06FCC:  MOVF   01,W
06FCE:  SUBWF  xAC,W
06FD0:  BC    7016
....................       for(sc1+=n,sc2+=n;0<n;--n) 
06FD2:  MOVF   xAB,W
06FD4:  ADDWF  xAC,F
06FD6:  MOVLW  00
06FD8:  ADDWFC xAD,F
06FDA:  MOVF   xAB,W
06FDC:  ADDWF  xAE,F
06FDE:  MOVLW  00
06FE0:  ADDWFC xAF,F
06FE2:  MOVF   xAB,W
06FE4:  SUBLW  00
06FE6:  BC    7014
....................          *--sc1=*--sc2; 
06FE8:  MOVF   xAC,W
06FEA:  BTFSC  FD8.2
06FEC:  DECF   xAD,F
06FEE:  DECF   xAC,F
06FF0:  MOVF   xAE,W
06FF2:  BTFSC  FD8.2
06FF4:  DECF   xAF,F
06FF6:  DECF   xAE,F
06FF8:  MOVFF  3AE,FE9
06FFC:  MOVFF  3AF,FEA
07000:  MOVFF  FEF,3B2
07004:  MOVFF  3AD,FEA
07008:  MOVFF  3AC,FE9
0700C:  MOVFF  3B2,FEF
07010:  DECF   xAB,F
07012:  BRA    6FE2
....................    else 
07014:  BRA    7054
....................       for(;0<n;--n) 
07016:  MOVF   xAB,W
07018:  SUBLW  00
0701A:  BC    7054
....................          *sc1++=*sc2++; 
0701C:  MOVFF  3AD,03
07020:  MOVF   xAC,W
07022:  INCF   xAC,F
07024:  BTFSC  FD8.2
07026:  INCF   xAD,F
07028:  MOVWF  xB0
0702A:  MOVFF  03,3B1
0702E:  MOVFF  3AF,03
07032:  MOVF   xAE,W
07034:  INCF   xAE,F
07036:  BTFSC  FD8.2
07038:  INCF   xAF,F
0703A:  MOVWF  FE9
0703C:  MOVFF  03,FEA
07040:  MOVFF  FEF,3B2
07044:  MOVFF  3B1,FEA
07048:  MOVFF  3B0,FE9
0704C:  MOVFF  3B2,FEF
07050:  DECF   xAB,F
07052:  BRA    7016
....................   return s1; 
07054:  MOVFF  3A7,01
07058:  MOVFF  3A8,02
....................   } 
0705C:  MOVLB  0
0705E:  GOTO   7134 (RETURN)
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
074D2:  MOVFF  3BE,3C3
074D6:  MOVFF  3BD,3C2
074DA:  MOVLB  3
074DC:  MOVF   xC1,F
074DE:  BZ    7528
074E0:  MOVFF  3C0,03
074E4:  MOVFF  3BF,FE9
074E8:  MOVFF  3C0,FEA
074EC:  MOVF   FEF,F
074EE:  BZ    7528
....................      *s++ = *s2++; 
074F0:  MOVFF  3C3,03
074F4:  MOVF   xC2,W
074F6:  INCF   xC2,F
074F8:  BTFSC  FD8.2
074FA:  INCF   xC3,F
074FC:  MOVWF  xC4
074FE:  MOVFF  03,3C5
07502:  MOVFF  3C0,03
07506:  MOVF   xBF,W
07508:  INCF   xBF,F
0750A:  BTFSC  FD8.2
0750C:  INCF   xC0,F
0750E:  MOVWF  FE9
07510:  MOVFF  03,FEA
07514:  MOVFF  FEF,3C6
07518:  MOVFF  3C5,FEA
0751C:  MOVFF  3C4,FE9
07520:  MOVFF  3C6,FEF
07524:  DECF   xC1,F
07526:  BRA    74DC
....................   for (; n > 0; n--) 
07528:  MOVF   xC1,F
0752A:  BZ    7544
....................      *s++ = '\0'; 
0752C:  MOVFF  3C3,03
07530:  MOVF   xC2,W
07532:  INCF   xC2,F
07534:  BTFSC  FD8.2
07536:  INCF   xC3,F
07538:  MOVWF  FE9
0753A:  MOVFF  03,FEA
0753E:  CLRF   FEF
07540:  DECF   xC1,F
07542:  BRA    7528
....................  
....................   return(s1); 
07544:  MOVFF  3BD,01
07548:  MOVFF  3BE,02
.................... } 
0754C:  MOVLB  0
0754E:  RETLW  00
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
06B34:  MOVLB  3
06B36:  MOVFF  38A,FE9
06B3A:  MOVFF  38B,FEA
06B3E:  MOVFF  FEF,38E
06B42:  MOVFF  38D,03
06B46:  MOVFF  38C,FE9
06B4A:  MOVFF  38D,FEA
06B4E:  MOVF   FEF,W
06B50:  SUBWF  x8E,W
06B52:  BNZ   6B7E
....................       if (*s1 == '\0') 
06B54:  MOVFF  38B,03
06B58:  MOVFF  38A,FE9
06B5C:  MOVFF  03,FEA
06B60:  MOVF   FEF,F
06B62:  BNZ   6B6A
....................          return(0); 
06B64:  MOVLW  00
06B66:  MOVWF  01
06B68:  BRA    6BA8
06B6A:  MOVFF  38B,03
06B6E:  MOVF   x8A,W
06B70:  INCF   x8A,F
06B72:  BTFSC  FD8.2
06B74:  INCF   x8B,F
06B76:  INCF   x8C,F
06B78:  BTFSC  FD8.2
06B7A:  INCF   x8D,F
06B7C:  BRA    6B36
....................    return((*s1 < *s2) ? -1: 1); 
06B7E:  MOVFF  38B,03
06B82:  MOVFF  38A,FE9
06B86:  MOVFF  38B,FEA
06B8A:  MOVFF  FEF,38E
06B8E:  MOVFF  38D,03
06B92:  MOVFF  38C,FE9
06B96:  MOVFF  38D,FEA
06B9A:  MOVF   FEF,W
06B9C:  SUBWF  x8E,W
06B9E:  BC    6BA4
06BA0:  MOVLW  FF
06BA2:  BRA    6BA6
06BA4:  MOVLW  01
06BA6:  MOVWF  01
.................... } 
06BA8:  MOVLB  0
06BAA:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
06BAC:  MOVFF  3D9,3DB
....................    for(su=s;0<n;++su,--n) 
06BB0:  MOVFF  3D8,3DD
06BB4:  MOVFF  3D7,3DC
06BB8:  MOVLB  3
06BBA:  MOVF   xDA,W
06BBC:  SUBLW  00
06BBE:  BC    6BE6
....................       if(*su==uc) 
06BC0:  MOVFF  3DD,03
06BC4:  MOVFF  3DC,FE9
06BC8:  MOVFF  3DD,FEA
06BCC:  MOVF   xDB,W
06BCE:  SUBWF  FEF,W
06BD0:  BNZ   6BDC
....................       return su; 
06BD2:  MOVFF  3DC,01
06BD6:  MOVFF  3DD,02
06BDA:  BRA    6BEC
06BDC:  INCF   xDC,F
06BDE:  BTFSC  FD8.2
06BE0:  INCF   xDD,F
06BE2:  DECF   xDA,F
06BE4:  BRA    6BBA
....................    return NULL; 
06BE6:  MOVLW  00
06BE8:  MOVWF  01
06BEA:  MOVWF  02
.................... } 
06BEC:  MOVLB  0
06BEE:  RETLW  00
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
06A0A:  MOVFF  395,399
06A0E:  MOVFF  394,398
06A12:  MOVFF  399,03
06A16:  MOVLB  3
06A18:  MOVFF  398,FE9
06A1C:  MOVFF  399,FEA
06A20:  MOVF   FEF,F
06A22:  BZ    6A78
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
06A24:  MOVFF  397,39B
06A28:  MOVFF  396,39A
06A2C:  MOVFF  39B,03
06A30:  MOVFF  39A,FE9
06A34:  MOVFF  39B,FEA
06A38:  MOVF   FEF,F
06A3A:  BZ    6A6C
....................          if (*sc1 == *sc2) 
06A3C:  MOVFF  398,FE9
06A40:  MOVFF  399,FEA
06A44:  MOVFF  FEF,39C
06A48:  MOVFF  39B,03
06A4C:  MOVFF  39A,FE9
06A50:  MOVFF  39B,FEA
06A54:  MOVF   FEF,W
06A56:  SUBWF  x9C,W
06A58:  BNZ   6A64
....................             return(sc1); 
06A5A:  MOVFF  398,01
06A5E:  MOVFF  399,02
06A62:  BRA    6A7E
06A64:  INCF   x9A,F
06A66:  BTFSC  FD8.2
06A68:  INCF   x9B,F
06A6A:  BRA    6A2C
06A6C:  INCF   x98,F
06A6E:  BTFSC  FD8.2
06A70:  INCF   x99,F
06A72:  MOVLB  0
06A74:  BRA    6A12
06A76:  MOVLB  3
....................    return(0); 
06A78:  MOVLW  00
06A7A:  MOVWF  01
06A7C:  MOVWF  02
.................... } 
06A7E:  MOVLB  0
06A80:  GOTO   6AF6 (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0697A:  MOVFF  395,399
0697E:  MOVFF  394,398
06982:  MOVFF  399,03
06986:  MOVLB  3
06988:  MOVFF  398,FE9
0698C:  MOVFF  399,FEA
06990:  MOVF   FEF,F
06992:  BZ    69F4
....................       for (sc2 = s2; ; sc2++) 
06994:  MOVFF  397,39B
06998:  MOVFF  396,39A
....................     if (*sc2 == '\0') 
0699C:  MOVFF  39B,03
069A0:  MOVFF  39A,FE9
069A4:  MOVFF  39B,FEA
069A8:  MOVF   FEF,F
069AA:  BNZ   69C0
....................        return(sc1 - s1); 
069AC:  MOVF   x94,W
069AE:  SUBWF  x98,W
069B0:  MOVWF  00
069B2:  MOVF   x95,W
069B4:  SUBWFB x99,W
069B6:  MOVWF  03
069B8:  MOVFF  00,01
069BC:  BRA    6A04
....................          else if (*sc1 == *sc2) 
069BE:  BRA    69E0
069C0:  MOVFF  398,FE9
069C4:  MOVFF  399,FEA
069C8:  MOVFF  FEF,39C
069CC:  MOVFF  39B,03
069D0:  MOVFF  39A,FE9
069D4:  MOVFF  39B,FEA
069D8:  MOVF   FEF,W
069DA:  SUBWF  x9C,W
069DC:  BNZ   69E0
....................             break; 
069DE:  BRA    69E8
069E0:  INCF   x9A,F
069E2:  BTFSC  FD8.2
069E4:  INCF   x9B,F
069E6:  BRA    699C
069E8:  INCF   x98,F
069EA:  BTFSC  FD8.2
069EC:  INCF   x99,F
069EE:  MOVLB  0
069F0:  BRA    6982
069F2:  MOVLB  3
....................    return(sc1 - s1); 
069F4:  MOVF   x94,W
069F6:  SUBWF  x98,W
069F8:  MOVWF  00
069FA:  MOVF   x95,W
069FC:  SUBWFB x99,W
069FE:  MOVWF  03
06A00:  MOVFF  00,01
.................... } 
06A04:  MOVLB  0
06A06:  GOTO   6AB4 (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
06A84:  MOVLB  3
06A86:  MOVF   x8C,W
06A88:  IORWF  x8D,W
06A8A:  BZ    6A94
06A8C:  MOVFF  38D,03
06A90:  MOVF   x8C,W
06A92:  BRA    6A9A
06A94:  MOVFF  48,03
06A98:  MOVF   47,W
06A9A:  MOVWF  x90
06A9C:  MOVFF  03,391
....................    beg += strspn(beg, s2); 
06AA0:  MOVFF  391,395
06AA4:  MOVFF  390,394
06AA8:  MOVFF  38F,397
06AAC:  MOVFF  38E,396
06AB0:  MOVLB  0
06AB2:  BRA    697A
06AB4:  MOVF   01,W
06AB6:  MOVLB  3
06AB8:  ADDWF  x90,F
06ABA:  MOVLW  00
06ABC:  ADDWFC x91,F
....................    if (*beg == '\0') 
06ABE:  MOVFF  391,03
06AC2:  MOVFF  390,FE9
06AC6:  MOVFF  391,FEA
06ACA:  MOVF   FEF,F
06ACC:  BNZ   6AE2
....................    { 
....................       *save = ' '; 
06ACE:  MOVFF  47,FE9
06AD2:  MOVFF  48,FEA
06AD6:  MOVLW  20
06AD8:  MOVWF  FEF
....................       return(0); 
06ADA:  MOVLW  00
06ADC:  MOVWF  01
06ADE:  MOVWF  02
06AE0:  BRA    6B30
....................    } 
....................    end = strpbrk(beg, s2); 
06AE2:  MOVFF  391,395
06AE6:  MOVFF  390,394
06AEA:  MOVFF  38F,397
06AEE:  MOVFF  38E,396
06AF2:  MOVLB  0
06AF4:  BRA    6A0A
06AF6:  MOVFF  02,393
06AFA:  MOVFF  01,392
....................    if (*end != '\0') 
06AFE:  MOVFF  393,03
06B02:  MOVLB  3
06B04:  MOVFF  392,FE9
06B08:  MOVFF  393,FEA
06B0C:  MOVF   FEF,F
06B0E:  BZ    6B20
....................    { 
....................       *end = '\0'; 
06B10:  MOVFF  392,FE9
06B14:  MOVFF  393,FEA
06B18:  CLRF   FEF
....................       end++; 
06B1A:  INCF   x92,F
06B1C:  BTFSC  FD8.2
06B1E:  INCF   x93,F
....................    } 
....................    save = end; 
06B20:  MOVFF  393,48
06B24:  MOVFF  392,47
....................    return(beg); 
06B28:  MOVFF  390,01
06B2C:  MOVFF  391,02
.................... } 
06B30:  MOVLB  0
06B32:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
06F5E:  MOVFF  3BE,3C0
06F62:  MOVFF  3BD,3BF
06F66:  MOVFF  3C0,03
06F6A:  MOVLB  3
06F6C:  MOVFF  3BF,FE9
06F70:  MOVFF  3C0,FEA
06F74:  MOVF   FEF,F
06F76:  BZ    6F84
06F78:  INCF   xBF,F
06F7A:  BTFSC  FD8.2
06F7C:  INCF   xC0,F
06F7E:  MOVLB  0
06F80:  BRA    6F66
06F82:  MOVLB  3
....................    return(sc - s); 
06F84:  MOVF   xBD,W
06F86:  SUBWF  xBF,W
06F88:  MOVWF  00
06F8A:  MOVF   xBE,W
06F8C:  SUBWFB xC0,W
06F8E:  MOVWF  03
06F90:  MOVFF  00,01
.................... } 
06F94:  MOVLB  0
06F96:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
0714E:  MOVLB  3
07150:  MOVFF  3A4,FE9
07154:  MOVFF  3A5,FEA
07158:  MOVFF  FEF,3A8
0715C:  MOVFF  3A7,03
07160:  MOVFF  3A6,FE9
07164:  MOVFF  3A7,FEA
07168:  MOVF   FEF,W
0716A:  SUBWF  xA8,W
0716C:  BZ    71FE
0716E:  MOVFF  3A5,03
07172:  MOVFF  3A4,FE9
07176:  MOVFF  3A5,FEA
0717A:  MOVFF  FEF,3A8
0717E:  MOVF   xA8,W
07180:  SUBLW  40
07182:  BC    718A
07184:  MOVF   xA8,W
07186:  SUBLW  5A
07188:  BC    7196
0718A:  MOVF   xA8,W
0718C:  SUBLW  60
0718E:  BC    7228
07190:  MOVF   xA8,W
07192:  SUBLW  7A
07194:  BNC   7228
07196:  MOVFF  3A7,03
0719A:  MOVFF  3A6,FE9
0719E:  MOVFF  3A7,FEA
071A2:  MOVFF  FEF,3A8
071A6:  MOVF   xA8,W
071A8:  SUBLW  40
071AA:  BC    71B2
071AC:  MOVF   xA8,W
071AE:  SUBLW  5A
071B0:  BC    71BE
071B2:  MOVF   xA8,W
071B4:  SUBLW  60
071B6:  BC    7228
071B8:  MOVF   xA8,W
071BA:  SUBLW  7A
071BC:  BNC   7228
071BE:  MOVFF  3A4,FE9
071C2:  MOVFF  3A5,FEA
071C6:  MOVFF  FEF,3A8
071CA:  MOVFF  3A7,03
071CE:  MOVFF  3A6,FE9
071D2:  MOVFF  3A7,FEA
071D6:  MOVLW  20
071D8:  ADDWF  FEF,W
071DA:  SUBWF  xA8,W
071DC:  BZ    71FE
071DE:  MOVFF  3A6,FE9
071E2:  MOVFF  3A7,FEA
071E6:  MOVFF  FEF,3A8
071EA:  MOVFF  3A5,03
071EE:  MOVFF  3A4,FE9
071F2:  MOVFF  3A5,FEA
071F6:  MOVLW  20
071F8:  ADDWF  FEF,W
071FA:  SUBWF  xA8,W
071FC:  BNZ   7228
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
071FE:  MOVFF  3A5,03
07202:  MOVFF  3A4,FE9
07206:  MOVFF  3A5,FEA
0720A:  MOVF   FEF,F
0720C:  BNZ   7214
....................        return(0); 
0720E:  MOVLW  00
07210:  MOVWF  01
07212:  BRA    7252
07214:  MOVFF  3A5,03
07218:  MOVF   xA4,W
0721A:  INCF   xA4,F
0721C:  BTFSC  FD8.2
0721E:  INCF   xA5,F
07220:  INCF   xA6,F
07222:  BTFSC  FD8.2
07224:  INCF   xA7,F
07226:  BRA    7150
....................  return((*s1 < *s2) ? -1: 1); 
07228:  MOVFF  3A5,03
0722C:  MOVFF  3A4,FE9
07230:  MOVFF  3A5,FEA
07234:  MOVFF  FEF,3A8
07238:  MOVFF  3A7,03
0723C:  MOVFF  3A6,FE9
07240:  MOVFF  3A7,FEA
07244:  MOVF   FEF,W
07246:  SUBWF  xA8,W
07248:  BC    724E
0724A:  MOVLW  FF
0724C:  BRA    7250
0724E:  MOVLW  01
07250:  MOVWF  01
.................... } 
07252:  MOVLB  0
07254:  RETLW  00
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
07330:  MOVLB  3
07332:  CLRF   xA9
....................    sign = 0; 
07334:  CLRF   xA7
....................    base = 10; 
07336:  MOVLW  0A
07338:  MOVWF  xA8
....................    result = 0; 
0733A:  CLRF   xA6
....................  
....................    if (!s) 
0733C:  MOVF   xA4,W
0733E:  IORWF  xA5,W
07340:  BNZ   7348
....................       return 0; 
07342:  MOVLW  00
07344:  MOVWF  01
07346:  BRA    74CE
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
07348:  MOVF   xA9,W
0734A:  INCF   xA9,F
0734C:  CLRF   03
0734E:  ADDWF  xA4,W
07350:  MOVWF  FE9
07352:  MOVF   xA5,W
07354:  ADDWFC 03,W
07356:  MOVWF  FEA
07358:  MOVFF  FEF,3AA
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0735C:  MOVF   xAA,W
0735E:  SUBLW  2D
07360:  BNZ   737C
....................    { 
....................       sign = 1;         // Set the sign to negative 
07362:  MOVLW  01
07364:  MOVWF  xA7
....................       c = s[index++]; 
07366:  MOVF   xA9,W
07368:  INCF   xA9,F
0736A:  CLRF   03
0736C:  ADDWF  xA4,W
0736E:  MOVWF  FE9
07370:  MOVF   xA5,W
07372:  ADDWFC 03,W
07374:  MOVWF  FEA
07376:  MOVFF  FEF,3AA
....................    } 
....................    else if (c == '+') 
0737A:  BRA    7396
0737C:  MOVF   xAA,W
0737E:  SUBLW  2B
07380:  BNZ   7396
....................    { 
....................       c = s[index++]; 
07382:  MOVF   xA9,W
07384:  INCF   xA9,F
07386:  CLRF   03
07388:  ADDWF  xA4,W
0738A:  MOVWF  FE9
0738C:  MOVF   xA5,W
0738E:  ADDWFC 03,W
07390:  MOVWF  FEA
07392:  MOVFF  FEF,3AA
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
07396:  MOVF   xAA,W
07398:  SUBLW  2F
0739A:  BTFSC  FD8.0
0739C:  BRA    74BE
0739E:  MOVF   xAA,W
073A0:  SUBLW  39
073A2:  BTFSS  FD8.0
073A4:  BRA    74BE
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
073A6:  MOVF   xAA,W
073A8:  SUBLW  30
073AA:  BNZ   73EE
073AC:  CLRF   03
073AE:  MOVF   xA9,W
073B0:  ADDWF  xA4,W
073B2:  MOVWF  FE9
073B4:  MOVF   xA5,W
073B6:  ADDWFC 03,W
073B8:  MOVWF  FEA
073BA:  MOVF   FEF,W
073BC:  SUBLW  78
073BE:  BZ    73D4
073C0:  CLRF   03
073C2:  MOVF   xA9,W
073C4:  ADDWF  xA4,W
073C6:  MOVWF  FE9
073C8:  MOVF   xA5,W
073CA:  ADDWFC 03,W
073CC:  MOVWF  FEA
073CE:  MOVF   FEF,W
073D0:  SUBLW  58
073D2:  BNZ   73EE
....................       { 
....................          base = 16; 
073D4:  MOVLW  10
073D6:  MOVWF  xA8
....................          index++; 
073D8:  INCF   xA9,F
....................          c = s[index++]; 
073DA:  MOVF   xA9,W
073DC:  INCF   xA9,F
073DE:  CLRF   03
073E0:  ADDWF  xA4,W
073E2:  MOVWF  FE9
073E4:  MOVF   xA5,W
073E6:  ADDWFC 03,W
073E8:  MOVWF  FEA
073EA:  MOVFF  FEF,3AA
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
073EE:  MOVF   xA8,W
073F0:  SUBLW  0A
073F2:  BNZ   742E
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
073F4:  MOVF   xAA,W
073F6:  SUBLW  2F
073F8:  BC    742C
073FA:  MOVF   xAA,W
073FC:  SUBLW  39
073FE:  BNC   742C
....................             result = 10*result + (c - '0'); 
07400:  MOVLW  0A
07402:  MOVWF  xAB
07404:  MOVFF  3A6,3AC
07408:  MOVLB  0
0740A:  BRA    72E0
0740C:  MOVLW  30
0740E:  MOVLB  3
07410:  SUBWF  xAA,W
07412:  ADDWF  01,W
07414:  MOVWF  xA6
....................             c = s[index++]; 
07416:  MOVF   xA9,W
07418:  INCF   xA9,F
0741A:  CLRF   03
0741C:  ADDWF  xA4,W
0741E:  MOVWF  FE9
07420:  MOVF   xA5,W
07422:  ADDWFC 03,W
07424:  MOVWF  FEA
07426:  MOVFF  FEF,3AA
....................          } 
0742A:  BRA    73F4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0742C:  BRA    74BE
0742E:  MOVF   xA8,W
07430:  SUBLW  10
07432:  BNZ   74BE
....................       { 
....................          c = toupper(c); 
07434:  MOVF   xAA,W
07436:  SUBLW  60
07438:  BC    7446
0743A:  MOVF   xAA,W
0743C:  SUBLW  7A
0743E:  BNC   7446
07440:  MOVF   xAA,W
07442:  ANDLW  DF
07444:  BRA    7448
07446:  MOVF   xAA,W
07448:  MOVWF  xAA
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0744A:  MOVF   xAA,W
0744C:  SUBLW  2F
0744E:  BC    7456
07450:  MOVF   xAA,W
07452:  SUBLW  39
07454:  BC    7462
07456:  MOVF   xAA,W
07458:  SUBLW  40
0745A:  BC    74BE
0745C:  MOVF   xAA,W
0745E:  SUBLW  46
07460:  BNC   74BE
....................             if (c >= '0' && c <= '9') 
07462:  MOVF   xAA,W
07464:  SUBLW  2F
07466:  BC    7480
07468:  MOVF   xAA,W
0746A:  SUBLW  39
0746C:  BNC   7480
....................                result = (result << 4) + (c - '0'); 
0746E:  SWAPF  xA6,W
07470:  MOVWF  xAB
07472:  MOVLW  F0
07474:  ANDWF  xAB,F
07476:  MOVLW  30
07478:  SUBWF  xAA,W
0747A:  ADDWF  xAB,W
0747C:  MOVWF  xA6
....................             else 
0747E:  BRA    7492
....................                result = (result << 4) + (c - 'A' + 10); 
07480:  SWAPF  xA6,W
07482:  MOVWF  xAB
07484:  MOVLW  F0
07486:  ANDWF  xAB,F
07488:  MOVLW  41
0748A:  SUBWF  xAA,W
0748C:  ADDLW  0A
0748E:  ADDWF  xAB,W
07490:  MOVWF  xA6
....................  
....................             c = s[index++]; 
07492:  MOVF   xA9,W
07494:  INCF   xA9,F
07496:  CLRF   03
07498:  ADDWF  xA4,W
0749A:  MOVWF  FE9
0749C:  MOVF   xA5,W
0749E:  ADDWFC 03,W
074A0:  MOVWF  FEA
074A2:  MOVFF  FEF,3AA
....................             c = toupper(c); 
074A6:  MOVF   xAA,W
074A8:  SUBLW  60
074AA:  BC    74B8
074AC:  MOVF   xAA,W
074AE:  SUBLW  7A
074B0:  BNC   74B8
074B2:  MOVF   xAA,W
074B4:  ANDLW  DF
074B6:  BRA    74BA
074B8:  MOVF   xAA,W
074BA:  MOVWF  xAA
....................          } 
074BC:  BRA    744A
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
074BE:  DECFSZ xA7,W
074C0:  BRA    74CA
074C2:  MOVF   xA8,W
074C4:  SUBLW  0A
074C6:  BNZ   74CA
....................        result = -result; 
074C8:  NEGF   xA6
....................  
....................    return(result); 
074CA:  MOVFF  3A6,01
.................... } 
074CE:  MOVLB  0
074D0:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
028DA:  MOVLB  3
028DC:  CLRF   x97
....................    sign = 0; 
028DE:  CLRF   x95
....................    base = 10; 
028E0:  MOVLW  0A
028E2:  MOVWF  x96
....................    result = 0; 
028E4:  CLRF   x94
028E6:  CLRF   x93
....................  
....................    if (!s) 
028E8:  MOVF   x91,W
028EA:  IORWF  x92,W
028EC:  BNZ   28F6
....................       return 0; 
028EE:  MOVLW  00
028F0:  MOVWF  01
028F2:  MOVWF  02
028F4:  BRA    2AC6
....................    c = s[index++]; 
028F6:  MOVF   x97,W
028F8:  INCF   x97,F
028FA:  CLRF   03
028FC:  ADDWF  x91,W
028FE:  MOVWF  FE9
02900:  MOVF   x92,W
02902:  ADDWFC 03,W
02904:  MOVWF  FEA
02906:  MOVFF  FEF,398
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0290A:  MOVF   x98,W
0290C:  SUBLW  2D
0290E:  BNZ   292A
....................    { 
....................       sign = 1;         // Set the sign to negative 
02910:  MOVLW  01
02912:  MOVWF  x95
....................       c = s[index++]; 
02914:  MOVF   x97,W
02916:  INCF   x97,F
02918:  CLRF   03
0291A:  ADDWF  x91,W
0291C:  MOVWF  FE9
0291E:  MOVF   x92,W
02920:  ADDWFC 03,W
02922:  MOVWF  FEA
02924:  MOVFF  FEF,398
....................    } 
....................    else if (c == '+') 
02928:  BRA    2944
0292A:  MOVF   x98,W
0292C:  SUBLW  2B
0292E:  BNZ   2944
....................    { 
....................       c = s[index++]; 
02930:  MOVF   x97,W
02932:  INCF   x97,F
02934:  CLRF   03
02936:  ADDWF  x91,W
02938:  MOVWF  FE9
0293A:  MOVF   x92,W
0293C:  ADDWFC 03,W
0293E:  MOVWF  FEA
02940:  MOVFF  FEF,398
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
02944:  MOVF   x98,W
02946:  SUBLW  2F
02948:  BTFSC  FD8.0
0294A:  BRA    2AAA
0294C:  MOVF   x98,W
0294E:  SUBLW  39
02950:  BTFSS  FD8.0
02952:  BRA    2AAA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
02954:  MOVF   x98,W
02956:  SUBLW  30
02958:  BNZ   299C
0295A:  CLRF   03
0295C:  MOVF   x97,W
0295E:  ADDWF  x91,W
02960:  MOVWF  FE9
02962:  MOVF   x92,W
02964:  ADDWFC 03,W
02966:  MOVWF  FEA
02968:  MOVF   FEF,W
0296A:  SUBLW  78
0296C:  BZ    2982
0296E:  CLRF   03
02970:  MOVF   x97,W
02972:  ADDWF  x91,W
02974:  MOVWF  FE9
02976:  MOVF   x92,W
02978:  ADDWFC 03,W
0297A:  MOVWF  FEA
0297C:  MOVF   FEF,W
0297E:  SUBLW  58
02980:  BNZ   299C
....................       { 
....................          base = 16; 
02982:  MOVLW  10
02984:  MOVWF  x96
....................          index++; 
02986:  INCF   x97,F
....................          c = s[index++]; 
02988:  MOVF   x97,W
0298A:  INCF   x97,F
0298C:  CLRF   03
0298E:  ADDWF  x91,W
02990:  MOVWF  FE9
02992:  MOVF   x92,W
02994:  ADDWFC 03,W
02996:  MOVWF  FEA
02998:  MOVFF  FEF,398
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0299C:  MOVF   x96,W
0299E:  SUBLW  0A
029A0:  BNZ   29E8
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
029A2:  MOVF   x98,W
029A4:  SUBLW  2F
029A6:  BC    29E6
029A8:  MOVF   x98,W
029AA:  SUBLW  39
029AC:  BNC   29E6
....................             result = 10*result + (c - '0'); 
029AE:  CLRF   xD9
029B0:  MOVLW  0A
029B2:  MOVWF  xD8
029B4:  MOVFF  394,3DB
029B8:  MOVFF  393,3DA
029BC:  MOVLB  0
029BE:  RCALL  2886
029C0:  MOVLW  30
029C2:  MOVLB  3
029C4:  SUBWF  x98,W
029C6:  ADDWF  01,W
029C8:  MOVWF  x93
029CA:  MOVLW  00
029CC:  ADDWFC 02,W
029CE:  MOVWF  x94
....................             c = s[index++]; 
029D0:  MOVF   x97,W
029D2:  INCF   x97,F
029D4:  CLRF   03
029D6:  ADDWF  x91,W
029D8:  MOVWF  FE9
029DA:  MOVF   x92,W
029DC:  ADDWFC 03,W
029DE:  MOVWF  FEA
029E0:  MOVFF  FEF,398
....................          } 
029E4:  BRA    29A2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
029E6:  BRA    2AAA
029E8:  MOVF   x96,W
029EA:  SUBLW  10
029EC:  BNZ   2AAA
....................       { 
....................          c = toupper(c); 
029EE:  MOVF   x98,W
029F0:  SUBLW  60
029F2:  BC    2A00
029F4:  MOVF   x98,W
029F6:  SUBLW  7A
029F8:  BNC   2A00
029FA:  MOVF   x98,W
029FC:  ANDLW  DF
029FE:  BRA    2A02
02A00:  MOVF   x98,W
02A02:  MOVWF  x98
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
02A04:  MOVF   x98,W
02A06:  SUBLW  2F
02A08:  BC    2A10
02A0A:  MOVF   x98,W
02A0C:  SUBLW  39
02A0E:  BC    2A1C
02A10:  MOVF   x98,W
02A12:  SUBLW  40
02A14:  BC    2AAA
02A16:  MOVF   x98,W
02A18:  SUBLW  46
02A1A:  BNC   2AAA
....................             if (c >= '0' && c <= '9') 
02A1C:  MOVF   x98,W
02A1E:  SUBLW  2F
02A20:  BC    2A54
02A22:  MOVF   x98,W
02A24:  SUBLW  39
02A26:  BNC   2A54
....................                result = (result << 4) + (c - '0'); 
02A28:  RLCF   x93,W
02A2A:  MOVWF  x99
02A2C:  RLCF   x94,W
02A2E:  MOVWF  x9A
02A30:  RLCF   x99,F
02A32:  RLCF   x9A,F
02A34:  RLCF   x99,F
02A36:  RLCF   x9A,F
02A38:  RLCF   x99,F
02A3A:  RLCF   x9A,F
02A3C:  MOVLW  F0
02A3E:  ANDWF  x99,F
02A40:  MOVLW  30
02A42:  SUBWF  x98,W
02A44:  ADDWF  x99,W
02A46:  MOVWF  01
02A48:  MOVLW  00
02A4A:  ADDWFC x9A,W
02A4C:  MOVFF  01,393
02A50:  MOVWF  x94
....................             else 
02A52:  BRA    2A80
....................                result = (result << 4) + (c - 'A' + 10); 
02A54:  RLCF   x93,W
02A56:  MOVWF  x99
02A58:  RLCF   x94,W
02A5A:  MOVWF  x9A
02A5C:  RLCF   x99,F
02A5E:  RLCF   x9A,F
02A60:  RLCF   x99,F
02A62:  RLCF   x9A,F
02A64:  RLCF   x99,F
02A66:  RLCF   x9A,F
02A68:  MOVLW  F0
02A6A:  ANDWF  x99,F
02A6C:  MOVLW  41
02A6E:  SUBWF  x98,W
02A70:  ADDLW  0A
02A72:  ADDWF  x99,W
02A74:  MOVWF  01
02A76:  MOVLW  00
02A78:  ADDWFC x9A,W
02A7A:  MOVFF  01,393
02A7E:  MOVWF  x94
....................  
....................             c = s[index++];c = toupper(c); 
02A80:  MOVF   x97,W
02A82:  INCF   x97,F
02A84:  CLRF   03
02A86:  ADDWF  x91,W
02A88:  MOVWF  FE9
02A8A:  MOVF   x92,W
02A8C:  ADDWFC 03,W
02A8E:  MOVWF  FEA
02A90:  MOVF   FEF,W
02A92:  MOVWF  x98
02A94:  SUBLW  60
02A96:  BC    2AA4
02A98:  MOVF   x98,W
02A9A:  SUBLW  7A
02A9C:  BNC   2AA4
02A9E:  MOVF   x98,W
02AA0:  ANDLW  DF
02AA2:  BRA    2AA6
02AA4:  MOVF   x98,W
02AA6:  MOVWF  x98
....................          } 
02AA8:  BRA    2A04
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
02AAA:  MOVF   x96,W
02AAC:  SUBLW  0A
02AAE:  BNZ   2ABE
02AB0:  DECFSZ x95,W
02AB2:  BRA    2ABE
....................       result = -result; 
02AB4:  COMF   x93,F
02AB6:  COMF   x94,F
02AB8:  INCF   x93,F
02ABA:  BTFSC  FD8.2
02ABC:  INCF   x94,F
....................  
....................    return(result); 
02ABE:  MOVFF  393,01
02AC2:  MOVFF  394,02
.................... } 
02AC6:  MOVLB  0
02AC8:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
*
06BF0:  MOVLB  3
06BF2:  CLRF   xAF
06BF4:  CLRF   xB0
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
06BF6:  MOVLW  30
06BF8:  MOVWF  xB2
06BFA:  MOVLW  31
06BFC:  MOVWF  xB3
06BFE:  MOVLW  32
06C00:  MOVWF  xB4
06C02:  MOVLW  33
06C04:  MOVWF  xB5
06C06:  MOVLW  34
06C08:  MOVWF  xB6
06C0A:  MOVLW  35
06C0C:  MOVWF  xB7
06C0E:  MOVLW  36
06C10:  MOVWF  xB8
06C12:  MOVLW  37
06C14:  MOVWF  xB9
06C16:  MOVLW  38
06C18:  MOVWF  xBA
06C1A:  MOVLW  39
06C1C:  MOVWF  xBB
06C1E:  MOVLW  61
06C20:  MOVWF  xBC
06C22:  MOVLW  62
06C24:  MOVWF  xBD
06C26:  MOVLW  63
06C28:  MOVWF  xBE
06C2A:  MOVLW  64
06C2C:  MOVWF  xBF
06C2E:  MOVLW  65
06C30:  MOVWF  xC0
06C32:  MOVLW  66
06C34:  MOVWF  xC1
06C36:  MOVLW  67
06C38:  MOVWF  xC2
06C3A:  MOVLW  68
06C3C:  MOVWF  xC3
06C3E:  MOVLW  69
06C40:  MOVWF  xC4
06C42:  MOVLW  6A
06C44:  MOVWF  xC5
06C46:  MOVLW  6B
06C48:  MOVWF  xC6
06C4A:  MOVLW  6C
06C4C:  MOVWF  xC7
06C4E:  MOVLW  6D
06C50:  MOVWF  xC8
06C52:  MOVLW  6E
06C54:  MOVWF  xC9
06C56:  MOVLW  6F
06C58:  MOVWF  xCA
06C5A:  MOVLW  70
06C5C:  MOVWF  xCB
06C5E:  MOVLW  71
06C60:  MOVWF  xCC
06C62:  MOVLW  73
06C64:  MOVWF  xCD
06C66:  MOVLW  74
06C68:  MOVWF  xCE
06C6A:  MOVLW  75
06C6C:  MOVWF  xCF
06C6E:  MOVLW  76
06C70:  MOVWF  xD0
06C72:  MOVLW  77
06C74:  MOVWF  xD1
06C76:  MOVLW  78
06C78:  MOVWF  xD2
06C7A:  MOVLW  79
06C7C:  MOVWF  xD3
06C7E:  MOVLW  7A
06C80:  MOVWF  xD4
06C82:  CLRF   xD5
....................    for(sc=s;isspace(*sc);++sc); 
06C84:  MOVFF  3A5,3AA
06C88:  MOVFF  3A4,3A9
06C8C:  MOVFF  3AA,03
06C90:  MOVFF  3A9,FE9
06C94:  MOVFF  3AA,FEA
06C98:  MOVF   FEF,W
06C9A:  SUBLW  20
06C9C:  BNZ   6CA6
06C9E:  INCF   xA9,F
06CA0:  BTFSC  FD8.2
06CA2:  INCF   xAA,F
06CA4:  BRA    6C8C
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
06CA6:  MOVFF  3AA,03
06CAA:  MOVFF  3A9,FE9
06CAE:  MOVFF  3AA,FEA
06CB2:  MOVF   FEF,W
06CB4:  SUBLW  2D
06CB6:  BZ    6CCA
06CB8:  MOVFF  3AA,03
06CBC:  MOVFF  3A9,FE9
06CC0:  MOVFF  3AA,FEA
06CC4:  MOVF   FEF,W
06CC6:  SUBLW  2B
06CC8:  BNZ   6CE0
06CCA:  MOVFF  3AA,03
06CCE:  MOVF   xA9,W
06CD0:  INCF   xA9,F
06CD2:  BTFSC  FD8.2
06CD4:  INCF   xAA,F
06CD6:  MOVWF  FE9
06CD8:  MOVFF  03,FEA
06CDC:  MOVF   FEF,W
06CDE:  BRA    6CE2
06CE0:  MOVLW  2B
06CE2:  MOVWF  xB1
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
06CE4:  MOVF   xB1,W
06CE6:  SUBLW  2D
06CE8:  BZ    6CFE
06CEA:  BTFSC  xA8.7
06CEC:  BRA    6CFE
06CEE:  DECFSZ xA8,W
06CF0:  BRA    6CF4
06CF2:  BRA    6CFE
06CF4:  BTFSC  xA8.7
06CF6:  BRA    6D02
06CF8:  MOVF   xA8,W
06CFA:  SUBLW  24
06CFC:  BC    6D02
....................    goto StrtoulGO; 
06CFE:  BRA    6F18
....................  
....................    else if (base) 
06D00:  BRA    6E0A
06D02:  MOVF   xA8,F
06D04:  BZ    6D9E
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
06D06:  MOVF   xA8,W
06D08:  SUBLW  10
06D0A:  BNZ   6D4A
06D0C:  MOVFF  3AA,03
06D10:  MOVFF  3A9,FE9
06D14:  MOVFF  3AA,FEA
06D18:  MOVF   FEF,W
06D1A:  SUBLW  30
06D1C:  BNZ   6D4A
06D1E:  MOVLW  01
06D20:  ADDWF  xA9,W
06D22:  MOVWF  FE9
06D24:  MOVLW  00
06D26:  ADDWFC xAA,W
06D28:  MOVWF  FEA
06D2A:  MOVF   FEF,W
06D2C:  SUBLW  78
06D2E:  BZ    6D42
06D30:  MOVLW  01
06D32:  ADDWF  xA9,W
06D34:  MOVWF  FE9
06D36:  MOVLW  00
06D38:  ADDWFC xAA,W
06D3A:  MOVWF  FEA
06D3C:  MOVF   FEF,W
06D3E:  SUBLW  58
06D40:  BNZ   6D4A
....................          sc+=2; 
06D42:  MOVLW  02
06D44:  ADDWF  xA9,F
06D46:  MOVLW  00
06D48:  ADDWFC xAA,F
....................       if(base==8 && *sc =='0') 
06D4A:  MOVF   xA8,W
06D4C:  SUBLW  08
06D4E:  BNZ   6D6A
06D50:  MOVFF  3AA,03
06D54:  MOVFF  3A9,FE9
06D58:  MOVFF  3AA,FEA
06D5C:  MOVF   FEF,W
06D5E:  SUBLW  30
06D60:  BNZ   6D6A
....................          sc+=1; 
06D62:  MOVLW  01
06D64:  ADDWF  xA9,F
06D66:  MOVLW  00
06D68:  ADDWFC xAA,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
06D6A:  MOVF   xA8,W
06D6C:  SUBLW  02
06D6E:  BNZ   6D9C
06D70:  MOVFF  3AA,03
06D74:  MOVFF  3A9,FE9
06D78:  MOVFF  3AA,FEA
06D7C:  MOVF   FEF,W
06D7E:  SUBLW  30
06D80:  BNZ   6D9C
06D82:  MOVLW  01
06D84:  ADDWF  xA9,W
06D86:  MOVWF  FE9
06D88:  MOVLW  00
06D8A:  ADDWFC xAA,W
06D8C:  MOVWF  FEA
06D8E:  MOVF   FEF,W
06D90:  SUBLW  62
06D92:  BNZ   6D9C
....................          sc+=2; 
06D94:  MOVLW  02
06D96:  ADDWF  xA9,F
06D98:  MOVLW  00
06D9A:  ADDWFC xAA,F
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
06D9C:  BRA    6E0A
06D9E:  MOVFF  3AA,03
06DA2:  MOVFF  3A9,FE9
06DA6:  MOVFF  3AA,FEA
06DAA:  MOVF   FEF,W
06DAC:  SUBLW  30
06DAE:  BZ    6DB6
....................       base=10; 
06DB0:  MOVLW  0A
06DB2:  MOVWF  xA8
....................    else if (sc[1]=='x' || sc[1]=='X') 
06DB4:  BRA    6E0A
06DB6:  MOVLW  01
06DB8:  ADDWF  xA9,W
06DBA:  MOVWF  FE9
06DBC:  MOVLW  00
06DBE:  ADDWFC xAA,W
06DC0:  MOVWF  FEA
06DC2:  MOVF   FEF,W
06DC4:  SUBLW  78
06DC6:  BZ    6DDA
06DC8:  MOVLW  01
06DCA:  ADDWF  xA9,W
06DCC:  MOVWF  FE9
06DCE:  MOVLW  00
06DD0:  ADDWFC xAA,W
06DD2:  MOVWF  FEA
06DD4:  MOVF   FEF,W
06DD6:  SUBLW  58
06DD8:  BNZ   6DE8
....................       base =16,sc+=2; 
06DDA:  MOVLW  10
06DDC:  MOVWF  xA8
06DDE:  MOVLW  02
06DE0:  ADDWF  xA9,F
06DE2:  MOVLW  00
06DE4:  ADDWFC xAA,F
....................    else if(sc[1]=='b') 
06DE6:  BRA    6E0A
06DE8:  MOVLW  01
06DEA:  ADDWF  xA9,W
06DEC:  MOVWF  FE9
06DEE:  MOVLW  00
06DF0:  ADDWFC xAA,W
06DF2:  MOVWF  FEA
06DF4:  MOVF   FEF,W
06DF6:  SUBLW  62
06DF8:  BNZ   6E06
....................       base=2,sc+=2; 
06DFA:  MOVLW  02
06DFC:  MOVWF  xA8
06DFE:  ADDWF  xA9,F
06E00:  MOVLW  00
06E02:  ADDWFC xAA,F
....................    else 
06E04:  BRA    6E0A
....................       base=8; 
06E06:  MOVLW  08
06E08:  MOVWF  xA8
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
06E0A:  MOVFF  3AA,3AC
06E0E:  MOVFF  3A9,3AB
06E12:  MOVFF  3AA,03
06E16:  MOVFF  3A9,FE9
06E1A:  MOVFF  3AA,FEA
06E1E:  MOVF   FEF,W
06E20:  SUBLW  30
06E22:  BNZ   6E2C
06E24:  INCF   xA9,F
06E26:  BTFSC  FD8.2
06E28:  INCF   xAA,F
06E2A:  BRA    6E12
....................    sd=memchr(digits,tolower(*sc),base); 
06E2C:  MOVFF  3AA,03
06E30:  MOVFF  3A9,FE9
06E34:  MOVFF  3AA,FEA
06E38:  MOVFF  FEF,3D6
06E3C:  MOVF   xD6,W
06E3E:  SUBLW  40
06E40:  BC    6E4E
06E42:  MOVF   xD6,W
06E44:  SUBLW  5A
06E46:  BNC   6E4E
06E48:  MOVF   xD6,W
06E4A:  IORLW  20
06E4C:  BRA    6E50
06E4E:  MOVF   xD6,W
06E50:  MOVWF  xD6
06E52:  MOVLW  03
06E54:  MOVWF  xD8
06E56:  MOVLW  B2
06E58:  MOVWF  xD7
06E5A:  MOVFF  3D6,3D9
06E5E:  MOVFF  3A8,3DA
06E62:  MOVLB  0
06E64:  RCALL  6BAC
06E66:  MOVFF  02,3AE
06E6A:  MOVFF  01,3AD
....................    for(; sd!=0; ) 
06E6E:  MOVLB  3
06E70:  MOVF   xAD,F
06E72:  BNZ   6E78
06E74:  MOVF   xAE,F
06E76:  BZ    6F0C
....................    { 
....................       x=x*base+(int16)(sd-digits); 
06E78:  CLRF   03
06E7A:  MOVF   xA8,W
06E7C:  MOVWF  00
06E7E:  BTFSC  FE8.7
06E80:  DECF   03,F
06E82:  MOVWF  xD6
06E84:  MOVFF  03,3D7
06E88:  MOVFF  3B0,3D9
06E8C:  MOVFF  3AF,3D8
06E90:  MOVFF  03,3DB
06E94:  MOVWF  xDA
06E96:  MOVLB  0
06E98:  CALL   2886
06E9C:  MOVFF  01,3D6
06EA0:  MOVLW  B2
06EA2:  MOVLB  3
06EA4:  SUBWF  xAD,W
06EA6:  MOVWF  00
06EA8:  MOVLW  03
06EAA:  SUBWFB xAE,W
06EAC:  MOVWF  03
06EAE:  MOVF   00,W
06EB0:  ADDWF  01,W
06EB2:  MOVWF  01
06EB4:  MOVF   02,W
06EB6:  ADDWFC 03,F
06EB8:  MOVFF  01,3AF
06EBC:  MOVFF  03,3B0
....................       ++sc; 
06EC0:  INCF   xA9,F
06EC2:  BTFSC  FD8.2
06EC4:  INCF   xAA,F
....................       sd=memchr(digits,tolower(*sc),base); 
06EC6:  MOVFF  3AA,03
06ECA:  MOVFF  3A9,FE9
06ECE:  MOVFF  3AA,FEA
06ED2:  MOVFF  FEF,3D6
06ED6:  MOVF   xD6,W
06ED8:  SUBLW  40
06EDA:  BC    6EE8
06EDC:  MOVF   xD6,W
06EDE:  SUBLW  5A
06EE0:  BNC   6EE8
06EE2:  MOVF   xD6,W
06EE4:  IORLW  20
06EE6:  BRA    6EEA
06EE8:  MOVF   xD6,W
06EEA:  MOVWF  xD6
06EEC:  MOVLW  03
06EEE:  MOVWF  xD8
06EF0:  MOVLW  B2
06EF2:  MOVWF  xD7
06EF4:  MOVFF  3D6,3D9
06EF8:  MOVFF  3A8,3DA
06EFC:  MOVLB  0
06EFE:  RCALL  6BAC
06F00:  MOVFF  02,3AE
06F04:  MOVFF  01,3AD
....................    } 
06F08:  BRA    6E6E
06F0A:  MOVLB  3
....................    if(s1==sc) 
06F0C:  MOVF   xA9,W
06F0E:  SUBWF  xAB,W
06F10:  BNZ   6F38
06F12:  MOVF   xAA,W
06F14:  SUBWF  xAC,W
06F16:  BNZ   6F38
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
06F18:  MOVF   xA6,W
06F1A:  IORWF  xA7,W
06F1C:  BZ    6F30
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
06F1E:  MOVFF  3A6,FE9
06F22:  MOVFF  3A7,FEA
06F26:  MOVFF  3A5,FEC
06F2A:  MOVF   FED,F
06F2C:  MOVFF  3A4,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
06F30:  MOVLW  00
06F32:  MOVWF  01
06F34:  MOVWF  02
06F36:  BRA    6F58
....................    } 
....................    if (endptr) 
06F38:  MOVF   xA6,W
06F3A:  IORWF  xA7,W
06F3C:  BZ    6F50
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
06F3E:  MOVFF  3A6,FE9
06F42:  MOVFF  3A7,FEA
06F46:  MOVFF  3AA,FEC
06F4A:  MOVF   FED,F
06F4C:  MOVFF  3A9,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
06F50:  MOVFF  3AF,01
06F54:  MOVFF  3B0,02
.................... } 
06F58:  MOVLB  0
06F5A:  GOTO   70E2 (RETURN)
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01632:  MOVFF  4C,382
01636:  MOVFF  4B,381
0163A:  MOVFF  4A,380
0163E:  MOVFF  49,37F
01642:  MOVLW  41
01644:  MOVLB  3
01646:  MOVWF  x86
01648:  MOVLW  C6
0164A:  MOVWF  x85
0164C:  MOVLW  4E
0164E:  MOVWF  x84
01650:  MOVLW  6D
01652:  MOVWF  x83
01654:  MOVLB  0
01656:  BRA    158C
01658:  MOVLW  39
0165A:  MOVLB  3
0165C:  ADDWF  00,W
0165E:  MOVWF  49
01660:  MOVLW  30
01662:  ADDWFC 01,W
01664:  MOVWF  4A
01666:  MOVLW  00
01668:  ADDWFC 02,W
0166A:  MOVWF  4B
0166C:  MOVLW  00
0166E:  ADDWFC 03,W
01670:  MOVWF  4C
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
01672:  MOVFF  4B,00
01676:  MOVFF  4C,01
0167A:  CLRF   02
0167C:  CLRF   03
0167E:  MOVFF  4C,381
01682:  MOVFF  4B,380
01686:  MOVFF  4C,383
0168A:  MOVFF  4B,382
0168E:  MOVLW  7F
01690:  MOVWF  x85
01692:  MOVLW  FF
01694:  MOVWF  x84
01696:  MOVLB  0
01698:  BRA    15EA
0169A:  MOVFF  00,01
0169E:  MOVFF  03,02
.................... } 
016A2:  GOTO   17B8 (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01578:  MOVFF  382,4C
0157C:  MOVFF  381,4B
01580:  MOVFF  380,4A
01584:  MOVFF  37F,49
.................... } 
01588:  GOTO   17B6 (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
03142:  MOVFF  42B,42C
....................     new.v[1]=v.v[0]; 
03146:  MOVFF  42A,42D
....................  
....................     return(new.Val); 
0314A:  MOVLB  4
0314C:  MOVFF  42C,01
03150:  MOVFF  42D,02
.................... } 
03154:  MOVLB  0
03156:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
04436:  MOVFF  416,417
....................     new.v[1]=v.v[2]; 
0443A:  MOVFF  415,418
....................     new.v[2]=v.v[1]; 
0443E:  MOVFF  414,419
....................     new.v[3]=v.v[0]; 
04442:  MOVFF  413,41A
....................  
....................     return(new.Val); 
04446:  MOVFF  417,00
0444A:  MOVFF  418,01
0444E:  MOVFF  419,02
04452:  MOVFF  41A,03
.................... } 
04456:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
03DFC:  MOVLB  4
03DFE:  CLRF   x1C
03E00:  CLRF   x1B
03E02:  CLRF   x1A
03E04:  CLRF   x19
....................  
.................... 	i = count >> 1; 
03E06:  BCF    FD8.0
03E08:  RRCF   x10,W
03E0A:  MOVWF  x12
03E0C:  RRCF   x0F,W
03E0E:  MOVWF  x11
.................... 	val = (WORD *)buffer; 
03E10:  MOVFF  40E,414
03E14:  MOVFF  40D,413
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
03E18:  MOVFF  412,03
03E1C:  MOVF   x11,W
03E1E:  BTFSC  FD8.2
03E20:  DECF   x12,F
03E22:  DECF   x11,F
03E24:  IORWF  03,W
03E26:  BZ    3E56
03E28:  MOVFF  414,03
03E2C:  MOVFF  413,00
03E30:  MOVLW  02
03E32:  ADDWF  x13,F
03E34:  BTFSC  FD8.0
03E36:  INCF   x14,F
03E38:  MOVFF  00,FE9
03E3C:  MOVFF  03,FEA
03E40:  MOVFF  FEC,03
03E44:  MOVF   FED,F
03E46:  MOVF   FEF,W
03E48:  ADDWF  x19,F
03E4A:  MOVF   03,W
03E4C:  ADDWFC x1A,F
03E4E:  MOVLW  00
03E50:  ADDWFC x1B,F
03E52:  ADDWFC x1C,F
03E54:  BRA    3E18
....................  
.................... 	if ( count & 1 ) 
03E56:  MOVF   x0F,W
03E58:  ANDLW  01
03E5A:  MOVWF  00
03E5C:  CLRF   03
03E5E:  MOVF   00,W
03E60:  IORWF  03,W
03E62:  BZ    3E78
.................... 		sum.Val += *(BYTE *)val; 
03E64:  MOVFF  413,FE9
03E68:  MOVFF  414,FEA
03E6C:  MOVF   FEF,W
03E6E:  ADDWF  x19,F
03E70:  MOVLW  00
03E72:  ADDWFC x1A,F
03E74:  ADDWFC x1B,F
03E76:  ADDWFC x1C,F
....................  
.................... 	tempSum.Val = sum.Val; 
03E78:  MOVFF  41C,418
03E7C:  MOVFF  41B,417
03E80:  MOVFF  41A,416
03E84:  MOVFF  419,415
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
03E88:  MOVFF  418,412
03E8C:  MOVFF  417,411
03E90:  MOVF   x11,F
03E92:  BNZ   3E98
03E94:  MOVF   x12,F
03E96:  BZ    3ED6
.................... 		sum.words.MSB.Val = 0; 
03E98:  CLRF   x1C
03E9A:  CLRF   x1B
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
03E9C:  CLRF   x20
03E9E:  CLRF   x1F
03EA0:  MOVFF  41A,41E
03EA4:  MOVFF  419,41D
03EA8:  CLRF   02
03EAA:  CLRF   03
03EAC:  MOVF   x11,W
03EAE:  ADDWF  x19,W
03EB0:  MOVWF  x19
03EB2:  MOVF   x12,W
03EB4:  ADDWFC x1A,W
03EB6:  MOVWF  x1A
03EB8:  MOVF   02,W
03EBA:  ADDWFC x1F,W
03EBC:  MOVWF  x1B
03EBE:  MOVF   03,W
03EC0:  ADDWFC x20,W
03EC2:  MOVWF  x1C
.................... 		tempSum.Val = sum.Val; 
03EC4:  MOVFF  41C,418
03EC8:  MOVFF  41B,417
03ECC:  MOVFF  41A,416
03ED0:  MOVFF  419,415
.................... 	} 
03ED4:  BRA    3E88
....................  
.................... 	return (~sum.words.LSB.Val); 
03ED6:  MOVFF  41A,03
03EDA:  COMF   03,F
03EDC:  MOVF   x19,W
03EDE:  XORLW  FF
03EE0:  MOVWF  01
03EE2:  MOVFF  03,02
.................... } 
03EE6:  MOVLB  0
03EE8:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
00FF2:  MOVLW  83
00FF4:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
00FF6:  MOVLW  0B
00FF8:  MOVWF  FD7
00FFA:  MOVLW  DB
00FFC:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
00FFE:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
01000:  MOVLW  C0
01002:  IORWF  FF2,F
.................... } 
01004:  GOTO   198A (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
0485C:  BCF    FF2.5
....................     ret=TickCount; 
0485E:  MOVFF  4F,3CF
04862:  MOVFF  4E,3CE
....................     enable_interrupts(INT_TIMER0); 
04866:  BSF    FF2.5
....................     return ret; 
04868:  MOVLB  3
0486A:  MOVFF  3CE,01
0486E:  MOVFF  3CF,02
.................... } 
04872:  MOVLB  0
04874:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
000B4:  INCF   4E,F
000B6:  BTFSC  FD8.2
000B8:  INCF   4F,F
....................  
....................         second_counter_intermediate++; 
000BA:  INCF   51,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
000BC:  MOVF   51,W
000BE:  SUBLW  09
000C0:  BC    00C6
....................             second_counter++; //increment this ever 1s 
000C2:  INCF   50,F
....................             second_counter_intermediate=0; 
000C4:  CLRF   51
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
000C6:  MOVLW  0B
000C8:  MOVWF  FD7
000CA:  MOVLW  DB
000CC:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *					     MAC.h 
....................  *					     string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *					     Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date   		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		6/28/04	Original 
....................  * Howard Schlunder		10/8/04	Cleanup 
....................  * Howard Schlunder		10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder		11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder		12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder		1/09/06	Added comments and minor mods 
....................  * Howard Schlunder		1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder		2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE		//due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
....................  
.................... #define SPISelectEthernet()		output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()	output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS	(TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO	(LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS		(TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO		(LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //		flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //		other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //		done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a) 					(a & 0xFF) 
.................... #define HIGH(a) 				((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE	8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART	(0ul)						// Should be an even memory address 
.................... #define	RXSTOP	((TXSTART-2ul) | 0x0001ul)	// Odd for errata workaround 
.................... #define RXSIZE	(RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define	WCR (0b010<<5)			// Write Control Register command 
.................... #define BFS (0b100<<5)			// Bit Field Set command 
.................... #define	BFC (0b101<<5)			// Bit Field Clear command 
.................... #define	RCR (0b000<<5)			// Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)	// Read Buffer Memory command 
.................... #define	WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define	SR  ((0b111<<5) | 0x1F)	// System Reset command does not use an address. 
.................... 								//   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP	(0x00u) 
.................... #define ETHER_ARP	(0x06u) 
....................  
.................... #define MAXFRAMEC	(1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
000CE:  BCF    FF2.2
000D0:  GOTO   0054
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16			NextPacketPointer; 
....................     RXSTATUS		StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
.................... 	WORD_VAL StartAddress; 
.................... 	WORD_VAL EndAddress; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bFree : 1; 
.................... 		unsigned char bTransmitted : 1; 
.................... 	} Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
*
00B8C:  MOVLW  03
00B8E:  IORWF  F93,F
00B90:  MOVF   F94,W
00B92:  ANDLW  D7
00B94:  IORLW  10
00B96:  MOVWF  F94
00B98:  MOVLW  F4
00B9A:  ANDWF  F95,F
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
00B9C:  BCF    FC6.5
00B9E:  MOVLW  20
00BA0:  MOVWF  FC6
00BA2:  MOVLW  40
00BA4:  MOVWF  FC7
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
.................... 	// 
.................... 	// Set up the SPI module on the PIC for communications with the ENC28J60 
.................... 	// 
.................... 	SPIUnselectEthernet(); 
00BA6:  BCF    F95.1
00BA8:  BSF    F8C.1
....................  
.................... 	// Deassert the nRESET pin on the ENC28J60.  The internal 
.................... 	// weak pull on the nRESET pin will get the job done anyway, 
.................... 	// so this isn't necessary, but it may provide extra noise immunity, 
.................... 	// should someone put their finger on the pin or otherwise cause a leakage 
.................... 	// path to ground on this pin. 
.................... 	output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00BAA:  BCF    F95.0
00BAC:  BSF    F8C.0
.................... } 
00BAE:  RETLW  00
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
*
01008:  MOVF   FC9,W
0100A:  MOVFF  435,FC9
0100E:  RRCF   FC7,W
01010:  BNC   100E
01012:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
01016:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *					registers in the ENC28J60 so that normal operation can 
....................  *					begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
.................... 	BYTE i; 
....................  
....................    ENCSPIInit(); 
*
012EC:  RCALL  0B8C
....................  
.................... 	// Wait for CLKRDY to become set. 
.................... 	// Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
.................... 	// means the part is in RESET or otherwise our SPI pin is being driven 
.................... 	// incorrectly.  Make sure it is working before proceeding. 
.................... 	do 
.................... 	{ 
.................... 		i = ReadETHReg(ESTAT).Val; 
012EE:  MOVLW  1D
012F0:  MOVLB  4
012F2:  MOVWF  x2A
012F4:  MOVLB  0
012F6:  RCALL  1018
012F8:  MOVFF  01,37C
.................... 	} while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
012FC:  MOVLB  3
012FE:  BTFSS  x7C.3
01300:  BRA    1306
01302:  MOVLB  0
01304:  BRA    12EE
01306:  MOVF   x7C,W
01308:  XORLW  FF
0130A:  ANDLW  01
0130C:  BTFSC  FD8.2
0130E:  BRA    1314
01310:  MOVLB  0
01312:  BRA    12EE
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
.................... 	// Do the memory test and enter a while always trap if a hardware error 
.................... 	// occured.  The LEDA and LEDB pins will be configured to blink 
.................... 	// periodically in an abnormal manner to indicate to the user that the 
.................... 	// error occured. 
.................... 	if( !TestMemory() ) 
.................... 	{ 
.................... 		SetLEDConfig(0x0AA2);		// Set LEDs to blink periodically 
.................... 		while(1); 
.................... 	} 
.................... #endif 
....................  
.................... 	// RESET the entire ENC28J60, clearing all registers 
.................... 	SendSystemReset(); 
01314:  MOVLB  0
01316:  BRA    1042
....................     delay_ms(1); 
01318:  MOVLW  01
0131A:  MOVLB  3
0131C:  MOVWF  xA7
0131E:  MOVLB  0
01320:  CALL   0A04
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
01324:  CLRF   4D
....................  
.................... 	// Start up in Bank 0 and configure the receive buffer boundary pointers 
.................... 	// and the buffer write protect pointer (receive buffer read pointer) 
.................... 	WasDiscarded = TRUE; 
01326:  BSF    56.0
.................... 	NextPacketLocation.Val = RXSTART; 
01328:  CLRF   53
0132A:  CLRF   52
.................... 	WriteReg(ERXSTL, LOW(RXSTART)); 
0132C:  MOVLW  08
0132E:  MOVLB  4
01330:  MOVWF  x30
01332:  CLRF   x31
01334:  MOVLB  0
01336:  RCALL  1058
.................... 	WriteReg(ERXSTH, HIGH(RXSTART)); 
01338:  MOVLW  09
0133A:  MOVLB  4
0133C:  MOVWF  x30
0133E:  CLRF   x31
01340:  MOVLB  0
01342:  RCALL  1058
.................... 	WriteReg(ERXRDPTL, LOW(RXSTOP));	// Write low byte first 
01344:  MOVLW  0C
01346:  MOVLB  4
01348:  MOVWF  x30
0134A:  MOVLW  F7
0134C:  MOVWF  x31
0134E:  MOVLB  0
01350:  RCALL  1058
.................... 	WriteReg(ERXRDPTH, HIGH(RXSTOP));	// Write high byte last 
01352:  MOVLW  0D
01354:  MOVLB  4
01356:  MOVWF  x30
01358:  MOVLW  1B
0135A:  MOVWF  x31
0135C:  MOVLB  0
0135E:  RCALL  1058
.................... #if RXSTOP != 0x1FFF	// The RESET default ERXND is 0x1FFF 
.................... 	WriteReg(ERXNDL, LOW(RXSTOP)); 
01360:  MOVLW  0A
01362:  MOVLB  4
01364:  MOVWF  x30
01366:  MOVLW  F7
01368:  MOVWF  x31
0136A:  MOVLB  0
0136C:  RCALL  1058
.................... 	WriteReg(ERXNDH, HIGH(RXSTOP)); 
0136E:  MOVLW  0B
01370:  MOVLB  4
01372:  MOVWF  x30
01374:  MOVLW  1B
01376:  MOVWF  x31
01378:  MOVLB  0
0137A:  RCALL  1058
.................... #endif 
.................... #if TXSTART != 0		// The RESET default ETXST is 0 
.................... 	WriteReg(ETXSTL, LOW(TXSTART)); 
0137C:  MOVLW  04
0137E:  MOVLB  4
01380:  MOVWF  x30
01382:  MOVLW  F8
01384:  MOVWF  x31
01386:  MOVLB  0
01388:  RCALL  1058
.................... 	WriteReg(ETXSTH, HIGH(TXSTART)); 
0138A:  MOVLW  05
0138C:  MOVLB  4
0138E:  MOVWF  x30
01390:  MOVLW  1B
01392:  MOVWF  x31
01394:  MOVLB  0
01396:  RCALL  1058
.................... #endif 
....................  
.................... 	// Enter Bank 1 and configure Receive Filters 
.................... 	// (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
.................... 	// acceptable) 
.................... 	// Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
.................... 	//BankSel(ERXFCON); 
.................... 	//WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
.................... 	// Enter Bank 2 and configure the MAC 
.................... 	BankSel(MACON1); 
01398:  MOVLW  02
0139A:  MOVLB  4
0139C:  MOVWF  x2E
0139E:  CLRF   x2D
013A0:  MOVLB  0
013A2:  RCALL  10B2
....................  
.................... 	// Enable the receive portion of the MAC 
.................... 	WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
013A4:  MOVLB  4
013A6:  CLRF   x30
013A8:  MOVLW  0D
013AA:  MOVWF  x31
013AC:  MOVLB  0
013AE:  RCALL  1058
....................  
.................... 	// Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... 	WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
013B0:  MOVLW  02
013B2:  MOVLB  4
013B4:  MOVWF  x30
013B6:  MOVLW  32
013B8:  MOVWF  x31
013BA:  MOVLB  0
013BC:  RCALL  1058
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
013BE:  MOVLW  03
013C0:  MOVLB  4
013C2:  MOVWF  x30
013C4:  MOVLW  40
013C6:  MOVWF  x31
013C8:  MOVLB  0
013CA:  RCALL  1058
....................  
.................... 	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
.................... 	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
.................... 	// collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
013CC:  MOVLW  09
013CE:  MOVLB  4
013D0:  MOVWF  x30
013D2:  MOVLW  3F
013D4:  MOVWF  x31
013D6:  MOVLB  0
013D8:  RCALL  1058
....................  
.................... 	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
.................... 	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
.................... 	// later. 
.................... 	WriteReg((BYTE)MAIPGL, 0x12); 
013DA:  MOVLW  06
013DC:  MOVLB  4
013DE:  MOVWF  x30
013E0:  MOVLW  12
013E2:  MOVWF  x31
013E4:  MOVLB  0
013E6:  RCALL  1058
.................... 	WriteReg((BYTE)MAIPGH, 0x0C); 
013E8:  MOVLW  07
013EA:  MOVLB  4
013EC:  MOVWF  x30
013EE:  MOVLW  0C
013F0:  MOVWF  x31
013F2:  MOVLB  0
013F4:  RCALL  1058
....................  
.................... 	// Set the maximum packet size which the controller will accept 
.................... 	WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
013F6:  MOVLW  0A
013F8:  MOVLB  4
013FA:  MOVWF  x30
013FC:  MOVLW  EE
013FE:  MOVWF  x31
01400:  MOVLB  0
01402:  RCALL  1058
.................... 	WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
01404:  MOVLW  0B
01406:  MOVLB  4
01408:  MOVWF  x30
0140A:  MOVLW  05
0140C:  MOVWF  x31
0140E:  MOVLB  0
01410:  RCALL  1058
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
.................... 	BankSel(MAADR1); 
01412:  MOVLW  03
01414:  MOVLB  4
01416:  MOVWF  x2E
01418:  MOVLW  04
0141A:  MOVWF  x2D
0141C:  MOVLB  0
0141E:  RCALL  10B2
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
01420:  MOVLW  04
01422:  MOVLB  4
01424:  MOVWF  x30
01426:  MOVFF  1A,431
0142A:  MOVLB  0
0142C:  RCALL  1058
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0142E:  MOVLW  05
01430:  MOVLB  4
01432:  MOVWF  x30
01434:  MOVFF  1B,431
01438:  MOVLB  0
0143A:  RCALL  1058
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0143C:  MOVLW  02
0143E:  MOVLB  4
01440:  MOVWF  x30
01442:  MOVFF  1C,431
01446:  MOVLB  0
01448:  RCALL  1058
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0144A:  MOVLW  03
0144C:  MOVLB  4
0144E:  MOVWF  x30
01450:  MOVFF  1D,431
01454:  MOVLB  0
01456:  RCALL  1058
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
01458:  MOVLB  4
0145A:  CLRF   x30
0145C:  MOVFF  1E,431
01460:  MOVLB  0
01462:  RCALL  1058
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
01464:  MOVLW  01
01466:  MOVLB  4
01468:  MOVWF  x30
0146A:  MOVFF  1F,431
0146E:  MOVLB  0
01470:  RCALL  1058
....................  
.................... 	// Get the Rev ID so that we can implement the correct errata workarounds 
.................... 	ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
01472:  MOVLW  12
01474:  MOVLB  4
01476:  MOVWF  x2A
01478:  MOVLB  0
0147A:  RCALL  1018
0147C:  MOVFF  01,57
....................  
.................... 	// Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
.................... 	// side effect. 
.................... 	WritePHYReg(PHCON2, PHCON2_HDLDIS); 
01480:  MOVLW  10
01482:  MOVLB  3
01484:  MOVWF  x81
01486:  MOVLW  01
01488:  MOVWF  x83
0148A:  CLRF   x82
0148C:  MOVLB  0
0148E:  RCALL  111A
....................  
.................... 	// Configure LEDA to display LINK status, LEDB to display TX/RX activity 
.................... 	SetLEDConfig(0x0472); 
01490:  MOVLW  14
01492:  MOVLB  3
01494:  MOVWF  x81
01496:  MOVLW  04
01498:  MOVWF  x83
0149A:  MOVLW  72
0149C:  MOVWF  x82
0149E:  MOVLB  0
014A0:  RCALL  111A
....................  
.................... 	// Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
.................... 	MACSetDuplex(FULL);		// Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
.................... 	MACSetDuplex(HALF);		// Function exits with Bank 2 selected 
014A2:  MOVLB  3
014A4:  CLRF   x7D
014A6:  MOVLB  0
014A8:  BRA    124C
.................... #else 
.................... 	// Use the external LEDB polarity to determine weather full or half duplex 
.................... 	// communication mode should be set. 
.................... 	MACSetDuplex(USE_PHY);	// Function exits with Bank 2 selected 
.................... #endif 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
014AA:  MOVLW  1F
014AC:  MOVLB  4
014AE:  MOVWF  x32
014B0:  MOVLW  04
014B2:  MOVWF  x33
014B4:  MOVLB  0
014B6:  RCALL  1094
.................... }//end MACInit 
014B8:  GOTO   198C (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *						  and the link has been up continuously since the last 
....................  *						  call to MACIsLinked() 
....................  *					FALSE: If the PHY reports no link partner, or the link went 
....................  *						   down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
.................... 	// LLSTAT is a latching low link status bit.  Therefore, if the link 
.................... 	// goes down and comes back up before a higher level stack program calls 
.................... 	// MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
.................... 	// call to MACIsLinked() will return TRUE (unless the link goes down 
.................... 	// again). 
.................... 	return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
02F04:  MOVLW  01
02F06:  MOVLB  3
02F08:  MOVWF  x82
02F0A:  MOVLB  0
02F0C:  CALL   11B0
02F10:  MOVFF  01,382
02F14:  MOVLW  00
02F16:  MOVLB  3
02F18:  BTFSC  01.2
02F1A:  MOVLW  01
02F1C:  MOVWF  01
.................... } 
02F1E:  MOVLB  0
02F20:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *								  FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *					FALSE: If a previous transmission was started, and it has 
....................  *						   not completed yet.  While FALSE, the data in the 
....................  *						   transmit buffer and the TXST/TXND pointers must not 
....................  *						   be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
0497A:  MOVLW  1F
0497C:  MOVLB  4
0497E:  MOVWF  x2A
04980:  MOVLB  0
04982:  CALL   1018
04986:  MOVFF  01,40C
0498A:  MOVLW  00
0498C:  MOVLB  4
0498E:  BTFSC  01.3
04990:  MOVLW  01
04992:  XORLW  00
04994:  BZ    499A
04996:  MOVLW  00
04998:  BRA    499C
0499A:  MOVLW  01
0499C:  MOVWF  01
0499E:  BRA    49A0
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
.................... 	// Check if the current buffer can be modified.  It cannot be modified if 
.................... 	// the TX hardware is currently transmitting it. 
.................... 	if(CurrentTxBuffer == LastTXedBuffer) 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
.................... 	} 
....................  
.................... 	// Check if a buffer is available for a new packet 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			return TRUE; 
.................... 		} 
.................... 	} 
....................  
.................... 	return FALSE; 
.................... #endif 
.................... } 
049A0:  MOVLB  0
049A2:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 		return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
0344A:  MOVLW  1F
0344C:  MOVLB  4
0344E:  MOVWF  x2A
03450:  MOVLB  0
03452:  CALL   1018
03456:  MOVFF  01,40C
0345A:  MOVLW  00
0345C:  MOVLB  4
0345E:  BTFSC  01.3
03460:  MOVLW  01
03462:  XORLW  00
03464:  BNZ   346A
03466:  MOVLW  00
03468:  BRA    346C
0346A:  MOVLW  FF
0346C:  MOVWF  01
0346E:  BRA    3470
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Find a free buffer.  Do not use buffer 0, it is reserved for 
.................... 	// high priority messages that don't need to be acknowledged 
.................... 	// before being discarded (TCP control packets, all ICMP 
.................... 	// packets, all UDP packets, etc.) 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		// If this buffer is free, then mark it as used and return with it 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			TxBuffers[i].Flags.bFree = FALSE; 
.................... 			TxBuffers[i].Flags.bTransmitted = FALSE; 
.................... 			return i; 
.................... 		} 
.................... 	} 
....................  
.................... 	return INVALID_BUFFER; 
.................... #endif 
.................... } 
03470:  MOVLB  0
03472:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
.................... 	{ 
.................... 	    TxBuffers[buffer].Flags.bFree = TRUE; 
.................... 	    CurrentTxBuffer = buffer; 
.................... 	} 
.................... #endif 
.................... } 
*
00004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *					MACGetHeader())as being processed and frees the buffer 
....................  *					memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
.................... 	WORD_VAL NewRXRDLocation; 
....................  
.................... 	// Make sure the current packet was not already discarded 
.................... 	if( WasDiscarded ) 
*
03070:  BTFSS  56.0
03072:  BRA    3076
.................... 		return; 
03074:  BRA    30DC
.................... 	WasDiscarded = TRUE; 
03076:  BSF    56.0
....................  
.................... 	// Decrement the next packet pointer before writing it into 
.................... 	// the ERXRDPT registers.  This is a silicon errata workaround. 
.................... 	// RX buffer wrapping must be taken into account if the 
.................... 	// NextPacketLocation is precisely RXSTART. 
.................... 	NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
03078:  MOVLW  01
0307A:  SUBWF  52,W
0307C:  MOVLB  3
0307E:  MOVWF  xCE
03080:  MOVLW  00
03082:  SUBWFB 53,W
03084:  MOVWF  xCF
.................... #if RXSTART == 0 
.................... 	if(NewRXRDLocation.Val > RXSTOP) 
03086:  MOVF   xCF,W
03088:  SUBLW  1A
0308A:  BC    309E
0308C:  XORLW  FF
0308E:  BNZ   3096
03090:  MOVF   xCE,W
03092:  SUBLW  F7
03094:  BC    309E
.................... #else 
.................... 	if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		NewRXRDLocation.Val = RXSTOP; 
03096:  MOVLW  1B
03098:  MOVWF  xCF
0309A:  MOVLW  F7
0309C:  MOVWF  xCE
.................... 	} 
....................  
.................... 	// Decrement the RX packet counter register, EPKTCNT 
.................... 	BFSReg(ECON2, ECON2_PKTDEC); 
0309E:  MOVLW  1E
030A0:  MOVLB  4
030A2:  MOVWF  x32
030A4:  MOVLW  40
030A6:  MOVWF  x33
030A8:  MOVLB  0
030AA:  CALL   1094
....................  
.................... 	// Move the receive read pointer to unwrite-protect the memory used by the 
.................... 	// last packet.  The writing order is important: set the low byte first, 
.................... 	// high byte last. 
.................... 	BankSel(ERXRDPTL); 
030AE:  MOVLB  4
030B0:  CLRF   x2E
030B2:  MOVLW  0C
030B4:  MOVWF  x2D
030B6:  MOVLB  0
030B8:  CALL   10B2
.................... 	WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
030BC:  MOVLW  0C
030BE:  MOVLB  4
030C0:  MOVWF  x30
030C2:  MOVFF  3CE,431
030C6:  MOVLB  0
030C8:  CALL   1058
.................... 	WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
030CC:  MOVLW  0D
030CE:  MOVLB  4
030D0:  MOVWF  x30
030D2:  MOVFF  3CF,431
030D6:  MOVLB  0
030D8:  CALL   1058
.................... } 
030DC:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *					the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
.................... 	WORD_VAL ReadPT, WritePT; 
....................  
.................... 	// Read the Ethernet hardware buffer write pointer.  Because packets can be 
.................... 	// received at any time, it can change between reading the low and high 
.................... 	// bytes.  A loop is necessary to make certain a proper low/high byte pair 
.................... 	// is read. 
.................... 	BankSel(EPKTCNT); 
*
049A4:  MOVLW  01
049A6:  MOVLB  4
049A8:  MOVWF  x2E
049AA:  MOVLW  19
049AC:  MOVWF  x2D
049AE:  MOVLB  0
049B0:  CALL   10B2
.................... 	do { 
.................... 		// Save EPKTCNT in a temporary location 
.................... 		ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
049B4:  MOVLW  19
049B6:  MOVLB  4
049B8:  MOVWF  x2A
049BA:  MOVLB  0
049BC:  CALL   1018
049C0:  MOVFF  01,40B
....................  
.................... 		BankSel(ERXWRPTL); 
049C4:  MOVLB  4
049C6:  CLRF   x2E
049C8:  MOVLW  0E
049CA:  MOVWF  x2D
049CC:  MOVLB  0
049CE:  CALL   10B2
.................... 		WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
049D2:  MOVLW  0E
049D4:  MOVLB  4
049D6:  MOVWF  x2A
049D8:  MOVLB  0
049DA:  CALL   1018
049DE:  MOVFF  01,40D
.................... 		WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
049E2:  MOVLW  0F
049E4:  MOVLB  4
049E6:  MOVWF  x2A
049E8:  MOVLB  0
049EA:  CALL   1018
049EE:  MOVFF  01,40E
....................  
.................... 		BankSel(EPKTCNT); 
049F2:  MOVLW  01
049F4:  MOVLB  4
049F6:  MOVWF  x2E
049F8:  MOVLW  19
049FA:  MOVWF  x2D
049FC:  MOVLB  0
049FE:  CALL   10B2
.................... 	} while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
04A02:  MOVLW  19
04A04:  MOVLB  4
04A06:  MOVWF  x2A
04A08:  MOVLB  0
04A0A:  CALL   1018
04A0E:  MOVFF  01,40F
04A12:  MOVLB  4
04A14:  MOVF   x0B,W
04A16:  SUBWF  01,W
04A18:  BTFSC  FD8.2
04A1A:  BRA    4A20
04A1C:  MOVLB  0
04A1E:  BRA    49B4
....................  
.................... 	// Determine where the write protection pointer is 
.................... 	BankSel(ERXRDPTL); 
04A20:  CLRF   x2E
04A22:  MOVLW  0C
04A24:  MOVWF  x2D
04A26:  MOVLB  0
04A28:  CALL   10B2
.................... 	ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
04A2C:  MOVLW  0C
04A2E:  MOVLB  4
04A30:  MOVWF  x2A
04A32:  MOVLB  0
04A34:  CALL   1018
04A38:  MOVFF  01,40B
.................... 	ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
04A3C:  MOVLW  0D
04A3E:  MOVLB  4
04A40:  MOVWF  x2A
04A42:  MOVLB  0
04A44:  CALL   1018
04A48:  MOVFF  01,40C
....................  
.................... 	// Calculate the difference between the pointers, taking care to account 
.................... 	// for buffer wrapping conditions 
.................... 	if ( WritePT.Val > ReadPT.Val ) 
04A4C:  MOVLB  4
04A4E:  MOVF   x0C,W
04A50:  SUBWF  x0E,W
04A52:  BNC   4A80
04A54:  BNZ   4A5C
04A56:  MOVF   x0D,W
04A58:  SUBWF  x0B,W
04A5A:  BC    4A80
.................... 	{ 
.................... 		return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
04A5C:  MOVF   x0B,W
04A5E:  SUBWF  x0D,W
04A60:  MOVWF  00
04A62:  MOVF   x0C,W
04A64:  SUBWFB x0E,W
04A66:  MOVWF  03
04A68:  MOVF   00,W
04A6A:  XORLW  FF
04A6C:  ADDLW  F8
04A6E:  MOVWF  00
04A70:  MOVLW  1B
04A72:  SUBFWB 03,F
04A74:  MOVFF  00,01
04A78:  MOVFF  03,02
04A7C:  BRA    4AB8
.................... 	} 
.................... 	else if ( WritePT.Val == ReadPT.Val ) 
04A7E:  BRA    4AB8
04A80:  MOVF   x0B,W
04A82:  SUBWF  x0D,W
04A84:  BNZ   4A98
04A86:  MOVF   x0C,W
04A88:  SUBWF  x0E,W
04A8A:  BNZ   4A98
.................... 	{ 
.................... 		return RXSIZE - 1; 
04A8C:  MOVLW  F7
04A8E:  MOVWF  01
04A90:  MOVLW  1B
04A92:  MOVWF  02
04A94:  BRA    4AB8
.................... 	} 
.................... 	else 
04A96:  BRA    4AB8
....................     { 
.................... 		return ReadPT.Val - WritePT.Val - 1; 
04A98:  MOVF   x0D,W
04A9A:  SUBWF  x0B,W
04A9C:  MOVWF  x0F
04A9E:  MOVF   x0E,W
04AA0:  SUBWFB x0C,W
04AA2:  MOVWF  x10
04AA4:  MOVLW  01
04AA6:  SUBWF  x0F,W
04AA8:  MOVWF  00
04AAA:  MOVLW  00
04AAC:  SUBWFB x10,W
04AAE:  MOVWF  03
04AB0:  MOVFF  00,01
04AB4:  MOVWF  02
04AB6:  BRA    4AB8
.................... 	} 
.................... } 
04AB8:  MOVLB  0
04ABA:  GOTO   4D4A (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *							 received frame. 
....................  *					*type: Location of a BYTE to store the constant 
....................  *						   MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *						   the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *						  remote, and type values are updated. 
....................  *					FALSE: If a packet was not pending.  remote and type are 
....................  *						   not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *					been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
.................... 	ENC_PREAMBLE header; 
....................  
.................... 	// Test if at least one packet has been received and is waiting 
.................... 	BankSel(EPKTCNT); 
*
03158:  MOVLW  01
0315A:  MOVLB  4
0315C:  MOVWF  x2E
0315E:  MOVLW  19
03160:  MOVWF  x2D
03162:  MOVLB  0
03164:  CALL   10B2
.................... 	if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
03168:  MOVLW  19
0316A:  MOVLB  4
0316C:  MOVWF  x2A
0316E:  MOVLB  0
03170:  CALL   1018
03174:  MOVFF  01,39A
03178:  MOVLB  3
0317A:  MOVF   x9A,F
0317C:  BNZ   3184
.................... 		return FALSE; 
0317E:  MOVLW  00
03180:  MOVWF  01
03182:  BRA    328E
....................  
.................... 	// Make absolutely certain that any previous packet was discarded 
.................... 	if(WasDiscarded == FALSE) 
03184:  BTFSC  56.0
03186:  BRA    3194
.................... 	{ 
.................... 		MACDiscardRx(); 
03188:  MOVLB  0
0318A:  RCALL  3070
.................... 		return FALSE; 
0318C:  MOVLW  00
0318E:  MOVWF  01
03190:  MOVLB  3
03192:  BRA    328E
.................... 	} 
....................  
.................... 	// Save the location of this packet 
.................... 	CurrentPacketLocation.Val = NextPacketLocation.Val; 
03194:  MOVFF  53,55
03198:  MOVFF  52,54
....................  
.................... 	// Set the SPI read pointer to the beginning of the next unprocessed packet 
.................... 	BankSel(ERDPTL); 
0319C:  MOVLB  4
0319E:  CLRF   x2E
031A0:  CLRF   x2D
031A2:  MOVLB  0
031A4:  CALL   10B2
.................... 	WriteReg(ERDPTL, NextPacketLocation.v[0]); 
031A8:  MOVLB  4
031AA:  CLRF   x30
031AC:  MOVFF  52,431
031B0:  MOVLB  0
031B2:  CALL   1058
.................... 	WriteReg(ERDPTH, NextPacketLocation.v[1]); 
031B6:  MOVLW  01
031B8:  MOVLB  4
031BA:  MOVWF  x30
031BC:  MOVFF  53,431
031C0:  MOVLB  0
031C2:  CALL   1058
....................  
.................... 	// Obtain the MAC header from the Ethernet buffer 
.................... 	MACGetArray((BYTE*)&header, sizeof(header)); 
031C6:  MOVLW  03
031C8:  MOVLB  3
031CA:  MOVWF  x9B
031CC:  MOVLW  86
031CE:  MOVFF  39B,41A
031D2:  MOVFF  FE8,419
031D6:  MOVLB  4
031D8:  CLRF   x1C
031DA:  MOVLW  14
031DC:  MOVWF  x1B
031DE:  MOVLB  0
031E0:  RCALL  30DE
....................  
.................... 	// The EtherType field, like most items transmitted on the Ethernet medium 
.................... 	// are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
031E2:  MOVFF  399,42B
031E6:  MOVFF  398,42A
031EA:  RCALL  3142
031EC:  MOVFF  02,399
031F0:  MOVFF  01,398
....................  
.................... 	// Validate the data returned from the ENC28J60.  Random data corruption, 
.................... 	// such as if a single SPI bit error occurs while communicating or a 
.................... 	// momentary power glitch could cause this to occur in rare circumstances. 
.................... 	if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
.................... 	   header.StatusVector.bits.Zero || 
.................... 	   header.StatusVector.bits.CRCError || 
.................... 	   header.StatusVector.bits.ByteCount > 1518 || 
.................... 	   !header.StatusVector.bits.ReceiveOk) 
031F4:  MOVLB  3
031F6:  MOVF   x87,W
031F8:  SUBLW  1A
031FA:  BC    3206
031FC:  XORLW  FF
031FE:  BNZ   3232
03200:  MOVF   x86,W
03202:  SUBLW  F7
03204:  BNC   3232
03206:  MOVLW  03
03208:  MOVWF  x9B
0320A:  MOVLW  86
0320C:  MOVWF  FE9
0320E:  MOVFF  39B,FEA
03212:  BTFSC  FEF.0
03214:  BRA    3232
03216:  BTFSC  x8B.7
03218:  BRA    3232
0321A:  BTFSC  x8A.4
0321C:  BRA    3232
0321E:  MOVF   x89,W
03220:  SUBLW  04
03222:  BC    322E
03224:  XORLW  FF
03226:  BNZ   3232
03228:  MOVF   x88,W
0322A:  SUBLW  EE
0322C:  BNC   3232
0322E:  BTFSC  x8A.7
03230:  BRA    3234
.................... 	{ 
.................... 		//Reset(); 
....................       reset_cpu(); 
03232:  RESET
.................... 	} 
....................  
.................... 	// Save the location where the hardware will write the next packet to 
.................... 	NextPacketLocation.Val = header.NextPacketPointer; 
03234:  MOVFF  387,53
03238:  MOVFF  386,52
....................  
.................... 	// Return the Ethernet frame's Source MAC address field to the caller 
.................... 	// This parameter is useful for replying to requests without requiring an 
.................... 	// ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
0323C:  MOVFF  382,39A
03240:  MOVFF  383,39B
03244:  MOVFF  383,FEA
03248:  MOVFF  382,FE9
0324C:  MOVLW  03
0324E:  MOVWF  FE2
03250:  MOVLW  92
03252:  MOVWF  FE1
03254:  MOVLW  06
03256:  MOVWF  01
03258:  MOVFF  FE6,FEE
0325C:  DECFSZ 01,F
0325E:  BRA    3258
....................  
.................... 	// Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
03260:  MOVFF  384,FE9
03264:  MOVFF  385,FEA
03268:  MOVLW  FF
0326A:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................     	((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
0326C:  MOVF   x99,W
0326E:  SUBLW  08
03270:  BNZ   3288
03272:  MOVF   x98,F
03274:  BZ    327C
03276:  MOVF   x98,W
03278:  SUBLW  06
0327A:  BNZ   3288
....................     { 
....................     	*type = header.Type.v[0]; 
0327C:  MOVFF  384,FE9
03280:  MOVFF  385,FEA
03284:  MOVFF  398,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
03288:  BCF    56.0
.................... 	return TRUE; 
0328A:  MOVLW  01
0328C:  MOVWF  01
.................... } 
0328E:  MOVLB  0
03290:  GOTO   A148 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *					                     BYTE type, 
....................  *                   					 WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  * 							 MAC address (6 bytes) 
....................  *					type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *						  value to write into the Ethernet header's type field. 
....................  *					dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *					advantagous to call this function immediately before 
....................  *					transmitting a packet rather than initially when the 
....................  *					packet is first created.  The order in which the packet 
....................  *					is constructed (header first or data first) is not 
....................  *					important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
.................... 	BankSel(EWRPTL); 
*
0358A:  MOVLB  4
0358C:  CLRF   x2E
0358E:  MOVLW  02
03590:  MOVWF  x2D
03592:  MOVLB  0
03594:  CALL   10B2
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
.................... 	TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
03598:  MOVLW  02
0359A:  MOVLB  4
0359C:  MOVWF  x30
0359E:  MOVLW  F8
035A0:  MOVWF  x31
035A2:  MOVLB  0
035A4:  CALL   1058
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
035A8:  MOVLW  03
035AA:  MOVLB  4
035AC:  MOVWF  x30
035AE:  MOVLW  1B
035B0:  MOVWF  x31
035B2:  MOVLB  0
035B4:  CALL   1058
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
035B8:  MOVLW  06
035BA:  MOVLB  4
035BC:  ADDWF  x2B,F
035BE:  MOVLW  1C
035C0:  ADDWFC x2C,F
....................  
.................... 	// Write the TXND pointer into the registers, given the dataLen given 
.................... 	WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
035C2:  MOVLW  04
035C4:  MOVWF  x2E
035C6:  MOVLW  2B
035C8:  MOVWF  FE9
035CA:  MOVFF  42E,FEA
035CE:  MOVFF  FEF,42F
035D2:  MOVLW  06
035D4:  MOVWF  x30
035D6:  MOVFF  42F,431
035DA:  MOVLB  0
035DC:  CALL   1058
.................... 	WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
035E0:  MOVLW  04
035E2:  MOVLB  4
035E4:  MOVWF  x2E
035E6:  MOVLW  2B
035E8:  MOVWF  x2D
035EA:  MOVLW  01
035EC:  ADDWF  x2D,W
035EE:  MOVWF  FE9
035F0:  MOVLW  00
035F2:  ADDWFC x2E,W
035F4:  MOVWF  FEA
035F6:  MOVFF  FEF,42F
035FA:  MOVLW  07
035FC:  MOVWF  x30
035FE:  MOVFF  42F,431
03602:  MOVLB  0
03604:  CALL   1058
.................... #endif 
....................  
....................  
.................... 	// Set the per-packet control byte and write the Ethernet destination 
.................... 	// address 
.................... 	MACPut(0x00);	// Use default control configuration 
03608:  MOVLB  4
0360A:  CLRF   x2E
0360C:  MOVLB  0
0360E:  RCALL  351E
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
03610:  MOVFF  429,430
03614:  MOVFF  428,42F
03618:  MOVLB  4
0361A:  CLRF   x32
0361C:  MOVLW  06
0361E:  MOVWF  x31
03620:  MOVLB  0
03622:  RCALL  353C
....................  
.................... 	// Write our MAC address in the Ethernet source field 
.................... 	MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
03624:  MOVLB  4
03626:  CLRF   x2E
03628:  MOVLW  1A
0362A:  MOVFF  42E,430
0362E:  MOVWF  x2F
03630:  CLRF   x32
03632:  MOVLW  06
03634:  MOVWF  x31
03636:  MOVLB  0
03638:  RCALL  353C
....................  
.................... 	// Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
0363A:  MOVLW  08
0363C:  MOVLB  4
0363E:  MOVWF  x2E
03640:  MOVLB  0
03642:  RCALL  351E
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
03644:  MOVLB  4
03646:  MOVF   x2A,F
03648:  BNZ   364E
0364A:  MOVLW  00
0364C:  BRA    3650
0364E:  MOVLW  06
03650:  MOVWF  x2E
03652:  MOVLB  0
03654:  RCALL  351E
.................... } 
03656:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *					MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *					the Ethernet medium.  The hardware MAC will take control 
....................  *					and handle CRC generation, collision retransmission and 
....................  *					other details. 
....................  * 
....................  * Note:			After transmission completes (MACIsTxReady() returns TRUE), 
....................  *					the packet can be modified and transmitted again by calling 
....................  *					MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *					called (in the TX data area), the data in the TX buffer 
....................  *					will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the packet start and end address pointers 
.................... 	BankSel(ETXSTL); 
.................... 	WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
.................... 	WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
.................... 	WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
.................... 	LastTXedBuffer = CurrentTxBuffer; 
.................... 	TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
.................... 	// Reset transmit logic if a TX Error has previously occured 
.................... 	// This is a silicon errata workaround 
.................... 	if(ReadETHReg(EIR).EIRbits.TXERIF) 
03658:  MOVLW  1C
0365A:  MOVLB  4
0365C:  MOVWF  x2A
0365E:  MOVLB  0
03660:  CALL   1018
03664:  MOVFF  01,417
03668:  MOVLW  00
0366A:  MOVLB  4
0366C:  BTFSC  01.1
0366E:  MOVLW  01
03670:  XORLW  00
03672:  BZ    3694
.................... 	{ 
.................... 		BFSReg(ECON1, ECON1_TXRST); 
03674:  MOVLW  1F
03676:  MOVWF  x32
03678:  MOVLW  80
0367A:  MOVWF  x33
0367C:  MOVLB  0
0367E:  CALL   1094
.................... 		BFCReg(ECON1, ECON1_TXRST); 
03682:  MOVLW  1F
03684:  MOVLB  4
03686:  MOVWF  x2F
03688:  MOVLW  80
0368A:  MOVWF  x30
0368C:  MOVLB  0
0368E:  CALL   1076
03692:  MOVLB  4
.................... 	} 
.................... 	BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
03694:  MOVLW  1C
03696:  MOVWF  x2F
03698:  MOVLW  0A
0369A:  MOVWF  x30
0369C:  MOVLB  0
0369E:  CALL   1076
....................  
.................... 	// Start the transmission 
.................... 	// After transmission completes (MACIsTxReady() returns TRUE), the packet 
.................... 	// can be modified and transmitted again by calling MACFlush() again. 
.................... 	// Until MACPutHeader() is called, the data in the TX buffer will not be 
.................... 	// corrupted. 
.................... 	BFSReg(ECON1, ECON1_TXRTS); 
036A2:  MOVLW  1F
036A4:  MOVLB  4
036A6:  MOVWF  x32
036A8:  MOVLW  08
036AA:  MOVWF  x33
036AC:  MOVLB  0
036AE:  CALL   1094
....................  
.................... 	// Revision B5 silicon errata workaround 
.................... 	if(ENCRevID == 0x05) 
036B2:  MOVF   57,W
036B4:  SUBLW  05
036B6:  BTFSS  FD8.2
036B8:  BRA    387A
.................... 	{ 
.................... 		while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
036BA:  MOVLW  1C
036BC:  MOVLB  4
036BE:  MOVWF  x2A
036C0:  MOVLB  0
036C2:  CALL   1018
036C6:  MOVFF  01,417
036CA:  MOVLB  4
036CC:  MOVF   01,W
036CE:  ANDLW  0A
036D0:  BTFSS  FD8.2
036D2:  BRA    36D8
036D4:  MOVLB  0
036D6:  BRA    36BA
.................... 		if(ReadETHReg(EIR).EIRbits.TXERIF) 
036D8:  MOVLW  1C
036DA:  MOVWF  x2A
036DC:  MOVLB  0
036DE:  CALL   1018
036E2:  MOVFF  01,417
036E6:  MOVLW  00
036E8:  MOVLB  4
036EA:  BTFSC  01.1
036EC:  MOVLW  01
036EE:  XORLW  00
036F0:  BTFSC  FD8.2
036F2:  BRA    387C
.................... 		{ 
.................... 			WORD_VAL ReadPtrSave; 
.................... 			WORD_VAL TXEnd; 
.................... 			TXSTATUS TXStatus; 
.................... 			BYTE i; 
....................  
.................... 			// Cancel the previous transmission if it has become stuck set 
.................... 			BFCReg(ECON1, ECON1_TXRTS); 
036F4:  MOVLW  1F
036F6:  MOVWF  x2F
036F8:  MOVLW  08
036FA:  MOVWF  x30
036FC:  MOVLB  0
036FE:  CALL   1076
....................  
.................... 			// Save the current read pointer (controlled by application) 
.................... 			BankSel(ERDPTL); 
03702:  MOVLB  4
03704:  CLRF   x2E
03706:  CLRF   x2D
03708:  MOVLB  0
0370A:  CALL   10B2
.................... 			ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
0370E:  MOVLB  4
03710:  CLRF   x2A
03712:  MOVLB  0
03714:  CALL   1018
03718:  MOVFF  01,40B
.................... 			ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
0371C:  MOVLW  01
0371E:  MOVLB  4
03720:  MOVWF  x2A
03722:  MOVLB  0
03724:  CALL   1018
03728:  MOVFF  01,40C
....................  
.................... 			// Get the location of the transmit status vector 
.................... 			TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
0372C:  MOVLW  06
0372E:  MOVLB  4
03730:  MOVWF  x2A
03732:  MOVLB  0
03734:  CALL   1018
03738:  MOVFF  01,40D
.................... 			TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
0373C:  MOVLW  07
0373E:  MOVLB  4
03740:  MOVWF  x2A
03742:  MOVLB  0
03744:  CALL   1018
03748:  MOVFF  01,40E
.................... 			TXEnd.Val++; 
0374C:  MOVLB  4
0374E:  INCF   x0D,F
03750:  BTFSC  FD8.2
03752:  INCF   x0E,F
....................  
.................... 			// Read the transmit status vector 
.................... 			WriteReg(ERDPTL, TXEnd.v[0]); 
03754:  CLRF   x30
03756:  MOVFF  40D,431
0375A:  MOVLB  0
0375C:  CALL   1058
.................... 			WriteReg(ERDPTH, TXEnd.v[1]); 
03760:  MOVLW  01
03762:  MOVLB  4
03764:  MOVWF  x30
03766:  MOVFF  40E,431
0376A:  MOVLB  0
0376C:  CALL   1058
.................... 			MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
03770:  MOVLW  04
03772:  MOVLB  4
03774:  MOVWF  x18
03776:  MOVLW  0F
03778:  MOVFF  418,41A
0377C:  MOVWF  x19
0377E:  CLRF   x1C
03780:  MOVLW  07
03782:  MOVWF  x1B
03784:  MOVLB  0
03786:  RCALL  30DE
....................  
.................... 			// Implement retransmission if a late collision occured (this can 
.................... 			// happen on B5 when certain link pulses arrive at the same time 
.................... 			// as the transmission) 
.................... 			for(i = 0; i < 16; i++) 
03788:  MOVLB  4
0378A:  CLRF   x16
0378C:  MOVF   x16,W
0378E:  SUBLW  0F
03790:  BNC   385E
.................... 			{ 
.................... 				if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
03792:  MOVLW  1C
03794:  MOVWF  x2A
03796:  MOVLB  0
03798:  CALL   1018
0379C:  MOVFF  01,417
037A0:  MOVLW  00
037A2:  MOVLB  4
037A4:  BTFSC  01.1
037A6:  MOVLW  01
037A8:  XORLW  00
037AA:  BZ    3854
037AC:  BTFSS  x12.5
037AE:  BRA    3854
.................... 				{ 
.................... 					// Reset the TX logic 
.................... 					BFSReg(ECON1, ECON1_TXRST); 
037B0:  MOVLW  1F
037B2:  MOVWF  x32
037B4:  MOVLW  80
037B6:  MOVWF  x33
037B8:  MOVLB  0
037BA:  CALL   1094
.................... 					BFCReg(ECON1, ECON1_TXRST); 
037BE:  MOVLW  1F
037C0:  MOVLB  4
037C2:  MOVWF  x2F
037C4:  MOVLW  80
037C6:  MOVWF  x30
037C8:  MOVLB  0
037CA:  CALL   1076
.................... 					BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
037CE:  MOVLW  1C
037D0:  MOVLB  4
037D2:  MOVWF  x2F
037D4:  MOVLW  0A
037D6:  MOVWF  x30
037D8:  MOVLB  0
037DA:  CALL   1076
....................  
.................... 					// Transmit the packet again 
.................... 					BFSReg(ECON1, ECON1_TXRTS); 
037DE:  MOVLW  1F
037E0:  MOVLB  4
037E2:  MOVWF  x32
037E4:  MOVLW  08
037E6:  MOVWF  x33
037E8:  MOVLB  0
037EA:  CALL   1094
.................... 					while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
037EE:  MOVLW  1C
037F0:  MOVLB  4
037F2:  MOVWF  x2A
037F4:  MOVLB  0
037F6:  CALL   1018
037FA:  MOVFF  01,417
037FE:  MOVLB  4
03800:  MOVF   01,W
03802:  ANDLW  0A
03804:  BTFSS  FD8.2
03806:  BRA    380C
03808:  MOVLB  0
0380A:  BRA    37EE
....................  
.................... 					// Cancel the previous transmission if it has become stuck set 
.................... 					BFCReg(ECON1, ECON1_TXRTS); 
0380C:  MOVLW  1F
0380E:  MOVWF  x2F
03810:  MOVLW  08
03812:  MOVWF  x30
03814:  MOVLB  0
03816:  CALL   1076
....................  
.................... 					// Read transmit status vector 
.................... 					WriteReg(ERDPTL, TXEnd.v[0]); 
0381A:  MOVLB  4
0381C:  CLRF   x30
0381E:  MOVFF  40D,431
03822:  MOVLB  0
03824:  CALL   1058
.................... 					WriteReg(ERDPTH, TXEnd.v[1]); 
03828:  MOVLW  01
0382A:  MOVLB  4
0382C:  MOVWF  x30
0382E:  MOVFF  40E,431
03832:  MOVLB  0
03834:  CALL   1058
.................... 					MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
03838:  MOVLW  04
0383A:  MOVLB  4
0383C:  MOVWF  x18
0383E:  MOVLW  0F
03840:  MOVFF  418,41A
03844:  MOVWF  x19
03846:  CLRF   x1C
03848:  MOVLW  07
0384A:  MOVWF  x1B
0384C:  MOVLB  0
0384E:  RCALL  30DE
.................... 				} 
.................... 				else 
03850:  BRA    3858
03852:  MOVLB  4
.................... 				{ 
.................... 					break; 
03854:  BRA    385E
03856:  MOVLB  0
.................... 				} 
.................... 			} 
03858:  MOVLB  4
0385A:  INCF   x16,F
0385C:  BRA    378C
....................  
.................... 			// Restore the current read pointer 
.................... 			WriteReg(ERDPTL, ReadPtrSave.v[0]); 
0385E:  CLRF   x30
03860:  MOVFF  40B,431
03864:  MOVLB  0
03866:  CALL   1058
.................... 			WriteReg(ERDPTH, ReadPtrSave.v[1]); 
0386A:  MOVLW  01
0386C:  MOVLB  4
0386E:  MOVWF  x30
03870:  MOVFF  40C,431
03874:  MOVLB  0
03876:  CALL   1058
0387A:  MOVLB  4
.................... 		} 
.................... 	} 
.................... } 
0387C:  MOVLB  0
0387E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *					getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			RXSTOP must be statically defined as being > RXSTART for 
....................  *					this function to work correctly.  In other words, do not 
....................  *					define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *					boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
.................... 	WORD_VAL ReadPT; 
....................  
.................... 	// Determine the address of the beginning of the entire packet 
.................... 	// and adjust the address to the desired location 
.................... 	ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03BB0:  MOVLW  14
03BB2:  ADDWF  54,W
03BB4:  MOVLB  3
03BB6:  MOVWF  xB7
03BB8:  MOVLW  00
03BBA:  ADDWFC 55,W
03BBC:  MOVWF  xB8
03BBE:  MOVF   xB3,W
03BC0:  ADDWF  xB7,W
03BC2:  MOVWF  xB5
03BC4:  MOVF   xB4,W
03BC6:  ADDWFC xB8,W
03BC8:  MOVWF  xB6
....................  
.................... 	// Since the receive buffer is circular, adjust if a wraparound is needed 
.................... 	if ( ReadPT.Val > RXSTOP ) 
03BCA:  MOVF   xB6,W
03BCC:  SUBLW  1A
03BCE:  BC    3BE2
03BD0:  XORLW  FF
03BD2:  BNZ   3BDA
03BD4:  MOVF   xB5,W
03BD6:  SUBLW  F7
03BD8:  BC    3BE2
.................... 		ReadPT.Val -= RXSIZE; 
03BDA:  MOVLW  F8
03BDC:  SUBWF  xB5,F
03BDE:  MOVLW  1B
03BE0:  SUBWFB xB6,F
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(ERDPTL); 
03BE2:  MOVLB  4
03BE4:  CLRF   x2E
03BE6:  CLRF   x2D
03BE8:  MOVLB  0
03BEA:  CALL   10B2
.................... 	WriteReg(ERDPTL, ReadPT.v[0]); 
03BEE:  MOVLB  4
03BF0:  CLRF   x30
03BF2:  MOVFF  3B5,431
03BF6:  MOVLB  0
03BF8:  CALL   1058
.................... 	WriteReg(ERDPTH, ReadPT.v[1]); 
03BFC:  MOVLW  01
03BFE:  MOVLB  4
03C00:  MOVWF  x30
03C02:  MOVFF  3B6,431
03C06:  MOVLB  0
03C08:  CALL   1058
.................... 	WriteReg(EWRPTL, ReadPT.v[0]); 
03C0C:  MOVLW  02
03C0E:  MOVLB  4
03C10:  MOVWF  x30
03C12:  MOVFF  3B5,431
03C16:  MOVLB  0
03C18:  CALL   1058
.................... 	WriteReg(EWRPTH, ReadPT.v[1]); 
03C1C:  MOVLW  03
03C1E:  MOVLB  4
03C20:  MOVWF  x30
03C22:  MOVFF  3B6,431
03C26:  MOVLB  0
03C28:  CALL   1058
.................... } 
03C2C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *							within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *							parameter is not used. 
....................  *					offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
03474:  MOVFF  424,4D
....................  
.................... 	// Calculate the proper address.  Since the TX memory area is not circular, 
.................... 	// no wrapparound checks are necessary. +1 adjustment is needed because of 
.................... 	// the per packet control byte which preceeds the packet in the TX memory 
.................... 	// area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
.................... 	offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
03478:  MOVLW  07
0347A:  MOVLB  4
0347C:  ADDWF  x25,F
0347E:  MOVLW  1C
03480:  ADDWFC x26,F
.................... #endif 
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(EWRPTL); 
03482:  CLRF   x2E
03484:  MOVLW  02
03486:  MOVWF  x2D
03488:  MOVLB  0
0348A:  CALL   10B2
.................... 	WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
0348E:  MOVLW  04
03490:  MOVLB  4
03492:  MOVWF  x28
03494:  MOVLW  25
03496:  MOVWF  FE9
03498:  MOVFF  428,FEA
0349C:  MOVFF  FEF,429
034A0:  CLRF   x30
034A2:  MOVFF  429,431
034A6:  MOVLB  0
034A8:  CALL   1058
.................... 	WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
034AC:  MOVLW  04
034AE:  MOVLB  4
034B0:  MOVWF  x28
034B2:  MOVLW  25
034B4:  MOVWF  x27
034B6:  MOVLW  01
034B8:  ADDWF  x27,W
034BA:  MOVWF  FE9
034BC:  MOVLW  00
034BE:  ADDWFC x28,W
034C0:  MOVWF  FEA
034C2:  MOVFF  FEF,429
034C6:  MOVLW  01
034C8:  MOVWF  x30
034CA:  MOVFF  429,431
034CE:  MOVLB  0
034D0:  CALL   1058
.................... 	WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
034D4:  MOVLW  04
034D6:  MOVLB  4
034D8:  MOVWF  x28
034DA:  MOVLW  25
034DC:  MOVWF  FE9
034DE:  MOVFF  428,FEA
034E2:  MOVFF  FEF,429
034E6:  MOVLW  02
034E8:  MOVWF  x30
034EA:  MOVFF  429,431
034EE:  MOVLB  0
034F0:  CALL   1058
.................... 	WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
034F4:  MOVLW  04
034F6:  MOVLB  4
034F8:  MOVWF  x28
034FA:  MOVLW  25
034FC:  MOVWF  x27
034FE:  MOVLW  01
03500:  ADDWF  x27,W
03502:  MOVWF  FE9
03504:  MOVLW  00
03506:  ADDWFC x28,W
03508:  MOVWF  FEA
0350A:  MOVFF  FEF,429
0350E:  MOVLW  03
03510:  MOVWF  x30
03512:  MOVFF  429,431
03516:  MOVLB  0
03518:  CALL   1058
.................... } 
0351C:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Add the offset requested by firmware plus the Ethernet header 
.................... 	temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03AA2:  MOVLW  14
03AA4:  ADDWF  54,W
03AA6:  MOVLB  3
03AA8:  MOVWF  xE1
03AAA:  MOVLW  00
03AAC:  ADDWFC 55,W
03AAE:  MOVWF  xE2
03AB0:  MOVF   xDB,W
03AB2:  ADDWF  xE1,W
03AB4:  MOVWF  xDF
03AB6:  MOVF   xDC,W
03AB8:  ADDWFC xE2,W
03ABA:  MOVWF  xE0
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
03ABC:  MOVF   xE0,W
03ABE:  SUBLW  1A
03AC0:  BC    3AD4
03AC2:  XORLW  FF
03AC4:  BNZ   3ACC
03AC6:  MOVF   xDF,W
03AC8:  SUBLW  F7
03ACA:  BC    3AD4
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
03ACC:  MOVLW  F8
03ACE:  SUBWF  xDF,F
03AD0:  MOVLW  1B
03AD2:  SUBWFB xE0,F
.................... 	} 
....................  
.................... 	// Program the start address of the DMA 
.................... 	BankSel(EDMASTL); 
03AD4:  MOVLB  4
03AD6:  CLRF   x2E
03AD8:  MOVLW  10
03ADA:  MOVWF  x2D
03ADC:  MOVLB  0
03ADE:  CALL   10B2
.................... 	WriteReg(EDMASTL, temp.v[0]); 
03AE2:  MOVLW  10
03AE4:  MOVLB  4
03AE6:  MOVWF  x30
03AE8:  MOVFF  3DF,431
03AEC:  MOVLB  0
03AEE:  CALL   1058
.................... 	WriteReg(EDMASTH, temp.v[1]); 
03AF2:  MOVLW  11
03AF4:  MOVLB  4
03AF6:  MOVWF  x30
03AF8:  MOVFF  3E0,431
03AFC:  MOVLB  0
03AFE:  CALL   1058
....................  
.................... 	// Calculate the end address, given the start address and len 
.................... 	temp.Val += len-1; 
03B02:  MOVLW  01
03B04:  MOVLB  3
03B06:  SUBWF  xDD,W
03B08:  MOVWF  00
03B0A:  MOVLW  00
03B0C:  SUBWFB xDE,W
03B0E:  MOVWF  03
03B10:  MOVF   00,W
03B12:  ADDWF  xDF,F
03B14:  MOVF   03,W
03B16:  ADDWFC xE0,F
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
03B18:  MOVF   xE0,W
03B1A:  SUBLW  1A
03B1C:  BC    3B30
03B1E:  XORLW  FF
03B20:  BNZ   3B28
03B22:  MOVF   xDF,W
03B24:  SUBLW  F7
03B26:  BC    3B30
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
03B28:  MOVLW  F8
03B2A:  SUBWF  xDF,F
03B2C:  MOVLW  1B
03B2E:  SUBWFB xE0,F
.................... 	} 
....................  
.................... 	// Program the end address of the DMA 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
03B30:  MOVLW  12
03B32:  MOVLB  4
03B34:  MOVWF  x30
03B36:  MOVFF  3DF,431
03B3A:  MOVLB  0
03B3C:  CALL   1058
.................... 	WriteReg(EDMANDH, temp.v[1]); 
03B40:  MOVLW  13
03B42:  MOVLB  4
03B44:  MOVWF  x30
03B46:  MOVFF  3E0,431
03B4A:  MOVLB  0
03B4C:  CALL   1058
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
03B50:  MOVLW  1F
03B52:  MOVLB  4
03B54:  MOVWF  x32
03B56:  MOVLW  30
03B58:  MOVWF  x33
03B5A:  MOVLB  0
03B5C:  CALL   1094
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
03B60:  MOVLW  1F
03B62:  MOVLB  4
03B64:  MOVWF  x2A
03B66:  MOVLB  0
03B68:  CALL   1018
03B6C:  MOVFF  01,3E1
03B70:  MOVLW  00
03B72:  MOVLB  3
03B74:  BTFSC  01.5
03B76:  MOVLW  01
03B78:  XORLW  00
03B7A:  BTFSC  FD8.2
03B7C:  BRA    3B82
03B7E:  MOVLB  0
03B80:  BRA    3B60
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
03B82:  MOVLW  16
03B84:  MOVLB  4
03B86:  MOVWF  x2A
03B88:  MOVLB  0
03B8A:  CALL   1018
03B8E:  MOVFF  01,3E0
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
03B92:  MOVLW  17
03B94:  MOVLB  4
03B96:  MOVWF  x2A
03B98:  MOVLB  0
03B9A:  CALL   1018
03B9E:  MOVFF  01,3DF
.................... 	return temp.Val; 
03BA2:  MOVLB  3
03BA4:  MOVFF  3DF,01
03BA8:  MOVFF  3E0,02
.................... } 
03BAC:  MOVLB  0
03BAE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Program the start address of the DMA, after adjusting for the Ethernet 
.................... 	// header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
.................... #else 
.................... 	temp.Val = TXSTART + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
*
04ABE:  MOVLW  06
04AC0:  MOVLB  4
04AC2:  ADDWF  x24,W
04AC4:  MOVWF  x2A
04AC6:  MOVLW  1C
04AC8:  ADDWFC x25,W
04ACA:  MOVWF  x2B
04ACC:  MOVLW  01
04ACE:  ADDWF  x2A,W
04AD0:  MOVWF  x28
04AD2:  MOVLW  00
04AD4:  ADDWFC x2B,W
04AD6:  MOVWF  x29
.................... #endif 
.................... 	BankSel(EDMASTL); 
04AD8:  CLRF   x2E
04ADA:  MOVLW  10
04ADC:  MOVWF  x2D
04ADE:  MOVLB  0
04AE0:  CALL   10B2
.................... 	WriteReg(EDMASTL, temp.v[0]); 
04AE4:  MOVLW  10
04AE6:  MOVLB  4
04AE8:  MOVWF  x30
04AEA:  MOVFF  428,431
04AEE:  MOVLB  0
04AF0:  CALL   1058
.................... 	WriteReg(EDMASTH, temp.v[1]); 
04AF4:  MOVLW  11
04AF6:  MOVLB  4
04AF8:  MOVWF  x30
04AFA:  MOVFF  429,431
04AFE:  MOVLB  0
04B00:  CALL   1058
....................  
.................... 	// Program the end address of the DMA. 
.................... 	temp.Val += len-1; 
04B04:  MOVLW  01
04B06:  MOVLB  4
04B08:  SUBWF  x26,W
04B0A:  MOVWF  00
04B0C:  MOVLW  00
04B0E:  SUBWFB x27,W
04B10:  MOVWF  03
04B12:  MOVF   00,W
04B14:  ADDWF  x28,F
04B16:  MOVF   03,W
04B18:  ADDWFC x29,F
.................... 	WriteReg(EDMANDL, temp.v[0]); 
04B1A:  MOVLW  12
04B1C:  MOVWF  x30
04B1E:  MOVFF  428,431
04B22:  MOVLB  0
04B24:  CALL   1058
.................... 	WriteReg(EDMANDH, temp.v[1]); 
04B28:  MOVLW  13
04B2A:  MOVLB  4
04B2C:  MOVWF  x30
04B2E:  MOVFF  429,431
04B32:  MOVLB  0
04B34:  CALL   1058
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
04B38:  MOVLW  1F
04B3A:  MOVLB  4
04B3C:  MOVWF  x32
04B3E:  MOVLW  30
04B40:  MOVWF  x33
04B42:  MOVLB  0
04B44:  CALL   1094
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
04B48:  MOVLW  1F
04B4A:  MOVLB  4
04B4C:  MOVWF  x2A
04B4E:  MOVLB  0
04B50:  CALL   1018
04B54:  MOVFF  01,42A
04B58:  MOVLW  00
04B5A:  MOVLB  4
04B5C:  BTFSC  01.5
04B5E:  MOVLW  01
04B60:  XORLW  00
04B62:  BTFSC  FD8.2
04B64:  BRA    4B6A
04B66:  MOVLB  0
04B68:  BRA    4B48
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
04B6A:  MOVLW  16
04B6C:  MOVWF  x2A
04B6E:  MOVLB  0
04B70:  CALL   1018
04B74:  MOVFF  01,429
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
04B78:  MOVLW  17
04B7A:  MOVLB  4
04B7C:  MOVWF  x2A
04B7E:  MOVLB  0
04B80:  CALL   1018
04B84:  MOVFF  01,428
.................... 	return temp.Val; 
04B88:  MOVLB  4
04B8A:  MOVFF  428,01
04B8E:  MOVFF  429,02
.................... } 
04B92:  MOVLB  0
04B94:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *						 The first byte included in the checksum is the byte 
....................  *						 pointed to by ERDPT, which is updated by calls to 
....................  *						 MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *					which can calculate the checksum faster than software, so 
....................  *					this function replaces the CaclIPBufferChecksum() function 
....................  *					defined in the helpers.c file.  Through the use of 
....................  *					preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *					buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Take care of special cases which the DMA cannot be used for 
.................... 	if(len == 0u) 
*
03F30:  MOVLB  4
03F32:  MOVF   x0B,F
03F34:  BNZ   3F44
03F36:  MOVF   x0C,F
03F38:  BNZ   3F44
.................... 	{ 
.................... 		return 0xFFFF; 
03F3A:  MOVLW  FF
03F3C:  MOVWF  01
03F3E:  MOVWF  02
03F40:  BRA    4084
.................... 	} 
.................... 	else if(len == 1u) 
03F42:  BRA    3F72
03F44:  DECFSZ x0B,W
03F46:  BRA    3F72
03F48:  MOVF   x0C,F
03F4A:  BNZ   3F72
.................... 	{ 
.................... 		return ~(((WORD)MACGet())<<8); 
03F4C:  MOVLB  0
03F4E:  RCALL  3F04
03F50:  MOVLB  4
03F52:  CLRF   x10
03F54:  MOVFF  01,40F
03F58:  MOVFF  01,03
03F5C:  MOVLW  00
03F5E:  CLRF   00
03F60:  DECF   00,F
03F62:  XORWF  00,F
03F64:  MOVLW  FF
03F66:  XORWF  03,F
03F68:  MOVFF  00,01
03F6C:  MOVFF  03,02
03F70:  BRA    4084
.................... 	} 
....................  
....................  
.................... 	// Set the DMA starting address to the SPI read pointer value 
.................... 	BankSel(ERDPTL); 
03F72:  CLRF   x2E
03F74:  CLRF   x2D
03F76:  MOVLB  0
03F78:  CALL   10B2
.................... 	temp.v[0] = ReadETHReg(ERDPTL).Val; 
03F7C:  MOVLB  4
03F7E:  CLRF   x2A
03F80:  MOVLB  0
03F82:  CALL   1018
03F86:  MOVFF  01,40D
.................... 	temp.v[1] = ReadETHReg(ERDPTH).Val; 
03F8A:  MOVLW  01
03F8C:  MOVLB  4
03F8E:  MOVWF  x2A
03F90:  MOVLB  0
03F92:  CALL   1018
03F96:  MOVFF  01,40E
.................... 	WriteReg(EDMASTL, temp.v[0]); 
03F9A:  MOVLW  10
03F9C:  MOVLB  4
03F9E:  MOVWF  x30
03FA0:  MOVFF  40D,431
03FA4:  MOVLB  0
03FA6:  CALL   1058
.................... 	WriteReg(EDMASTH, temp.v[1]); 
03FAA:  MOVLW  11
03FAC:  MOVLB  4
03FAE:  MOVWF  x30
03FB0:  MOVFF  40E,431
03FB4:  MOVLB  0
03FB6:  CALL   1058
....................  
.................... 	// See if we are calculating a checksum within the RX buffer (where 
.................... 	// wrapping rules apply) or TX/unused area (where wrapping rules are 
.................... 	// not applied) 
.................... #if RXSTART == 0 
.................... 	if(temp.Val <= RXSTOP) 
03FBA:  MOVLB  4
03FBC:  MOVF   x0E,W
03FBE:  SUBLW  1B
03FC0:  BNC   3FF8
03FC2:  BNZ   3FCA
03FC4:  MOVF   x0D,W
03FC6:  SUBLW  F7
03FC8:  BNC   3FF8
.................... #else 
.................... 	if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		// Calculate the DMA ending address given the starting address and len 
.................... 		// parameter.  The DMA will follow the receive buffer wrapping boundary. 
.................... 		temp.Val += len-1; 
03FCA:  MOVLW  01
03FCC:  SUBWF  x0B,W
03FCE:  MOVWF  00
03FD0:  MOVLW  00
03FD2:  SUBWFB x0C,W
03FD4:  MOVWF  03
03FD6:  MOVF   00,W
03FD8:  ADDWF  x0D,F
03FDA:  MOVF   03,W
03FDC:  ADDWFC x0E,F
.................... 		if(temp.Val > RXSTOP) 
03FDE:  MOVF   x0E,W
03FE0:  SUBLW  1A
03FE2:  BC    3FF6
03FE4:  XORLW  FF
03FE6:  BNZ   3FEE
03FE8:  MOVF   x0D,W
03FEA:  SUBLW  F7
03FEC:  BC    3FF6
.................... 		{ 
.................... 			temp.Val -= RXSIZE; 
03FEE:  MOVLW  F8
03FF0:  SUBWF  x0D,F
03FF2:  MOVLW  1B
03FF4:  SUBWFB x0E,F
.................... 		} 
.................... 	} 
.................... 	else 
03FF6:  BRA    400C
.................... 	{ 
.................... 		temp.Val += len-1; 
03FF8:  MOVLW  01
03FFA:  SUBWF  x0B,W
03FFC:  MOVWF  00
03FFE:  MOVLW  00
04000:  SUBWFB x0C,W
04002:  MOVWF  03
04004:  MOVF   00,W
04006:  ADDWF  x0D,F
04008:  MOVF   03,W
0400A:  ADDWFC x0E,F
.................... 	} 
....................  
.................... 	// Write the DMA end address 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
0400C:  MOVLW  12
0400E:  MOVWF  x30
04010:  MOVFF  40D,431
04014:  MOVLB  0
04016:  CALL   1058
.................... 	WriteReg(EDMANDH, temp.v[1]); 
0401A:  MOVLW  13
0401C:  MOVLB  4
0401E:  MOVWF  x30
04020:  MOVFF  40E,431
04024:  MOVLB  0
04026:  CALL   1058
....................  
.................... 	// Begin the DMA checksum calculation and wait until it is finished 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
0402A:  MOVLW  1F
0402C:  MOVLB  4
0402E:  MOVWF  x32
04030:  MOVLW  30
04032:  MOVWF  x33
04034:  MOVLB  0
04036:  CALL   1094
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0403A:  MOVLW  1F
0403C:  MOVLB  4
0403E:  MOVWF  x2A
04040:  MOVLB  0
04042:  CALL   1018
04046:  MOVFF  01,40F
0404A:  MOVLW  00
0404C:  MOVLB  4
0404E:  BTFSC  01.5
04050:  MOVLW  01
04052:  XORLW  00
04054:  BTFSC  FD8.2
04056:  BRA    405C
04058:  MOVLB  0
0405A:  BRA    403A
....................  
.................... 	// Return the resulting good stuff 
.................... 	temp.v[0] = ReadETHReg(EDMACSL).Val; 
0405C:  MOVLW  16
0405E:  MOVWF  x2A
04060:  MOVLB  0
04062:  CALL   1018
04066:  MOVFF  01,40D
.................... 	temp.v[1] = ReadETHReg(EDMACSH).Val; 
0406A:  MOVLW  17
0406C:  MOVLB  4
0406E:  MOVWF  x2A
04070:  MOVLB  0
04072:  CALL   1018
04076:  MOVFF  01,40E
.................... 	return temp.Val; 
0407A:  MOVLB  4
0407C:  MOVFF  40D,01
04080:  MOVFF  40E,02
.................... } 
04084:  MOVLB  0
04086:  RETLW  00
.................... #endif	// End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  * 							  destination MAC address) to copy from. 
....................  *					TxOffset: Offset in the TX buffer (0=first byte of 
....................  *							  destination MAC address) to copy to. 
....................  *					len:	  Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *					set), the hardware will wait until it is finished.  Then, 
....................  *					the DMA module will copy the data from the receive buffer 
....................  *					to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	BankSel(EDMASTL); 
.................... 	WriteReg(EDMASTL, temp.v[0]); 
.................... 	WriteReg(EDMASTH, temp.v[1]); 
....................  
.................... 	temp.Val += len-1; 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	WriteReg(EDMANDL, temp.v[0]); 
.................... 	WriteReg(EDMANDH, temp.v[1]); 
....................  
.................... 	TxOffset += TXSTART+1; 
.................... 	WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
.................... 	WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
.................... 	// Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
.................... 	// before starting the copy. 
.................... 	BFCReg(ECON1, ECON1_CSUMEN); 
.................... 	BFSReg(ECON1, ECON1_DMAST); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *										BYTE *PatternMask, 
....................  *										WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *					*PatternMask: Pointer to an 8 byte pattern mask which 
....................  *								  defines which bytes of the pattern are 
....................  *								  important.  At least one bit must be set. 
....................  *					PatternOffset: Offset from the beginning of the Ethernet 
....................  *								   frame (1st byte of destination address), to 
....................  *								   begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *					CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *					subset of the broadcast packets which are normally 
....................  *					received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
.................... 					BYTE *PatternMask, 
.................... 					WORD PatternOffset) 
.................... { 
.................... 	WORD_VAL i; 
.................... 	BYTE *MaskPtr; 
.................... 	BYTE UnmaskedPatternLen; 
....................  
.................... 	// Set the SPI write pointer and DMA startting address to the beginning of 
.................... 	// the transmit buffer 
.................... 	BankSel(EWRPTL); 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
.................... 	WriteReg(EDMASTL, LOW(TXSTART)); 
.................... 	WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
.................... 	// Fill the transmit buffer with the pattern to match against.  Only the 
.................... 	// bytes which have a mask bit of 1 are written into the buffer and will 
.................... 	// subsequently be used for checksum computation. 
.................... 	MaskPtr = PatternMask; 
.................... 	for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
.................... 	{ 
.................... 		if( *MaskPtr & i.v[1] ) 
.................... 		{ 
.................... 			MACPut(*Pattern); 
.................... 			UnmaskedPatternLen++; 
.................... 		} 
.................... 		Pattern++; 
....................  
.................... 		i.v[1] <<= 1; 
.................... 		if( i.v[1] == 0u ) 
.................... 		{ 
.................... 			i.v[1] = 0x01; 
.................... 			MaskPtr++; 
.................... 		} 
.................... 	} 
....................  
.................... 	// Calculate and set the DMA end address 
.................... 	i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
.................... 	WriteReg(EDMANDL, i.v[0]); 
.................... 	WriteReg(EDMANDH, i.v[1]); 
....................  
.................... 	// Calculate the checksum on the given pattern using the DMA module 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Make certain that the PM filter isn't enabled while it is 
.................... 	// being reconfigured. 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
.................... 	// Get the calculated DMA checksum and store it in the PM 
.................... 	// checksum registers 
.................... 	i.v[0] == ReadETHReg(EDMACSL).Val; 
.................... 	i.v[1] == ReadETHReg(EDMACSH).Val; 
.................... 	WriteReg(EPMCSL, i.v[0]); 
.................... 	WriteReg(EPMCSH, i.v[0]); 
....................  
.................... 	// Set the Pattern Match offset and 8 byte mask 
.................... 	WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
.................... 	WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
.................... 	for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
.................... 	{ 
.................... 		WriteReg(i.Val, *PatternMask++); 
.................... 	} 
....................  
.................... 	// Begin using the new Pattern Match filter instead of the 
.................... 	// broadcast filter 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *					filter (if enabled) and returns to the default filter 
....................  *					configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
.................... 	return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *					increments ERDPT so MACGet() can be called again.  The 
....................  *					increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
03F04:  BCF    F95.1
03F06:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
03F08:  MOVLW  3A
03F0A:  MOVLB  4
03F0C:  MOVWF  x35
03F0E:  MOVLB  0
03F10:  CALL   1008
....................    c=ENCSPIXfer(0); 
03F14:  MOVLB  4
03F16:  CLRF   x35
03F18:  MOVLB  0
03F1A:  CALL   1008
03F1E:  MOVFF  01,40F
....................    SPIUnselectEthernet(); 
03F22:  BCF    F95.1
03F24:  BSF    F8C.1
....................    return(c); 
03F26:  MOVLB  4
03F28:  MOVFF  40F,01
.................... }//end MACGet 
03F2C:  MOVLB  0
03F2E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *					len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *					and places them into local memory.  With SPI burst support, 
....................  *					it performs much faster than multiple MACGet() calls. 
....................  *					ERDPT is incremented after each byte, following the same 
....................  *					rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	int16 i; 
....................  
.................... 	// Start the burst operation 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM;			// Send the Read Buffer Memory opcode. 
.................... 	i = 0; 
.................... 	val--; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Read the data 
.................... 	while(i<len) 
.................... 	{ 
.................... 		SSPBUF = 0;			// Send a dummy byte to receive a byte 
.................... 		i++; 
.................... 		val++; 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is received. 
.................... 		PIR1_SSPIF = 0; 
.................... 		*val = SSPBUF; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
030DE:  MOVLB  4
030E0:  CLRF   x1D
030E2:  CLRF   x1E
....................  
....................    SPISelectEthernet(); 
030E4:  BCF    F95.1
030E6:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
030E8:  MOVLW  3A
030EA:  MOVWF  x35
030EC:  MOVLB  0
030EE:  CALL   1008
....................    while(i<len) 
....................    { 
030F2:  MOVLB  4
030F4:  MOVF   x1E,W
030F6:  SUBWF  x1C,W
030F8:  BNC   3132
030FA:  BNZ   3102
030FC:  MOVF   x1B,W
030FE:  SUBWF  x1D,W
03100:  BC    3132
....................       *val=ENCSPIXfer(0); 
03102:  MOVFF  41A,03
03106:  MOVFF  419,41F
0310A:  MOVFF  41A,420
0310E:  CLRF   x35
03110:  MOVLB  0
03112:  CALL   1008
03116:  MOVFF  420,FEA
0311A:  MOVFF  41F,FE9
0311E:  MOVFF  01,FEF
....................       val++; 
03122:  MOVLB  4
03124:  INCF   x19,F
03126:  BTFSC  FD8.2
03128:  INCF   x1A,F
....................       i++; 
0312A:  INCF   x1D,F
0312C:  BTFSC  FD8.2
0312E:  INCF   x1E,F
....................    } 
03130:  BRA    30F4
....................    SPIUnselectEthernet(); 
03132:  BCF    F95.1
03134:  BSF    F8C.1
....................  
....................    return(i); 
03136:  MOVFF  41D,01
0313A:  MOVFF  41E,02
.................... }//end MACGetArray 
0313E:  MOVLB  0
03140:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *					(8 bits) and data to write (8 bits) over the SPI. 
....................  *					EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the opcode and constant. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = val;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until byte is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0351E:  BCF    F95.1
03520:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
03522:  MOVLW  7A
03524:  MOVLB  4
03526:  MOVWF  x35
03528:  MOVLB  0
0352A:  CALL   1008
....................    ENCSPIXfer(val); 
0352E:  MOVFF  42E,435
03532:  CALL   1008
....................    SPIUnselectEthernet(); 
03536:  BCF    F95.1
03538:  BSF    F8C.1
.................... }//end MACPut 
0353A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *					len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *					ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *					calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	// Select the chip and send the proper opcode 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the Write Buffer Memory opcode 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Send the data 
.................... 	while(len) 
.................... 	{ 
.................... 		SSPBUF = *val;		// Start sending the byte 
.................... 		val++;				// Increment after writing to SSPBUF to increase speed 
.................... 		len--;				// Decrement after writing to SSPBUF to increase speed 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is transmitted 
.................... 		PIR1_SSPIF = 0; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0353C:  BCF    F95.1
0353E:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
03540:  MOVLW  7A
03542:  MOVLB  4
03544:  MOVWF  x35
03546:  MOVLB  0
03548:  CALL   1008
....................    while(len--) 
....................    { 
0354C:  MOVLB  4
0354E:  MOVFF  432,03
03552:  MOVF   x31,W
03554:  BTFSC  FD8.2
03556:  DECF   x32,F
03558:  DECF   x31,F
0355A:  IORWF  03,W
0355C:  BZ    3582
....................       ENCSPIXfer(*val); 
0355E:  MOVFF  430,03
03562:  MOVFF  42F,FE9
03566:  MOVFF  430,FEA
0356A:  MOVFF  FEF,433
0356E:  MOVFF  433,435
03572:  MOVLB  0
03574:  CALL   1008
....................       val++; 
03578:  MOVLB  4
0357A:  INCF   x2F,F
0357C:  BTFSC  FD8.2
0357E:  INCF   x30,F
....................    } 
03580:  BRA    354E
....................    SPIUnselectEthernet(); 
03582:  BCF    F95.1
03584:  BSF    F8C.1
.................... }//end MACPutArray 
03586:  MOVLB  0
03588:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *					the Ethernet controller.  It resets all register contents 
....................  *					(except for ECOCON) and returns the device to the power 
....................  *					on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = SR; 
.................... 	while(!PIR1_SSPIF);		// Wait until the command is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01042:  BCF    F95.1
01044:  BCF    F8C.1
....................    ENCSPIXfer(SR); 
01046:  MOVLW  FF
01048:  MOVLB  4
0104A:  MOVWF  x35
0104C:  MOVLB  0
0104E:  RCALL  1008
....................    SPIUnselectEthernet(); 
01050:  BCF    F95.1
01052:  BSF    F8C.1
.................... }//end SendSystemReset 
01054:  GOTO   1318 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *					the SPI and then retrives the register contents in the 
....................  *					next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *					registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	// Select the chip and send the Read Control Register opcode/address 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RCR | Address; 
....................  
.................... 	while(!PIR1_SSPIF);		// Wait until the opcode/address is transmitted 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents 
.................... 	while(!PIR1_SSPIF);		// Wait until the register is received 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
01018:  BCF    F95.1
0101A:  BCF    F8C.1
....................    ENCSPIXfer(RCR | Address); 
0101C:  MOVFF  42A,42C
01020:  MOVFF  42A,435
01024:  MOVLB  0
01026:  RCALL  1008
....................    c=ENCSPIXfer(0); 
01028:  MOVLB  4
0102A:  CLRF   x35
0102C:  MOVLB  0
0102E:  RCALL  1008
01030:  MOVFF  01,42B
....................    SPIUnselectEthernet(); 
01034:  BCF    F95.1
01036:  BSF    F8C.1
....................    return(c); 
01038:  MOVLB  4
0103A:  MOVFF  42B,01
.................... }//end ReadETHReg 
0103E:  MOVLB  0
01040:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *					as a dummy byte over the SPI and then retrives the 
....................  *					register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *					registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	SPISelectEthernet(); 
....................  
.................... 	SSPBUF = RCR | Address;	// Send the Read Control Register opcode and 
.................... 							//   address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send a dummy byte 
.................... 	while(!PIR1_SSPIF);		// Wait for the dummy byte to be transmitted 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send another dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
010E8:  BCF    F95.1
010EA:  BCF    F8C.1
....................  
....................    ENCSPIXfer(RCR | Address); 
010EC:  MOVFF  385,387
010F0:  MOVFF  385,435
010F4:  MOVLB  0
010F6:  RCALL  1008
....................    ENCSPIXfer(0); 
010F8:  MOVLB  4
010FA:  CLRF   x35
010FC:  MOVLB  0
010FE:  RCALL  1008
....................    c=ENCSPIXfer(0); 
01100:  MOVLB  4
01102:  CLRF   x35
01104:  MOVLB  0
01106:  RCALL  1008
01108:  MOVFF  01,386
....................  
....................    SPIUnselectEthernet(); 
0110C:  BCF    F95.1
0110E:  BSF    F8C.1
....................  
....................    return(c); 
01110:  MOVLB  3
01112:  MOVFF  386,01
.................... }//end ReadMACReg 
01116:  MOVLB  0
01118:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
.................... 	PHYREG Result; 
....................  
.................... 	// Set the right address and start the register read operation 
.................... 	BankSel(MIREGADR); 
*
011B0:  MOVLW  02
011B2:  MOVLB  4
011B4:  MOVWF  x2E
011B6:  MOVLW  14
011B8:  MOVWF  x2D
011BA:  MOVLB  0
011BC:  RCALL  10B2
.................... 	WriteReg(MIREGADR, Register); 
011BE:  MOVLW  14
011C0:  MOVLB  4
011C2:  MOVWF  x30
011C4:  MOVFF  382,431
011C8:  MOVLB  0
011CA:  RCALL  1058
.................... 	WriteReg(MICMD, MICMD_MIIRD); 
011CC:  MOVLW  12
011CE:  MOVLB  4
011D0:  MOVWF  x30
011D2:  MOVLW  01
011D4:  MOVWF  x31
011D6:  MOVLB  0
011D8:  RCALL  1058
....................  
.................... 	// Loop to wait until the PHY register has been read through the MII 
.................... 	// This requires 10.24us 
.................... 	BankSel(MISTAT); 
011DA:  MOVLW  03
011DC:  MOVLB  4
011DE:  MOVWF  x2E
011E0:  MOVLW  0A
011E2:  MOVWF  x2D
011E4:  MOVLB  0
011E6:  RCALL  10B2
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
011E8:  MOVLW  0A
011EA:  MOVLB  3
011EC:  MOVWF  x85
011EE:  MOVLB  0
011F0:  RCALL  10E8
011F2:  MOVFF  01,385
011F6:  MOVLW  00
011F8:  MOVLB  3
011FA:  BTFSC  01.0
011FC:  MOVLW  01
011FE:  XORLW  00
01200:  BTFSC  FD8.2
01202:  BRA    1208
01204:  MOVLB  0
01206:  BRA    11E8
....................  
.................... 	// Stop reading 
.................... 	BankSel(MIREGADR); 
01208:  MOVLW  02
0120A:  MOVLB  4
0120C:  MOVWF  x2E
0120E:  MOVLW  14
01210:  MOVWF  x2D
01212:  MOVLB  0
01214:  RCALL  10B2
.................... 	WriteReg(MICMD, 0x00); 
01216:  MOVLW  12
01218:  MOVLB  4
0121A:  MOVWF  x30
0121C:  CLRF   x31
0121E:  MOVLB  0
01220:  RCALL  1058
....................  
.................... 	// Obtain results and return 
.................... 	Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
01222:  MOVLW  18
01224:  MOVLB  3
01226:  MOVWF  x85
01228:  MOVLB  0
0122A:  RCALL  10E8
0122C:  MOVFF  01,383
.................... 	Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
01230:  MOVLW  19
01232:  MOVLB  3
01234:  MOVWF  x85
01236:  MOVLB  0
01238:  RCALL  10E8
0123A:  MOVFF  01,384
.................... 	return Result; 
0123E:  MOVLB  3
01240:  MOVFF  383,01
01244:  MOVFF  384,02
.................... }//end ReadPHYReg 
01248:  MOVLB  0
0124A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *					  The top 3 bits must be 0. 
....................  *					Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *					SPI and then sends the data to write in the next 8 SPI 
....................  *					clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *					BFSReg() functions.  It is seperate to maximize speed. 
....................  *					Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *					can write to any ETH or MAC register.  Writing to PHY 
....................  *					registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WCR | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01058:  BCF    F95.1
0105A:  BCF    F8C.1
....................    ENCSPIXfer(WCR | Address); 
0105C:  MOVLB  4
0105E:  MOVF   x30,W
01060:  IORLW  40
01062:  MOVWF  x32
01064:  MOVWF  x35
01066:  MOVLB  0
01068:  RCALL  1008
....................    ENCSPIXfer(Data); 
0106A:  MOVFF  431,435
0106E:  RCALL  1008
....................    SPIUnselectEthernet(); 
01070:  BCF    F95.1
01072:  BSF    F8C.1
.................... }//end WriteReg 
01074:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFSReg() functions.  It is separate to maximize speed. 
....................  *					BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFC | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01076:  BCF    F95.1
01078:  BCF    F8C.1
....................    ENCSPIXfer(BFC | Address); 
0107A:  MOVLB  4
0107C:  MOVF   x2F,W
0107E:  IORLW  A0
01080:  MOVWF  x31
01082:  MOVWF  x35
01084:  MOVLB  0
01086:  RCALL  1008
....................    ENCSPIXfer(Data); 
01088:  MOVFF  430,435
0108C:  RCALL  1008
....................    SPIUnselectEthernet(); 
0108E:  BCF    F95.1
01090:  BSF    F8C.1
.................... }//end BFCReg 
01092:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFCReg() functions.  It is separate to maximize speed. 
....................  *					BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFS | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01094:  BCF    F95.1
01096:  BCF    F8C.1
....................    ENCSPIXfer(BFS | Address); 
01098:  MOVLB  4
0109A:  MOVF   x32,W
0109C:  IORLW  80
0109E:  MOVWF  x34
010A0:  MOVWF  x35
010A2:  MOVLB  0
010A4:  RCALL  1008
....................    ENCSPIXfer(Data); 
010A6:  MOVFF  433,435
010AA:  RCALL  1008
....................    SPIUnselectEthernet(); 
010AC:  BCF    F95.1
010AE:  BSF    F8C.1
.................... }//end BFSReg 
010B0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *					16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
.................... 	// Write the register address 
.................... 	BankSel(MIREGADR); 
*
0111A:  MOVLW  02
0111C:  MOVLB  4
0111E:  MOVWF  x2E
01120:  MOVLW  14
01122:  MOVWF  x2D
01124:  MOVLB  0
01126:  RCALL  10B2
.................... 	WriteReg(MIREGADR, Register); 
01128:  MOVLW  14
0112A:  MOVLB  4
0112C:  MOVWF  x30
0112E:  MOVFF  381,431
01132:  MOVLB  0
01134:  RCALL  1058
....................  
.................... 	// Write the data 
.................... 	// Order is important: write low byte first, high byte last 
.................... 	WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
01136:  MOVLW  03
01138:  MOVLB  3
0113A:  MOVWF  x85
0113C:  MOVLW  82
0113E:  MOVWF  FE9
01140:  MOVFF  385,FEA
01144:  MOVFF  FEF,386
01148:  MOVLW  16
0114A:  MOVLB  4
0114C:  MOVWF  x30
0114E:  MOVFF  386,431
01152:  MOVLB  0
01154:  RCALL  1058
.................... 	WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
01156:  MOVLW  03
01158:  MOVLB  3
0115A:  MOVWF  x85
0115C:  MOVLW  82
0115E:  MOVWF  x84
01160:  MOVLW  01
01162:  ADDWF  x84,W
01164:  MOVWF  FE9
01166:  MOVLW  00
01168:  ADDWFC x85,W
0116A:  MOVWF  FEA
0116C:  MOVFF  FEF,386
01170:  MOVLW  17
01172:  MOVLB  4
01174:  MOVWF  x30
01176:  MOVFF  386,431
0117A:  MOVLB  0
0117C:  RCALL  1058
....................  
.................... 	// Wait until the PHY register has been written 
.................... 	BankSel(MISTAT); 
0117E:  MOVLW  03
01180:  MOVLB  4
01182:  MOVWF  x2E
01184:  MOVLW  0A
01186:  MOVWF  x2D
01188:  MOVLB  0
0118A:  RCALL  10B2
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0118C:  MOVLW  0A
0118E:  MOVLB  3
01190:  MOVWF  x85
01192:  MOVLB  0
01194:  RCALL  10E8
01196:  MOVFF  01,384
0119A:  MOVLW  00
0119C:  MOVLB  3
0119E:  BTFSC  01.0
011A0:  MOVLW  01
011A2:  XORLW  00
011A4:  BTFSC  FD8.2
011A6:  BRA    11AC
011A8:  MOVLB  0
011AA:  BRA    118C
.................... }//end WritePHYReg 
011AC:  MOVLB  0
011AE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *					  select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *					changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
.................... 	BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
010B2:  MOVLW  1F
010B4:  MOVLB  4
010B6:  MOVWF  x2F
010B8:  MOVLW  03
010BA:  MOVWF  x30
010BC:  MOVLB  0
010BE:  RCALL  1076
.................... 	BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
010C0:  MOVLW  04
010C2:  MOVLB  4
010C4:  MOVWF  x30
010C6:  MOVLW  2D
010C8:  MOVWF  x2F
010CA:  MOVLW  01
010CC:  ADDWF  x2F,W
010CE:  MOVWF  FE9
010D0:  MOVLW  00
010D2:  ADDWFC x30,W
010D4:  MOVWF  FEA
010D6:  MOVFF  FEF,431
010DA:  MOVLW  1F
010DC:  MOVWF  x32
010DE:  MOVFF  431,433
010E2:  MOVLB  0
010E4:  RCALL  1094
.................... }//end BankSel 
010E6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *					FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *					RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *					entire dual port memory and calculate a checksum of the 
....................  *					data stored within.  Address and Random fill modes are 
....................  *					used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *					seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *					is running, additional confidence that the memory is 
....................  *					working can be obtained by calling TestMemory multiple 
....................  *					times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
.................... 	#define RANDOM_FILL		0b0000 
.................... 	#define ADDRESS_FILL	0b0100 
.................... 	#define PATTERN_SHIFT	0b1000 
....................  
.................... 	WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
.................... 	// Select Bank 0 and disable anything that could have been in progress 
.................... 	WriteReg(ECON1, 0x00); 
....................  
.................... 	// Set up necessary pointers for the DMA to calculate over the entire 
.................... 	// memory 
.................... 	WriteReg(EDMASTL, 0x00); 
.................... 	WriteReg(EDMASTH, 0x00); 
.................... 	WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
.................... 	// Enable Test Mode and do an Address Fill 
.................... 	BankSel(EBSTCON); 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 						 EBSTCON_BISTST | 
.................... 						 ADDRESS_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode before 
.................... 	// starting any DMA operations. 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
.................... 	// Compare the results 
.................... 	// 0xF807 should always be generated in Address fill mode 
.................... 	if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
.................... 		return FALSE; 
....................  
.................... 	// Seed the random number generator and begin another Random Fill test 
.................... 	// with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
.................... 	WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
.................... 	WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 					  EBSTCON_PSEL | 
.................... 					  EBSTCON_BISTST | 
.................... 					  RANDOM_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode since 
.................... 	// we won't be needing it anymore 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
.................... 	return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *						FULL: Set full duplex mode 
....................  *						HALF: Set half duplex mode 
....................  *						USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *								 PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *					operation, sets PHY up for full duplex operation, and 
....................  *					reenables RX logic.  The back-to-back inter-packet gap 
....................  *					register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *					function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
.................... 	REG Register; 
.................... 	PHYREG PhyReg; 
....................  
.................... 	// Disable receive logic and abort any packets currently being transmitted 
.................... 	BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0124C:  MOVLW  1F
0124E:  MOVLB  4
01250:  MOVWF  x2F
01252:  MOVLW  0C
01254:  MOVWF  x30
01256:  MOVLB  0
01258:  RCALL  1076
....................  
.................... 	// Set the PHY to the proper duplex mode 
.................... 	PhyReg = ReadPHYReg(PHCON1); 
0125A:  MOVLB  3
0125C:  CLRF   x82
0125E:  MOVLB  0
01260:  RCALL  11B0
01262:  MOVFF  02,380
01266:  MOVFF  01,37F
.................... 	if(DuplexState == USE_PHY) 
0126A:  MOVLB  3
0126C:  MOVF   x7D,W
0126E:  SUBLW  02
01270:  BNZ   127A
.................... 	{ 
.................... 		DuplexState = PhyReg.PHCON1bits.PDPXMD; 
01272:  CLRF   x7D
01274:  BTFSC  x80.0
01276:  INCF   x7D,F
.................... 	} 
.................... 	else 
01278:  BRA    128E
.................... 	{ 
.................... 		PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0127A:  BCF    x80.0
0127C:  BTFSC  x7D.0
0127E:  BSF    x80.0
.................... 		WritePHYReg(PHCON1, PhyReg.Val); 
01280:  CLRF   x81
01282:  MOVFF  380,383
01286:  MOVFF  37F,382
0128A:  MOVLB  0
0128C:  RCALL  111A
.................... 	} 
....................  
.................... 	// Set the MAC to the proper duplex mode 
.................... 	BankSel(MACON3); 
0128E:  MOVLW  02
01290:  MOVLB  4
01292:  MOVWF  x2E
01294:  MOVWF  x2D
01296:  MOVLB  0
01298:  RCALL  10B2
.................... 	Register = ReadMACReg(MACON3); 
0129A:  MOVLW  02
0129C:  MOVLB  3
0129E:  MOVWF  x85
012A0:  MOVLB  0
012A2:  RCALL  10E8
012A4:  MOVFF  01,37E
.................... 	Register.MACON3bits.FULDPX = DuplexState; 
012A8:  MOVLB  3
012AA:  BCF    x7E.0
012AC:  BTFSC  x7D.0
012AE:  BSF    x7E.0
.................... 	WriteReg(MACON3, Register.Val); 
012B0:  MOVLW  02
012B2:  MOVLB  4
012B4:  MOVWF  x30
012B6:  MOVFF  37E,431
012BA:  MOVLB  0
012BC:  RCALL  1058
....................  
.................... 	// Set the back-to-back inter-packet gap time to IEEE specified 
.................... 	// requirements.  The meaning of the MABBIPG value changes with the duplex 
.................... 	// state, so it must be updated in this function. 
.................... 	// In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
.................... 	WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
012BE:  MOVLB  3
012C0:  MOVF   x7D,F
012C2:  BZ    12C8
012C4:  MOVLW  15
012C6:  BRA    12CA
012C8:  MOVLW  12
012CA:  MOVWF  x81
012CC:  MOVLW  04
012CE:  MOVLB  4
012D0:  MOVWF  x30
012D2:  MOVFF  381,431
012D6:  MOVLB  0
012D8:  RCALL  1058
....................  
.................... 	// Reenable receive logic 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
012DA:  MOVLW  1F
012DC:  MOVLB  4
012DE:  MOVWF  x32
012E0:  MOVLW  04
012E2:  MOVWF  x33
012E4:  MOVLB  0
012E6:  RCALL  1094
.................... }//end MACSetDuplex 
012E8:  GOTO   14AA (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *					sleep mode, no packets can be transmitted or received. 
....................  *					All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  * 					called, this function will block until it is it complete. 
....................  *					If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
.................... 	// Disable packet reception 
.................... 	BFCReg(ECON1, ECON1_RXEN); 
....................  
.................... 	// Make sure any last packet which was in-progress when RXEN was cleared 
.................... 	// is completed 
.................... 	while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
.................... 	// If a packet is being transmitted, wait for it to finish 
.................... 	while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
.................... 	// Enter sleep mode 
.................... 	BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *					after a previous call to MACPowerDown().  Calling this 
....................  *					function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *					you don't wait for the link to go up first.  MACIsLinked() 
....................  *					can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
.................... 	// Leave power down mode 
.................... 	BFCReg(ECON2, ECON2_PWRSV); 
....................  
.................... 	// Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
.................... 	// delay is required for the PHY module to return to an operational state. 
.................... 	while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *								0x01: Divide by 1 (25 MHz) 
....................  *								0x02: Divide by 2 (12.5 MHz) 
....................  *								0x03: Divide by 3 (8.333333 MHz) 
....................  *								0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *								0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *					The CLKOUT pin will beginning outputting the new frequency 
....................  *					immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *						   0x01: Divide by 1 (25 MHz) 
....................  *						   0x02: Divide by 2 (12.5 MHz) 
....................  *						   0x03: Divide by 3 (8.333333 MHz) 
....................  *						   0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *						   0x05: Divide by 8 (3.125 MHz) 
....................  *						   0x06: Reserved 
....................  *						   0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
*
05F42:  MOVFF  38F,58
....................    return(MACIsTxReady(TRUE)); 
05F46:  MOVLW  01
05F48:  MOVLB  4
05F4A:  MOVWF  x0B
05F4C:  MOVLB  0
05F4E:  CALL   497A
05F52:  MOVF   01,W
.................... } 
05F54:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
03D0E:  MOVLW  03
03D10:  MOVLB  3
03D12:  MOVWF  xA1
03D14:  MOVLW  8C
03D16:  MOVFF  3A1,41A
03D1A:  MOVFF  FE8,419
03D1E:  MOVLB  4
03D20:  CLRF   x1C
03D22:  MOVLW  14
03D24:  MOVWF  x1B
03D26:  MOVLB  0
03D28:  CALL   30DE
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
03D2C:  MOVLB  3
03D2E:  MOVF   x8C,W
03D30:  ANDLW  F0
03D32:  SUBLW  40
03D34:  BZ    3D3C
....................     	return FALSE; 
03D36:  MOVLW  00
03D38:  MOVWF  01
03D3A:  BRA    3DF6
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
03D3C:  MOVF   x8C,W
03D3E:  ANDLW  0F
03D40:  MOVWF  00
03D42:  RLCF   00,W
03D44:  MOVLB  0
03D46:  MOVWF  x89
03D48:  RLCF   x89,F
03D4A:  MOVLW  FC
03D4C:  ANDWF  x89,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
03D4E:  MOVLB  3
03D50:  CLRF   xDC
03D52:  CLRF   xDB
03D54:  CLRF   xDE
03D56:  MOVFF  89,3DD
03D5A:  MOVLB  0
03D5C:  RCALL  3AA2
03D5E:  MOVFF  02,38B
03D62:  MOVFF  01,38A
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
03D66:  MOVLB  3
03D68:  CLRF   xB4
03D6A:  MOVFF  89,3B3
03D6E:  MOVLB  0
03D70:  RCALL  3BB0
....................  
....................     if(CalcChecksum.Val) 
03D72:  MOVLB  3
03D74:  MOVF   x8A,W
03D76:  IORWF  x8B,W
03D78:  BZ    3D80
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
03D7A:  MOVLW  00
03D7C:  MOVWF  01
03D7E:  BRA    3DF6
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
03D80:  MOVLW  03
03D82:  MOVLB  4
03D84:  MOVWF  x25
03D86:  MOVLW  8C
03D88:  MOVWF  x24
03D8A:  MOVLB  0
03D8C:  RCALL  3C2E
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
03D8E:  MOVLB  3
03D90:  MOVF   x82,W
03D92:  IORWF  x83,W
03D94:  BZ    3DAE
....................         localIP->Val    = header.DestAddress.Val; 
03D96:  MOVFF  382,FE9
03D9A:  MOVFF  383,FEA
03D9E:  MOVFF  39C,FEF
03DA2:  MOVFF  39D,FEC
03DA6:  MOVFF  39E,FEC
03DAA:  MOVFF  39F,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
03DAE:  MOVLW  06
03DB0:  ADDWF  x84,W
03DB2:  MOVWF  FE9
03DB4:  MOVLW  00
03DB6:  ADDWFC x85,W
03DB8:  MOVWF  FEA
03DBA:  MOVFF  398,FEF
03DBE:  MOVFF  399,FEC
03DC2:  MOVFF  39A,FEC
03DC6:  MOVFF  39B,FEC
....................     *protocol           = header.Protocol; 
03DCA:  MOVFF  386,FE9
03DCE:  MOVFF  387,FEA
03DD2:  MOVFF  395,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
03DD6:  MOVFF  388,FE9
03DDA:  MOVFF  389,FEA
03DDE:  MOVLB  0
03DE0:  MOVF   x89,W
03DE2:  MOVLB  3
03DE4:  SUBWF  x8E,W
03DE6:  MOVWF  00
03DE8:  MOVLW  00
03DEA:  SUBWFB x8F,W
03DEC:  MOVFF  00,FEF
03DF0:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
03DF2:  MOVLW  01
03DF4:  MOVWF  01
.................... } 
03DF6:  MOVLB  0
03DF8:  GOTO   A1D2 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
04B96:  MOVLW  14
04B98:  MOVWF  x89
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
04B9A:  MOVLW  45
04B9C:  MOVLB  4
04B9E:  MOVWF  x10
....................     header.TypeOfService    = IP_SERVICE; 
04BA0:  CLRF   x11
....................     header.TotalLength      = sizeof(header) + len; 
04BA2:  MOVLW  14
04BA4:  ADDWF  x0E,W
04BA6:  MOVWF  x12
04BA8:  MOVLW  00
04BAA:  ADDWFC x0F,W
04BAC:  MOVWF  x13
....................     header.Identification   = ++_Identifier; 
04BAE:  MOVLB  0
04BB0:  INCF   x87,F
04BB2:  BTFSC  FD8.2
04BB4:  INCF   x88,F
04BB6:  MOVFF  88,415
04BBA:  MOVFF  87,414
....................     header.FragmentInfo     = 0; 
04BBE:  MOVLB  4
04BC0:  CLRF   x17
04BC2:  CLRF   x16
....................     header.TimeToLive       = MY_IP_TTL; 
04BC4:  MOVLW  64
04BC6:  MOVWF  x18
....................     header.Protocol         = protocol; 
04BC8:  MOVFF  40D,419
....................     header.HeaderChecksum   = 0; 
04BCC:  CLRF   x1B
04BCE:  CLRF   x1A
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
04BD0:  MOVFF  19,41F
04BD4:  MOVFF  18,41E
04BD8:  MOVFF  17,41D
04BDC:  MOVFF  16,41C
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
04BE0:  MOVLW  06
04BE2:  ADDWF  x0B,W
04BE4:  MOVWF  FE9
04BE6:  MOVLW  00
04BE8:  ADDWFC x0C,W
04BEA:  MOVWF  FEA
04BEC:  MOVFF  FEF,00
04BF0:  MOVFF  FEC,01
04BF4:  MOVFF  FEC,02
04BF8:  MOVFF  FEC,03
04BFC:  MOVFF  03,423
04C00:  MOVFF  02,422
04C04:  MOVFF  01,421
04C08:  MOVFF  00,420
....................  
....................     SwapIPHeader(&header); 
04C0C:  MOVLW  04
04C0E:  MOVWF  x25
04C10:  MOVLW  10
04C12:  MOVWF  x24
04C14:  MOVLB  0
04C16:  CALL   3C2E
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
04C1A:  MOVLB  4
04C1C:  MOVFF  40B,01
04C20:  MOVFF  40C,03
04C24:  MOVFF  40B,424
04C28:  MOVFF  40C,425
04C2C:  MOVLW  14
04C2E:  ADDWF  x0E,W
04C30:  MOVWF  x26
04C32:  MOVLW  00
04C34:  ADDWFC x0F,W
04C36:  MOVWF  x27
04C38:  MOVFF  40C,429
04C3C:  MOVFF  40B,428
04C40:  CLRF   x2A
04C42:  MOVWF  x2C
04C44:  MOVFF  426,42B
04C48:  MOVLB  0
04C4A:  CALL   358A
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
04C4E:  MOVLW  04
04C50:  MOVLB  4
04C52:  MOVWF  x25
04C54:  MOVLW  10
04C56:  MOVFF  425,430
04C5A:  MOVWF  x2F
04C5C:  CLRF   x32
04C5E:  MOVLW  14
04C60:  MOVWF  x31
04C62:  MOVLB  0
04C64:  CALL   353C
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
04C68:  MOVLB  4
04C6A:  CLRF   x25
04C6C:  CLRF   x24
04C6E:  CLRF   x27
04C70:  MOVLW  14
04C72:  MOVWF  x26
04C74:  MOVLB  0
04C76:  RCALL  4ABE
04C78:  MOVFF  02,41B
04C7C:  MOVFF  01,41A
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
04C80:  MOVFF  4D,424
04C84:  MOVLB  4
04C86:  CLRF   x26
04C88:  MOVLW  0A
04C8A:  MOVWF  x25
04C8C:  MOVLB  0
04C8E:  CALL   3474
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
04C92:  MOVLW  04
04C94:  MOVLB  4
04C96:  MOVWF  x25
04C98:  MOVLW  1A
04C9A:  MOVFF  425,430
04C9E:  MOVWF  x2F
04CA0:  CLRF   x32
04CA2:  MOVLW  02
04CA4:  MOVWF  x31
04CA6:  MOVLB  0
04CA8:  CALL   353C
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
04CAC:  MOVFF  4D,424
04CB0:  MOVLB  4
04CB2:  CLRF   x26
04CB4:  MOVLW  14
04CB6:  MOVWF  x25
04CB8:  MOVLB  0
04CBA:  CALL   3474
.................... #endif 
....................  
....................     return 0x0; 
04CBE:  MOVLW  00
04CC0:  MOVWF  01
04CC2:  MOVWF  02
.................... } 
04CC4:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
03EEA:  MOVF   x89,W
03EEC:  MOVLB  3
03EEE:  ADDWF  xAF,W
03EF0:  MOVWF  xB1
03EF2:  MOVLW  00
03EF4:  ADDWFC xB0,W
03EF6:  MOVWF  xB2
03EF8:  MOVWF  xB4
03EFA:  MOVFF  3B1,3B3
03EFE:  MOVLB  0
03F00:  RCALL  3BB0
.................... } 
03F02:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
03C2E:  MOVLW  02
03C30:  MOVLB  4
03C32:  ADDWF  x24,W
03C34:  MOVWF  01
03C36:  MOVLW  00
03C38:  ADDWFC x25,W
03C3A:  MOVWF  03
03C3C:  MOVFF  01,426
03C40:  MOVWF  x27
03C42:  MOVLW  02
03C44:  ADDWF  x24,W
03C46:  MOVWF  FE9
03C48:  MOVLW  00
03C4A:  ADDWFC x25,W
03C4C:  MOVWF  FEA
03C4E:  MOVFF  FEC,429
03C52:  MOVF   FED,F
03C54:  MOVFF  FEF,428
03C58:  MOVFF  429,42B
03C5C:  MOVFF  428,42A
03C60:  MOVLB  0
03C62:  CALL   3142
03C66:  MOVFF  427,FEA
03C6A:  MOVFF  426,FE9
03C6E:  MOVFF  02,FEC
03C72:  MOVF   FED,F
03C74:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
03C78:  MOVLW  04
03C7A:  MOVLB  4
03C7C:  ADDWF  x24,W
03C7E:  MOVWF  01
03C80:  MOVLW  00
03C82:  ADDWFC x25,W
03C84:  MOVWF  03
03C86:  MOVFF  01,426
03C8A:  MOVWF  x27
03C8C:  MOVLW  04
03C8E:  ADDWF  x24,W
03C90:  MOVWF  FE9
03C92:  MOVLW  00
03C94:  ADDWFC x25,W
03C96:  MOVWF  FEA
03C98:  MOVFF  FEC,429
03C9C:  MOVF   FED,F
03C9E:  MOVFF  FEF,428
03CA2:  MOVFF  429,42B
03CA6:  MOVFF  428,42A
03CAA:  MOVLB  0
03CAC:  CALL   3142
03CB0:  MOVFF  427,FEA
03CB4:  MOVFF  426,FE9
03CB8:  MOVFF  02,FEC
03CBC:  MOVF   FED,F
03CBE:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
03CC2:  MOVLW  0A
03CC4:  MOVLB  4
03CC6:  ADDWF  x24,W
03CC8:  MOVWF  01
03CCA:  MOVLW  00
03CCC:  ADDWFC x25,W
03CCE:  MOVWF  03
03CD0:  MOVFF  01,426
03CD4:  MOVWF  x27
03CD6:  MOVLW  0A
03CD8:  ADDWF  x24,W
03CDA:  MOVWF  FE9
03CDC:  MOVLW  00
03CDE:  ADDWFC x25,W
03CE0:  MOVWF  FEA
03CE2:  MOVFF  FEC,429
03CE6:  MOVF   FED,F
03CE8:  MOVFF  FEF,428
03CEC:  MOVFF  429,42B
03CF0:  MOVFF  428,42A
03CF4:  MOVLB  0
03CF6:  CALL   3142
03CFA:  MOVFF  427,FEA
03CFE:  MOVFF  426,FE9
03D02:  MOVFF  02,FEC
03D06:  MOVF   FED,F
03D08:  MOVFF  01,FEF
.................... } 
03D0C:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
016A6:  MOVLB  3
016A8:  CLRF   x7C
016AA:  MOVF   x7C,W
016AC:  SUBLW  04
016AE:  BNC   1782
....................     { 
....................         ps = &TCB[s]; 
016B0:  MOVF   x7C,W
016B2:  MULLW  24
016B4:  MOVF   FF3,W
016B6:  CLRF   03
016B8:  ADDLW  8C
016BA:  MOVWF  01
016BC:  MOVLW  00
016BE:  ADDWFC 03,F
016C0:  MOVFF  01,37D
016C4:  MOVFF  03,37E
....................  
....................         ps->smState             = TCP_CLOSED; 
016C8:  MOVFF  37D,FE9
016CC:  MOVFF  37E,FEA
016D0:  MOVLW  0A
016D2:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
016D4:  MOVLW  23
016D6:  ADDWF  x7D,W
016D8:  MOVWF  FE9
016DA:  MOVLW  00
016DC:  ADDWFC x7E,W
016DE:  MOVWF  FEA
016E0:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
016E2:  MOVLW  23
016E4:  ADDWF  x7D,W
016E6:  MOVWF  FE9
016E8:  MOVLW  00
016EA:  ADDWFC x7E,W
016EC:  MOVWF  FEA
016EE:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
016F0:  MOVLW  23
016F2:  ADDWF  x7D,W
016F4:  MOVWF  FE9
016F6:  MOVLW  00
016F8:  ADDWFC x7E,W
016FA:  MOVWF  FEA
016FC:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
016FE:  MOVLW  23
01700:  ADDWF  x7D,W
01702:  MOVWF  FE9
01704:  MOVLW  00
01706:  ADDWFC x7E,W
01708:  MOVWF  FEA
0170A:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
0170C:  MOVLW  23
0170E:  ADDWF  x7D,W
01710:  MOVWF  FE9
01712:  MOVLW  00
01714:  ADDWFC x7E,W
01716:  MOVWF  FEA
01718:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
0171A:  MOVLW  0F
0171C:  ADDWF  x7D,W
0171E:  MOVWF  FE9
01720:  MOVLW  00
01722:  ADDWFC x7E,W
01724:  MOVWF  FEA
01726:  INCFSZ FEF,W
01728:  BRA    172C
0172A:  BRA    1758
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
0172C:  MOVLW  0F
0172E:  ADDWF  x7D,W
01730:  MOVWF  FE9
01732:  MOVLW  00
01734:  ADDWFC x7E,W
01736:  MOVWF  FEA
01738:  MOVFF  FEF,37F
0173C:  MOVFF  37F,3CF
01740:  MOVLB  0
01742:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
01746:  MOVLW  0F
01748:  MOVLB  3
0174A:  ADDWF  x7D,W
0174C:  MOVWF  FE9
0174E:  MOVLW  00
01750:  ADDWFC x7E,W
01752:  MOVWF  FEA
01754:  MOVLW  FF
01756:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
01758:  MOVLW  21
0175A:  ADDWF  x7D,W
0175C:  MOVWF  FE9
0175E:  MOVLW  00
01760:  ADDWFC x7E,W
01762:  MOVWF  FEA
01764:  CLRF   FEC
01766:  MOVF   FED,F
01768:  MOVLW  1E
0176A:  MOVWF  FEF
....................       ps->TxCount            = 0; 
0176C:  MOVLW  10
0176E:  ADDWF  x7D,W
01770:  MOVWF  FE9
01772:  MOVLW  00
01774:  ADDWFC x7E,W
01776:  MOVWF  FEA
01778:  CLRF   FEC
0177A:  MOVF   FED,F
0177C:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
0177E:  INCF   x7C,F
01780:  BRA    16AA
....................     TCPInit_RandSeed+=get_timer0(); 
01782:  MOVF   FD6,W
01784:  MOVLB  1
01786:  ADDWF  x40,F
01788:  MOVF   FD7,W
0178A:  ADDWFC x41,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0178C:  MOVF   FCE,W
0178E:  ADDWF  x40,F
01790:  MOVF   FCF,W
01792:  ADDWFC x41,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
01794:  MOVF   FCC,W
01796:  ADDWF  x40,F
01798:  MOVLW  00
0179A:  ADDWFC x41,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0179C:  MOVF   FB2,W
0179E:  ADDWF  x40,F
017A0:  MOVF   FB3,W
017A2:  ADDWFC x41,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
017A4:  MOVLB  3
017A6:  CLRF   x82
017A8:  CLRF   x81
017AA:  MOVFF  141,380
017AE:  MOVFF  140,37F
017B2:  MOVLB  0
017B4:  BRA    1578
....................     _NextPort=rand(); 
017B6:  BRA    1632
017B8:  MOVFF  02,8B
017BC:  MOVFF  01,8A
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
017C0:  MOVLW  04
017C2:  ADDWF  x8B,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
017C4:  MOVF   x8B,W
017C6:  SUBLW  12
017C8:  BC    17DE
017CA:  XORLW  FF
017CC:  BNZ   17D4
017CE:  MOVF   x8A,W
017D0:  SUBLW  87
017D2:  BC    17DE
017D4:  MOVLW  88
017D6:  SUBWF  x8A,F
017D8:  MOVLW  13
017DA:  SUBWFB x8B,F
017DC:  BRA    17C4
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
017DE:  MOVF   x8B,W
017E0:  SUBLW  03
017E2:  BNC   17E8
017E4:  MOVLW  04
017E6:  ADDWF  x8B,F
.................... } 
017E8:  GOTO   1992 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
*
01818:  MOVLB  3
0181A:  CLRF   x81
0181C:  MOVF   x81,W
0181E:  SUBLW  04
01820:  BNC   190A
....................    { 
....................       ps = &TCB[s]; 
01822:  MOVF   x81,W
01824:  MULLW  24
01826:  MOVF   FF3,W
01828:  CLRF   03
0182A:  ADDLW  8C
0182C:  MOVWF  01
0182E:  MOVLW  00
01830:  ADDWFC 03,F
01832:  MOVFF  01,382
01836:  MOVFF  03,383
....................  
....................       if(ps->smState == TCP_CLOSED) 
0183A:  MOVFF  382,FE9
0183E:  MOVFF  383,FEA
01842:  MOVF   FEF,W
01844:  SUBLW  0A
01846:  BNZ   1906
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
01848:  MOVFF  382,FE9
0184C:  MOVFF  383,FEA
01850:  CLRF   FEF
....................          ps->localPort           = port; 
01852:  MOVLW  0B
01854:  ADDWF  x82,W
01856:  MOVWF  FE9
01858:  MOVLW  00
0185A:  ADDWFC x83,W
0185C:  MOVWF  FEA
0185E:  MOVFF  380,FEC
01862:  MOVF   FED,F
01864:  MOVFF  37F,FEF
....................          ps->remotePort          = 0; 
01868:  MOVLW  0D
0186A:  ADDWF  x82,W
0186C:  MOVWF  FE9
0186E:  MOVLW  00
01870:  ADDWFC x83,W
01872:  MOVWF  FEA
01874:  CLRF   FEC
01876:  MOVF   FED,F
01878:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
0187A:  MOVLW  07
0187C:  ADDWF  x82,W
0187E:  MOVWF  FE9
01880:  MOVLW  00
01882:  ADDWFC x83,W
01884:  MOVWF  FEA
01886:  MOVF   FEE,F
01888:  MOVF   FEE,F
0188A:  CLRF   FEC
0188C:  MOVF   FED,F
0188E:  CLRF   FEF
01890:  MOVF   FED,F
01892:  CLRF   FEF
01894:  MOVF   FED,F
01896:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
01898:  MOVLW  23
0189A:  ADDWF  x82,W
0189C:  MOVWF  FE9
0189E:  MOVLW  00
018A0:  ADDWFC x83,W
018A2:  MOVWF  FEA
018A4:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
018A6:  MOVLW  23
018A8:  ADDWF  x82,W
018AA:  MOVWF  FE9
018AC:  MOVLW  00
018AE:  ADDWFC x83,W
018B0:  MOVWF  FEA
018B2:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
018B4:  MOVLW  0F
018B6:  ADDWF  x82,W
018B8:  MOVWF  FE9
018BA:  MOVLW  00
018BC:  ADDWFC x83,W
018BE:  MOVWF  FEA
018C0:  INCFSZ FEF,W
018C2:  BRA    18C6
018C4:  BRA    18F2
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
018C6:  MOVLW  0F
018C8:  ADDWF  x82,W
018CA:  MOVWF  FE9
018CC:  MOVLW  00
018CE:  ADDWFC x83,W
018D0:  MOVWF  FEA
018D2:  MOVFF  FEF,384
018D6:  MOVFF  384,3CF
018DA:  MOVLB  0
018DC:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
018E0:  MOVLW  0F
018E2:  MOVLB  3
018E4:  ADDWF  x82,W
018E6:  MOVWF  FE9
018E8:  MOVLW  00
018EA:  ADDWFC x83,W
018EC:  MOVWF  FEA
018EE:  MOVLW  FF
018F0:  MOVWF  FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
018F2:  MOVLW  23
018F4:  ADDWF  x82,W
018F6:  MOVWF  FE9
018F8:  MOVLW  00
018FA:  ADDWFC x83,W
018FC:  MOVWF  FEA
018FE:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
01900:  MOVFF  381,01
01904:  BRA    190E
....................       } 
....................    } 
01906:  INCF   x81,F
01908:  BRA    181C
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
0190A:  MOVLW  FE
0190C:  MOVWF  01
.................... } 
0190E:  MOVLB  0
01910:  GOTO   193A (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
06850:  MOVLB  3
06852:  MOVF   x8A,W
06854:  MULLW  24
06856:  MOVF   FF3,W
06858:  CLRF   x8C
0685A:  MOVWF  x8B
0685C:  MOVLW  8C
0685E:  ADDWF  x8B,W
06860:  MOVWF  FE9
06862:  MOVLW  00
06864:  ADDWFC x8C,W
06866:  MOVWF  FEA
06868:  MOVF   FEF,W
0686A:  SUBLW  03
0686C:  BZ    6872
0686E:  MOVLW  00
06870:  BRA    6874
06872:  MOVLW  01
06874:  MOVWF  01
.................... } 
06876:  MOVLB  0
06878:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
08676:  MOVLB  3
08678:  MOVF   x8A,W
0867A:  MULLW  24
0867C:  MOVF   FF3,W
0867E:  CLRF   03
08680:  ADDLW  8C
08682:  MOVWF  01
08684:  MOVLW  00
08686:  ADDWFC 03,F
08688:  MOVFF  01,38B
0868C:  MOVFF  03,38C
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
08690:  MOVFF  38B,FE9
08694:  MOVFF  38C,FEA
08698:  MOVF   FEF,W
0869A:  SUBLW  03
0869C:  BZ    86BC
0869E:  MOVFF  38B,FE9
086A2:  MOVFF  38C,FEA
086A6:  MOVF   FEF,W
086A8:  SUBLW  02
086AA:  BZ    86BC
....................    { 
....................       CloseSocket(ps); 
086AC:  MOVFF  38C,3CD
086B0:  MOVFF  38B,3CC
086B4:  MOVLB  0
086B6:  CALL   4876
....................       return; 
086BA:  BRA    87AE
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
086BC:  MOVFF  38A,38D
086C0:  MOVLB  0
086C2:  CALL   7700
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
086C6:  MOVLW  01
086C8:  MOVLB  3
086CA:  ADDWF  x8B,W
086CC:  MOVWF  01
086CE:  MOVLW  00
086D0:  ADDWFC x8C,W
086D2:  MOVWF  03
086D4:  MOVFF  01,38D
086D8:  MOVWF  x8E
086DA:  MOVLW  0B
086DC:  ADDWF  x8B,W
086DE:  MOVWF  FE9
086E0:  MOVLW  00
086E2:  ADDWFC x8C,W
086E4:  MOVWF  FEA
086E6:  MOVFF  FEC,390
086EA:  MOVF   FED,F
086EC:  MOVFF  FEF,38F
086F0:  MOVLW  0D
086F2:  ADDWF  x8B,W
086F4:  MOVWF  FE9
086F6:  MOVLW  00
086F8:  ADDWFC x8C,W
086FA:  MOVWF  FEA
086FC:  MOVFF  FEC,392
08700:  MOVF   FED,F
08702:  MOVFF  FEF,391
08706:  MOVLW  16
08708:  ADDWF  x8B,W
0870A:  MOVWF  FE9
0870C:  MOVLW  00
0870E:  ADDWFC x8C,W
08710:  MOVWF  FEA
08712:  MOVFF  FEF,393
08716:  MOVFF  FEC,394
0871A:  MOVFF  FEC,395
0871E:  MOVFF  FEC,396
08722:  MOVLW  1A
08724:  ADDWF  x8B,W
08726:  MOVWF  FE9
08728:  MOVLW  00
0872A:  ADDWFC x8C,W
0872C:  MOVWF  FEA
0872E:  MOVFF  FEF,397
08732:  MOVFF  FEC,398
08736:  MOVFF  FEC,399
0873A:  MOVFF  FEC,39A
0873E:  MOVFF  03,3D4
08742:  MOVFF  01,3D3
08746:  MOVFF  390,3D6
0874A:  MOVFF  38F,3D5
0874E:  MOVFF  392,3D8
08752:  MOVFF  391,3D7
08756:  MOVFF  396,3DC
0875A:  MOVFF  395,3DB
0875E:  MOVFF  394,3DA
08762:  MOVFF  393,3D9
08766:  MOVFF  39A,3E0
0876A:  MOVFF  399,3DF
0876E:  MOVFF  398,3DE
08772:  MOVFF  397,3DD
08776:  MOVLW  11
08778:  MOVWF  xE1
0877A:  MOVLW  FF
0877C:  MOVWF  xE2
0877E:  CLRF   xE4
08780:  CLRF   xE3
08782:  MOVLB  0
08784:  CALL   4CC6
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
08788:  MOVLW  16
0878A:  MOVLB  3
0878C:  ADDWF  x8B,W
0878E:  MOVWF  FE9
08790:  MOVLW  00
08792:  ADDWFC x8C,W
08794:  MOVWF  FEA
08796:  MOVLW  01
08798:  ADDWF  FEE,F
0879A:  MOVLW  00
0879C:  ADDWFC FEE,F
0879E:  ADDWFC FEE,F
087A0:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
087A2:  MOVFF  38B,FE9
087A6:  MOVFF  38C,FEA
087AA:  MOVLW  04
087AC:  MOVWF  FEF
087AE:  MOVLB  0
....................  
....................    return; 
.................... } 
087B0:  GOTO   9404 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
077F6:  MOVLB  3
077F8:  MOVF   xBF,W
077FA:  MULLW  24
077FC:  MOVF   FF3,W
077FE:  CLRF   03
07800:  ADDLW  8C
07802:  MOVWF  01
07804:  MOVLW  00
07806:  ADDWFC 03,F
07808:  MOVFF  01,3C0
0780C:  MOVFF  03,3C1
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
07810:  MOVLW  0F
07812:  ADDWF  xC0,W
07814:  MOVWF  FE9
07816:  MOVLW  00
07818:  ADDWFC xC1,W
0781A:  MOVWF  FEA
0781C:  INCFSZ FEF,W
0781E:  BRA    7826
....................       return FALSE; 
07820:  MOVLW  00
07822:  MOVWF  01
07824:  BRA    79BC
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
07826:  MOVLW  23
07828:  ADDWF  xC0,W
0782A:  MOVWF  FE9
0782C:  MOVLW  00
0782E:  ADDWFC xC1,W
07830:  MOVWF  FEA
07832:  MOVLW  00
07834:  BTFSC  FEF.1
07836:  MOVLW  01
07838:  ANDLW  01
0783A:  BNZ   7842
....................       return FALSE; 
0783C:  MOVLW  00
0783E:  MOVWF  01
07840:  BRA    79BC
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
07842:  MOVLW  01
07844:  ADDWF  xC0,W
07846:  MOVWF  01
07848:  MOVLW  00
0784A:  ADDWFC xC1,W
0784C:  MOVWF  03
0784E:  MOVFF  01,3C2
07852:  MOVWF  xC3
07854:  MOVLW  0B
07856:  ADDWF  xC0,W
07858:  MOVWF  FE9
0785A:  MOVLW  00
0785C:  ADDWFC xC1,W
0785E:  MOVWF  FEA
07860:  MOVFF  FEC,3C5
07864:  MOVF   FED,F
07866:  MOVFF  FEF,3C4
0786A:  MOVLW  0D
0786C:  ADDWF  xC0,W
0786E:  MOVWF  FE9
07870:  MOVLW  00
07872:  ADDWFC xC1,W
07874:  MOVWF  FEA
07876:  MOVFF  FEC,3C7
0787A:  MOVF   FED,F
0787C:  MOVFF  FEF,3C6
07880:  MOVLW  16
07882:  ADDWF  xC0,W
07884:  MOVWF  FE9
07886:  MOVLW  00
07888:  ADDWFC xC1,W
0788A:  MOVWF  FEA
0788C:  MOVFF  FEF,3C8
07890:  MOVFF  FEC,3C9
07894:  MOVFF  FEC,3CA
07898:  MOVFF  FEC,3CB
0789C:  MOVLW  1A
0789E:  ADDWF  xC0,W
078A0:  MOVWF  FE9
078A2:  MOVLW  00
078A4:  ADDWFC xC1,W
078A6:  MOVWF  FEA
078A8:  MOVFF  FEF,3CC
078AC:  MOVFF  FEC,3CD
078B0:  MOVFF  FEC,3CE
078B4:  MOVFF  FEC,3CF
078B8:  MOVLW  0F
078BA:  ADDWF  xC0,W
078BC:  MOVWF  FE9
078BE:  MOVLW  00
078C0:  ADDWFC xC1,W
078C2:  MOVWF  FEA
078C4:  MOVFF  FEF,3D0
078C8:  MOVLW  10
078CA:  ADDWF  xC0,W
078CC:  MOVWF  FE9
078CE:  MOVLW  00
078D0:  ADDWFC xC1,W
078D2:  MOVWF  FEA
078D4:  MOVFF  FEC,3D2
078D8:  MOVF   FED,F
078DA:  MOVFF  FEF,3D1
078DE:  MOVFF  03,3D4
078E2:  MOVFF  01,3D3
078E6:  MOVFF  3C5,3D6
078EA:  MOVFF  3C4,3D5
078EE:  MOVFF  3C7,3D8
078F2:  MOVFF  3C6,3D7
078F6:  MOVFF  3CB,3DC
078FA:  MOVFF  3CA,3DB
078FE:  MOVFF  3C9,3DA
07902:  MOVFF  3C8,3D9
07906:  MOVFF  3CF,3E0
0790A:  MOVFF  3CE,3DF
0790E:  MOVFF  3CD,3DE
07912:  MOVFF  3CC,3DD
07916:  MOVLW  18
07918:  MOVWF  xE1
0791A:  MOVFF  3D0,3E2
0791E:  MOVFF  3D2,3E4
07922:  MOVFF  3D1,3E3
07926:  MOVLB  0
07928:  CALL   4CC6
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
0792C:  MOVLW  16
0792E:  MOVLB  3
07930:  ADDWF  xC0,W
07932:  MOVWF  01
07934:  MOVLW  00
07936:  ADDWFC xC1,W
07938:  MOVWF  03
0793A:  MOVFF  01,3C2
0793E:  MOVWF  xC3
07940:  MOVWF  FEA
07942:  MOVFF  01,FE9
07946:  MOVFF  FEF,3C4
0794A:  MOVFF  FEC,3C5
0794E:  MOVFF  FEC,3C6
07952:  MOVFF  FEC,3C7
07956:  MOVLW  10
07958:  ADDWF  xC0,W
0795A:  MOVWF  FE9
0795C:  MOVLW  00
0795E:  ADDWFC xC1,W
07960:  MOVWF  FEA
07962:  MOVFF  FEC,03
07966:  MOVF   FED,F
07968:  MOVFF  FEF,00
0796C:  MOVFF  03,01
07970:  CLRF   02
07972:  CLRF   03
07974:  MOVF   xC4,W
07976:  ADDWF  00,F
07978:  MOVF   xC5,W
0797A:  ADDWFC 01,F
0797C:  MOVF   xC6,W
0797E:  ADDWFC 02,F
07980:  MOVF   xC7,W
07982:  ADDWFC 03,F
07984:  MOVFF  3C3,FEA
07988:  MOVFF  3C2,FE9
0798C:  MOVFF  00,FEF
07990:  MOVFF  01,FEC
07994:  MOVFF  02,FEC
07998:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
0799C:  MOVLW  23
0799E:  ADDWF  xC0,W
079A0:  MOVWF  FE9
079A2:  MOVLW  00
079A4:  ADDWFC xC1,W
079A6:  MOVWF  FEA
079A8:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
079AA:  MOVLW  23
079AC:  ADDWF  xC0,W
079AE:  MOVWF  FE9
079B0:  MOVLW  00
079B2:  ADDWFC xC1,W
079B4:  MOVWF  FEA
079B6:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
079B8:  MOVLW  01
079BA:  MOVWF  01
.................... } 
079BC:  MOVLB  0
079BE:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
0774E:  MOVLB  3
07750:  MOVF   xAD,W
07752:  MULLW  24
07754:  MOVF   FF3,W
07756:  CLRF   xAF
07758:  MOVWF  xAE
0775A:  MOVLW  14
0775C:  ADDWF  xAE,W
0775E:  MOVWF  01
07760:  MOVLW  00
07762:  ADDWFC xAF,W
07764:  MOVWF  03
07766:  MOVF   01,W
07768:  ADDLW  8C
0776A:  MOVWF  FE9
0776C:  MOVLW  00
0776E:  ADDWFC 03,W
07770:  MOVWF  FEA
07772:  MOVFF  FEC,3AF
07776:  MOVF   FED,F
07778:  MOVFF  FEF,3AE
0777C:  MOVF   xAE,F
0777E:  BNZ   778A
07780:  MOVF   xAF,F
07782:  BNZ   778A
....................       return FALSE; 
07784:  MOVLW  00
07786:  MOVWF  01
07788:  BRA    77EA
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0778A:  MOVF   xAD,W
0778C:  MULLW  24
0778E:  MOVF   FF3,W
07790:  CLRF   xAF
07792:  MOVWF  xAE
07794:  MOVLW  0F
07796:  ADDWF  xAE,W
07798:  MOVWF  01
0779A:  MOVLW  00
0779C:  ADDWFC xAF,W
0779E:  MOVWF  03
077A0:  MOVF   01,W
077A2:  ADDLW  8C
077A4:  MOVWF  FE9
077A6:  MOVLW  00
077A8:  ADDWFC 03,W
077AA:  MOVWF  FEA
077AC:  INCFSZ FEF,W
077AE:  BRA    77C2
....................       return IPIsTxReady(FALSE); 
077B0:  MOVLB  4
077B2:  CLRF   x0B
077B4:  MOVLB  0
077B6:  CALL   497A
077BA:  MOVF   01,W
077BC:  MOVLB  3
077BE:  BRA    77EA
....................    else 
077C0:  BRA    77EA
....................       return TCB[s].Flags.bIsPutReady; 
077C2:  MOVF   xAD,W
077C4:  MULLW  24
077C6:  MOVF   FF3,W
077C8:  CLRF   xAF
077CA:  MOVWF  xAE
077CC:  MOVLW  23
077CE:  ADDWF  xAE,F
077D0:  MOVLW  00
077D2:  ADDWFC xAF,F
077D4:  MOVLW  8C
077D6:  ADDWF  xAE,W
077D8:  MOVWF  FE9
077DA:  MOVLW  00
077DC:  ADDWFC xAF,W
077DE:  MOVWF  FEA
077E0:  MOVLW  00
077E2:  BTFSC  FEF.1
077E4:  MOVLW  01
077E6:  MOVWF  01
077E8:  BRA    77EA
.................... } 
077EA:  MOVLB  0
077EC:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
07C3A:  MOVFF  3A8,3AD
07C3E:  RCALL  774E
07C40:  MOVF   01,F
07C42:  BNZ   7C4C
....................       return(0); 
07C44:  MOVLW  00
07C46:  MOVWF  01
07C48:  MOVWF  02
07C4A:  BRA    7D32
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
07C4C:  MOVLB  3
07C4E:  MOVF   xA8,W
07C50:  MULLW  24
07C52:  MOVF   FF3,W
07C54:  CLRF   xAE
07C56:  MOVWF  xAD
07C58:  MOVLW  0F
07C5A:  ADDWF  xAD,W
07C5C:  MOVWF  01
07C5E:  MOVLW  00
07C60:  ADDWFC xAE,W
07C62:  MOVWF  03
07C64:  MOVF   01,W
07C66:  ADDLW  8C
07C68:  MOVWF  FE9
07C6A:  MOVLW  00
07C6C:  ADDWFC 03,W
07C6E:  MOVWF  FEA
07C70:  INCFSZ FEF,W
07C72:  BRA    7C7A
....................       txCount = 0; 
07C74:  CLRF   xAA
07C76:  CLRF   xA9
....................    else 
07C78:  BRA    7CAA
....................       txCount = TCB[s].TxCount; 
07C7A:  MOVF   xA8,W
07C7C:  MULLW  24
07C7E:  MOVF   FF3,W
07C80:  CLRF   xAE
07C82:  MOVWF  xAD
07C84:  MOVLW  10
07C86:  ADDWF  xAD,W
07C88:  MOVWF  01
07C8A:  MOVLW  00
07C8C:  ADDWFC xAE,W
07C8E:  MOVWF  03
07C90:  MOVF   01,W
07C92:  ADDLW  8C
07C94:  MOVWF  FE9
07C96:  MOVLW  00
07C98:  ADDWFC 03,W
07C9A:  MOVWF  FEA
07C9C:  MOVFF  FEC,03
07CA0:  MOVF   FED,F
07CA2:  MOVFF  FEF,3A9
07CA6:  MOVFF  03,3AA
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
07CAA:  MOVLW  CA
07CAC:  BSF    FD8.0
07CAE:  SUBFWB xA9,W
07CB0:  MOVWF  xAB
07CB2:  MOVLW  03
07CB4:  SUBFWB xAA,W
07CB6:  MOVWF  xAC
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
07CB8:  MOVF   xA8,W
07CBA:  MULLW  24
07CBC:  MOVF   FF3,W
07CBE:  CLRF   xAE
07CC0:  MOVWF  xAD
07CC2:  MOVLW  14
07CC4:  ADDWF  xAD,W
07CC6:  MOVWF  01
07CC8:  MOVLW  00
07CCA:  ADDWFC xAE,W
07CCC:  MOVWF  03
07CCE:  MOVF   01,W
07CD0:  ADDLW  8C
07CD2:  MOVWF  FE9
07CD4:  MOVLW  00
07CD6:  ADDWFC 03,W
07CD8:  MOVWF  FEA
07CDA:  MOVFF  FEC,03
07CDE:  MOVF   FED,F
07CE0:  MOVFF  FEF,01
07CE4:  MOVF   03,W
07CE6:  SUBWF  xAC,W
07CE8:  BNC   7D1E
07CEA:  BNZ   7CF2
07CEC:  MOVF   xAB,W
07CEE:  SUBWF  01,W
07CF0:  BC    7D1E
07CF2:  MOVF   xA8,W
07CF4:  MULLW  24
07CF6:  MOVF   FF3,W
07CF8:  CLRF   xAE
07CFA:  MOVWF  xAD
07CFC:  MOVLW  14
07CFE:  ADDWF  xAD,W
07D00:  MOVWF  01
07D02:  MOVLW  00
07D04:  ADDWFC xAE,W
07D06:  MOVWF  03
07D08:  MOVF   01,W
07D0A:  ADDLW  8C
07D0C:  MOVWF  FE9
07D0E:  MOVLW  00
07D10:  ADDWFC 03,W
07D12:  MOVWF  FEA
07D14:  MOVFF  FEC,03
07D18:  MOVF   FED,F
07D1A:  MOVF   FEF,W
07D1C:  BRA    7D24
07D1E:  MOVFF  3AC,03
07D22:  MOVF   xAB,W
07D24:  MOVWF  xAB
07D26:  MOVFF  03,3AC
....................  
....................    return(txAvail); 
07D2A:  MOVFF  3AB,01
07D2E:  MOVFF  3AC,02
07D32:  MOVLB  0
.................... } 
07D34:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................     
....................    len = n < len ? n : len; 
....................    n = len; 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) 
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(len); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
079C0:  MOVLB  3
079C2:  MOVF   xB9,W
079C4:  MULLW  24
079C6:  MOVF   FF3,W
079C8:  CLRF   03
079CA:  ADDLW  8C
079CC:  MOVWF  01
079CE:  MOVLW  00
079D0:  ADDWFC 03,F
079D2:  MOVFF  01,3BB
079D6:  MOVFF  03,3BC
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
079DA:  MOVLW  14
079DC:  ADDWF  xBB,W
079DE:  MOVWF  FE9
079E0:  MOVLW  00
079E2:  ADDWFC xBC,W
079E4:  MOVWF  FEA
079E6:  MOVFF  FEC,3C0
079EA:  MOVF   FED,F
079EC:  MOVFF  FEF,3BF
079F0:  MOVF   xBF,F
079F2:  BNZ   79FE
079F4:  MOVF   xC0,F
079F6:  BNZ   79FE
....................       return FALSE; 
079F8:  MOVLW  00
079FA:  MOVWF  01
079FC:  BRA    7B08
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
079FE:  MOVLW  0F
07A00:  ADDWF  xBB,W
07A02:  MOVWF  FE9
07A04:  MOVLW  00
07A06:  ADDWFC xBC,W
07A08:  MOVWF  FEA
07A0A:  INCFSZ FEF,W
07A0C:  BRA    7A84
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
07A0E:  MOVLW  0F
07A10:  ADDWF  xBB,W
07A12:  MOVWF  01
07A14:  MOVLW  00
07A16:  ADDWFC xBC,W
07A18:  MOVWF  03
07A1A:  MOVFF  01,3BF
07A1E:  MOVWF  xC0
07A20:  MOVLB  4
07A22:  CLRF   x0B
07A24:  MOVLB  0
07A26:  CALL   344A
07A2A:  MOVFF  3C0,FEA
07A2E:  MOVFF  3BF,FE9
07A32:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
07A36:  MOVLW  0F
07A38:  MOVLB  3
07A3A:  ADDWF  xBB,W
07A3C:  MOVWF  FE9
07A3E:  MOVLW  00
07A40:  ADDWFC xBC,W
07A42:  MOVWF  FEA
07A44:  INCFSZ FEF,W
07A46:  BRA    7A4E
....................          return FALSE; 
07A48:  MOVLW  00
07A4A:  MOVWF  01
07A4C:  BRA    7B08
....................  
....................       ps->TxCount = 0; 
07A4E:  MOVLW  10
07A50:  ADDWF  xBB,W
07A52:  MOVWF  FE9
07A54:  MOVLW  00
07A56:  ADDWFC xBC,W
07A58:  MOVWF  FEA
07A5A:  CLRF   FEC
07A5C:  MOVF   FED,F
07A5E:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
07A60:  MOVLW  0F
07A62:  ADDWF  xBB,W
07A64:  MOVWF  FE9
07A66:  MOVLW  00
07A68:  ADDWFC xBC,W
07A6A:  MOVWF  FEA
07A6C:  MOVFF  FEF,3BF
07A70:  MOVFF  3BF,424
07A74:  MOVLB  4
07A76:  CLRF   x26
07A78:  MOVLW  28
07A7A:  MOVWF  x25
07A7C:  MOVLB  0
07A7E:  CALL   3474
07A82:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
07A84:  MOVLW  23
07A86:  ADDWF  xBB,W
07A88:  MOVWF  FE9
07A8A:  MOVLW  00
07A8C:  ADDWFC xBC,W
07A8E:  MOVWF  FEA
07A90:  BSF    FEF.4
....................  
....................    MACPut(byte); 
07A92:  MOVFF  3BA,42E
07A96:  MOVLB  0
07A98:  CALL   351E
....................    ps->RemoteWindow--; 
07A9C:  MOVLW  14
07A9E:  MOVLB  3
07AA0:  ADDWF  xBB,W
07AA2:  MOVWF  FE9
07AA4:  MOVLW  00
07AA6:  ADDWFC xBC,W
07AA8:  MOVWF  FEA
07AAA:  MOVLW  FF
07AAC:  ADDWF  FEF,F
07AAE:  BC    7AB4
07AB0:  MOVF   FEE,F
07AB2:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
07AB4:  MOVLW  10
07AB6:  ADDWF  xBB,W
07AB8:  MOVWF  FE9
07ABA:  MOVLW  00
07ABC:  ADDWFC xBC,W
07ABE:  MOVWF  FEA
07AC0:  MOVFF  FEC,03
07AC4:  MOVF   FED,F
07AC6:  MOVFF  FEF,3BD
07ACA:  MOVFF  03,3BE
....................    tempCount++; 
07ACE:  INCF   xBD,F
07AD0:  BTFSC  FD8.2
07AD2:  INCF   xBE,F
....................    ps->TxCount = tempCount; 
07AD4:  MOVLW  10
07AD6:  ADDWF  xBB,W
07AD8:  MOVWF  FE9
07ADA:  MOVLW  00
07ADC:  ADDWFC xBC,W
07ADE:  MOVWF  FEA
07AE0:  MOVFF  3BE,FEC
07AE4:  MOVF   FED,F
07AE6:  MOVFF  3BD,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
07AEA:  MOVF   xBE,W
07AEC:  SUBLW  02
07AEE:  BC    7B04
07AF0:  XORLW  FF
07AF2:  BNZ   7AFA
07AF4:  MOVF   xBD,W
07AF6:  SUBLW  C9
07AF8:  BC    7B04
....................       TCPFlush(s); 
07AFA:  MOVFF  3B9,3BF
07AFE:  MOVLB  0
07B00:  RCALL  77F6
07B02:  MOVLB  3
....................  
....................    return TRUE; 
07B04:  MOVLW  01
07B06:  MOVWF  01
.................... } 
07B08:  MOVLB  0
07B0A:  GOTO   7B18 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
07700:  MOVLB  3
07702:  MOVF   x8D,W
07704:  MULLW  24
07706:  MOVF   FF3,W
07708:  CLRF   03
0770A:  ADDLW  8C
0770C:  MOVWF  01
0770E:  MOVLW  00
07710:  ADDWFC 03,F
07712:  MOVFF  01,38E
07716:  MOVFF  03,38F
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
0771A:  MOVLW  23
0771C:  ADDWF  x8E,W
0771E:  MOVWF  FE9
07720:  MOVLW  00
07722:  ADDWFC x8F,W
07724:  MOVWF  FEA
07726:  BTFSC  FEF.3
07728:  BRA    7730
....................         return FALSE; 
0772A:  MOVLW  00
0772C:  MOVWF  01
0772E:  BRA    774A
....................  
....................     MACDiscardRx(); 
07730:  MOVLB  0
07732:  CALL   3070
....................     ps->Flags.bIsGetReady = FALSE; 
07736:  MOVLW  23
07738:  MOVLB  3
0773A:  ADDWF  x8E,W
0773C:  MOVWF  FE9
0773E:  MOVLW  00
07740:  ADDWFC x8F,W
07742:  MOVWF  FEA
07744:  BCF    FEF.3
....................  
....................     return TRUE; 
07746:  MOVLW  01
07748:  MOVWF  01
.................... } 
0774A:  MOVLB  0
0774C:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
068A6:  MOVLB  3
068A8:  MOVF   x8A,W
068AA:  MULLW  24
068AC:  MOVF   FF3,W
068AE:  CLRF   03
068B0:  ADDLW  8C
068B2:  MOVWF  01
068B4:  MOVLW  00
068B6:  ADDWFC 03,F
068B8:  MOVFF  01,38D
068BC:  MOVFF  03,38E
....................  
....................     if ( ps->Flags.bIsGetReady ) 
068C0:  MOVLW  23
068C2:  ADDWF  x8D,W
068C4:  MOVWF  FE9
068C6:  MOVLW  00
068C8:  ADDWFC x8E,W
068CA:  MOVWF  FEA
068CC:  BTFSS  FEF.3
068CE:  BRA    6972
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
068D0:  MOVLW  23
068D2:  ADDWF  x8D,W
068D4:  MOVWF  FE9
068D6:  MOVLW  00
068D8:  ADDWFC x8E,W
068DA:  MOVWF  FEA
068DC:  BTFSS  FEF.2
068DE:  BRA    68FC
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
068E0:  CLRF   xB0
068E2:  MOVLW  14
068E4:  MOVWF  xAF
068E6:  MOVLB  0
068E8:  CALL   3EEA
....................  
....................             ps->Flags.bFirstRead = FALSE; 
068EC:  MOVLW  23
068EE:  MOVLB  3
068F0:  ADDWF  x8D,W
068F2:  MOVWF  FE9
068F4:  MOVLW  00
068F6:  ADDWFC x8E,W
068F8:  MOVWF  FEA
068FA:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
068FC:  MOVLW  12
068FE:  ADDWF  x8D,W
06900:  MOVWF  FE9
06902:  MOVLW  00
06904:  ADDWFC x8E,W
06906:  MOVWF  FEA
06908:  MOVFF  FEC,390
0690C:  MOVF   FED,F
0690E:  MOVFF  FEF,38F
06912:  MOVF   x8F,F
06914:  BNZ   6936
06916:  MOVF   x90,F
06918:  BNZ   6936
....................         { 
....................             MACDiscardRx(); 
0691A:  MOVLB  0
0691C:  CALL   3070
....................             ps->Flags.bIsGetReady = FALSE; 
06920:  MOVLW  23
06922:  MOVLB  3
06924:  ADDWF  x8D,W
06926:  MOVWF  FE9
06928:  MOVLW  00
0692A:  ADDWFC x8E,W
0692C:  MOVWF  FEA
0692E:  BCF    FEF.3
....................             return FALSE; 
06930:  MOVLW  00
06932:  MOVWF  01
06934:  BRA    6976
....................         } 
....................  
....................          ps->RxCount--; 
06936:  MOVLW  12
06938:  ADDWF  x8D,W
0693A:  MOVWF  FE9
0693C:  MOVLW  00
0693E:  ADDWFC x8E,W
06940:  MOVWF  FEA
06942:  MOVLW  FF
06944:  ADDWF  FEF,F
06946:  BC    694C
06948:  MOVF   FEE,F
0694A:  DECF   FED,F
....................          *data = MACGet(); 
0694C:  MOVFF  38C,03
06950:  MOVFF  38B,38F
06954:  MOVFF  38C,390
06958:  MOVLB  0
0695A:  CALL   3F04
0695E:  MOVFF  390,FEA
06962:  MOVFF  38F,FE9
06966:  MOVFF  01,FEF
....................         return TRUE; 
0696A:  MOVLW  01
0696C:  MOVWF  01
0696E:  MOVLB  3
06970:  BRA    6976
....................     } 
....................     return FALSE; 
06972:  MOVLW  00
06974:  MOVWF  01
.................... } 
06976:  MOVLB  0
06978:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
0687A:  MOVLB  3
0687C:  MOVF   x8A,W
0687E:  MULLW  24
06880:  MOVF   FF3,W
06882:  CLRF   x8C
06884:  MOVWF  x8B
06886:  MOVLW  23
06888:  ADDWF  x8B,F
0688A:  MOVLW  00
0688C:  ADDWFC x8C,F
0688E:  MOVLW  8C
06890:  ADDWF  x8B,W
06892:  MOVWF  FE9
06894:  MOVLW  00
06896:  ADDWFC x8C,W
06898:  MOVWF  FEA
0689A:  MOVLW  00
0689C:  BTFSC  FEF.3
0689E:  MOVLW  01
068A0:  MOVWF  01
.................... } 
068A2:  MOVLB  0
068A4:  RETLW  00
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
06378:  MOVLB  3
0637A:  CLRF   x8D
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0637C:  CLRF   x82
0637E:  MOVF   x82,W
06380:  SUBLW  04
06382:  BTFSS  FD8.0
06384:  BRA    6814
....................    { 
....................       ps = &TCB[s]; 
06386:  MOVF   x82,W
06388:  MULLW  24
0638A:  MOVF   FF3,W
0638C:  CLRF   03
0638E:  ADDLW  8C
06390:  MOVWF  01
06392:  MOVLW  00
06394:  ADDWFC 03,F
06396:  MOVFF  01,387
0639A:  MOVFF  03,388
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
0639E:  MOVLW  23
063A0:  ADDWF  x87,W
063A2:  MOVWF  FE9
063A4:  MOVLW  00
063A6:  ADDWFC x88,W
063A8:  MOVWF  FEA
063AA:  BTFSC  FEF.3
063AC:  BRA    63BE
063AE:  MOVLW  23
063B0:  ADDWF  x87,W
063B2:  MOVWF  FE9
063B4:  MOVLW  00
063B6:  ADDWFC x88,W
063B8:  MOVWF  FEA
063BA:  BTFSS  FEF.4
063BC:  BRA    63C0
....................          continue; 
063BE:  BRA    6810
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
063C0:  MOVFF  387,FE9
063C4:  MOVFF  388,FEA
063C8:  MOVF   FEF,W
063CA:  SUBLW  0A
063CC:  BZ    63F2
063CE:  MOVFF  387,FE9
063D2:  MOVFF  388,FEA
063D6:  MOVF   FEF,F
063D8:  BNZ   63F4
063DA:  MOVLW  23
063DC:  ADDWF  x87,W
063DE:  MOVWF  FE9
063E0:  MOVLW  00
063E2:  ADDWFC x88,W
063E4:  MOVWF  FEA
063E6:  MOVLW  00
063E8:  BTFSC  FEF.0
063EA:  MOVLW  01
063EC:  ANDLW  01
063EE:  SUBLW  01
063F0:  BNZ   63F4
....................          continue; 
063F2:  BRA    6810
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
063F4:  MOVFF  387,FE9
063F8:  MOVFF  388,FEA
063FC:  MOVF   FEF,W
063FE:  SUBLW  03
06400:  BNZ   641C
06402:  MOVLW  23
06404:  ADDWF  x87,W
06406:  MOVWF  FE9
06408:  MOVLW  00
0640A:  ADDWFC x88,W
0640C:  MOVWF  FEA
0640E:  MOVLW  00
06410:  BTFSC  FEF.0
06412:  MOVLW  01
06414:  ANDLW  01
06416:  SUBLW  01
06418:  BNZ   641C
....................          continue; 
0641A:  BRA    6810
....................  
....................  
....................       tick = TickGet(); 
0641C:  MOVLB  0
0641E:  CALL   485C
06422:  MOVFF  02,386
06426:  MOVFF  01,385
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
0642A:  MOVLW  1F
0642C:  MOVLB  3
0642E:  ADDWF  x87,W
06430:  MOVWF  FE9
06432:  MOVLW  00
06434:  ADDWFC x88,W
06436:  MOVWF  FEA
06438:  MOVFF  FEC,03
0643C:  MOVF   FED,F
0643E:  MOVFF  FEF,01
06442:  MOVF   x86,W
06444:  SUBWF  03,W
06446:  BNC   6450
06448:  BNZ   6454
0644A:  MOVF   01,W
0644C:  SUBWF  x85,W
0644E:  BNC   6454
06450:  MOVLW  00
06452:  BRA    6456
06454:  MOVLW  01
06456:  CLRF   03
06458:  IORWF  03,W
0645A:  BZ    6492
0645C:  MOVLW  1F
0645E:  ADDWF  x87,W
06460:  MOVWF  FE9
06462:  MOVLW  00
06464:  ADDWFC x88,W
06466:  MOVWF  FEA
06468:  MOVFF  FEC,03
0646C:  MOVF   FED,F
0646E:  MOVF   FEF,W
06470:  SUBLW  FF
06472:  MOVWF  x8E
06474:  MOVLW  FF
06476:  SUBFWB 03,W
06478:  MOVWF  x8F
0647A:  MOVF   x85,W
0647C:  ADDWF  x8E,F
0647E:  MOVF   x86,W
06480:  ADDWFC x8F,F
06482:  MOVLW  01
06484:  ADDWF  x8E,W
06486:  MOVWF  01
06488:  MOVLW  00
0648A:  ADDWFC x8F,W
0648C:  MOVWF  03
0648E:  MOVF   01,W
06490:  BRA    64B2
06492:  MOVLW  1F
06494:  ADDWF  x87,W
06496:  MOVWF  FE9
06498:  MOVLW  00
0649A:  ADDWFC x88,W
0649C:  MOVWF  FEA
0649E:  MOVFF  FEC,03
064A2:  MOVF   FED,F
064A4:  MOVF   FEF,W
064A6:  SUBWF  x85,W
064A8:  MOVWF  00
064AA:  MOVF   03,W
064AC:  SUBWFB x86,W
064AE:  MOVWF  03
064B0:  MOVF   00,W
064B2:  MOVWF  x83
064B4:  MOVFF  03,384
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
064B8:  MOVLW  21
064BA:  ADDWF  x87,W
064BC:  MOVWF  FE9
064BE:  MOVLW  00
064C0:  ADDWFC x88,W
064C2:  MOVWF  FEA
064C4:  MOVFF  FEC,03
064C8:  MOVF   FED,F
064CA:  MOVFF  FEF,01
064CE:  MOVF   x84,W
064D0:  SUBWF  03,W
064D2:  BNC   64DE
064D4:  BNZ   64DC
064D6:  MOVF   x83,W
064D8:  SUBWF  01,W
064DA:  BNC   64DE
....................          continue; 
064DC:  BRA    6810
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
064DE:  MOVLW  01
064E0:  MOVLB  4
064E2:  MOVWF  x0B
064E4:  MOVLB  0
064E6:  CALL   497A
064EA:  MOVF   01,F
064EC:  BNZ   64F0
....................          return; 
064EE:  BRA    6814
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
064F0:  MOVLW  1F
064F2:  MOVLB  3
064F4:  ADDWF  x87,W
064F6:  MOVWF  01
064F8:  MOVLW  00
064FA:  ADDWFC x88,W
064FC:  MOVWF  03
064FE:  MOVFF  01,38E
06502:  MOVWF  x8F
06504:  MOVLB  0
06506:  CALL   485C
0650A:  MOVFF  38F,FEA
0650E:  MOVFF  38E,FE9
06512:  MOVFF  02,FEC
06516:  MOVF   FED,F
06518:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
0651C:  MOVLW  21
0651E:  MOVLB  3
06520:  ADDWF  x87,W
06522:  MOVWF  FE9
06524:  MOVLW  00
06526:  ADDWFC x88,W
06528:  MOVWF  FEA
0652A:  BCF    FD8.0
0652C:  RLCF   FEF,W
0652E:  MOVWF  02
06530:  RLCF   FEC,W
06532:  MOVWF  03
06534:  MOVF   02,W
06536:  MOVF   FED,F
06538:  MOVWF  FEF
0653A:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
0653E:  MOVLW  1E
06540:  ADDWF  x87,W
06542:  MOVWF  FE9
06544:  MOVLW  00
06546:  ADDWFC x88,W
06548:  MOVWF  FEA
0654A:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
0654C:  MOVFF  387,FE9
06550:  MOVFF  388,FEA
06554:  MOVLW  01
06556:  SUBWF  FEF,W
06558:  ADDLW  F7
0655A:  BTFSC  FD8.0
0655C:  BRA    66EE
0655E:  ADDLW  09
06560:  MOVLB  0
06562:  GOTO   681A
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
06566:  MOVLW  02
06568:  MOVLB  3
0656A:  MOVWF  x8D
....................          break; 
0656C:  BRA    66EE
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0656E:  MOVLW  1E
06570:  MOVLB  3
06572:  ADDWF  x87,W
06574:  MOVWF  FE9
06576:  MOVLW  00
06578:  ADDWFC x88,W
0657A:  MOVWF  FEA
0657C:  MOVF   FEF,W
0657E:  SUBLW  03
06580:  BNC   6588
....................          { 
....................             flags = SYN | ACK; 
06582:  MOVLW  12
06584:  MOVWF  x8D
....................          } 
....................          else 
06586:  BRA    65B4
....................          { 
....................             if(ps->Flags.bServer) 
06588:  MOVLW  23
0658A:  ADDWF  x87,W
0658C:  MOVWF  FE9
0658E:  MOVLW  00
06590:  ADDWFC x88,W
06592:  MOVWF  FEA
06594:  BTFSS  FEF.0
06596:  BRA    65A4
....................             { 
....................                ps->smState = TCP_LISTEN; 
06598:  MOVFF  387,FE9
0659C:  MOVFF  388,FEA
065A0:  CLRF   FEF
....................             } 
....................             else 
065A2:  BRA    65B4
....................             { 
....................                flags = SYN; 
065A4:  MOVLW  02
065A6:  MOVWF  x8D
....................                ps->smState = TCP_SYN_SENT; 
065A8:  MOVFF  387,FE9
065AC:  MOVFF  388,FEA
065B0:  MOVLW  01
065B2:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
065B4:  BRA    66EE
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
065B6:  MOVLW  1E
065B8:  MOVLB  3
065BA:  ADDWF  x87,W
065BC:  MOVWF  FE9
065BE:  MOVLW  00
065C0:  ADDWFC x88,W
065C2:  MOVWF  FEA
065C4:  MOVF   FEF,W
065C6:  SUBLW  03
065C8:  BNC   660E
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
065CA:  MOVLW  0F
065CC:  ADDWF  x87,W
065CE:  MOVWF  FE9
065D0:  MOVLW  00
065D2:  ADDWFC x88,W
065D4:  MOVWF  FEA
065D6:  INCFSZ FEF,W
065D8:  BRA    65DC
065DA:  BRA    6604
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
065DC:  MOVLW  0F
065DE:  ADDWF  x87,W
065E0:  MOVWF  FE9
065E2:  MOVLW  00
065E4:  ADDWFC x88,W
065E6:  MOVWF  FEA
065E8:  MOVFF  FEF,38E
065EC:  MOVFF  38E,424
065F0:  MOVLB  4
065F2:  CLRF   x26
065F4:  CLRF   x25
065F6:  MOVLB  0
065F8:  CALL   3474
....................                MACFlush(); 
065FC:  CALL   3658
....................             } 
....................             else 
06600:  BRA    660A
06602:  MOVLB  3
....................                flags = ACK; 
06604:  MOVLW  10
06606:  MOVWF  x8D
06608:  MOVLB  0
....................          } 
....................          else 
0660A:  BRA    665C
0660C:  MOVLB  3
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
0660E:  MOVLW  0F
06610:  ADDWF  x87,W
06612:  MOVWF  FE9
06614:  MOVLW  00
06616:  ADDWFC x88,W
06618:  MOVWF  FEA
0661A:  INCFSZ FEF,W
0661C:  BRA    6620
0661E:  BRA    664C
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
06620:  MOVLW  0F
06622:  ADDWF  x87,W
06624:  MOVWF  FE9
06626:  MOVLW  00
06628:  ADDWFC x88,W
0662A:  MOVWF  FEA
0662C:  MOVFF  FEF,38E
06630:  MOVFF  38E,3CF
06634:  MOVLB  0
06636:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
0663A:  MOVLW  0F
0663C:  MOVLB  3
0663E:  ADDWF  x87,W
06640:  MOVWF  FE9
06642:  MOVLW  00
06644:  ADDWFC x88,W
06646:  MOVWF  FEA
06648:  MOVLW  FF
0664A:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
0664C:  MOVLW  11
0664E:  MOVWF  x8D
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
06650:  MOVFF  387,FE9
06654:  MOVFF  388,FEA
06658:  MOVLW  04
0665A:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
0665C:  MOVLB  3
0665E:  BRA    66EE
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
06660:  MOVLW  1E
06662:  MOVLB  3
06664:  ADDWF  x87,W
06666:  MOVWF  FE9
06668:  MOVLW  00
0666A:  ADDWFC x88,W
0666C:  MOVWF  FEA
0666E:  MOVF   FEF,W
06670:  SUBLW  03
06672:  BNC   667A
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
06674:  MOVLW  01
06676:  MOVWF  x8D
....................          } 
....................          else 
06678:  BRA    668A
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
0667A:  MOVFF  388,3CD
0667E:  MOVFF  387,3CC
06682:  MOVLB  0
06684:  CALL   4876
06688:  MOVLB  3
....................          } 
....................          break; 
0668A:  BRA    66EE
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
0668C:  MOVFF  388,3CD
06690:  MOVFF  387,3CC
06694:  CALL   4876
....................          break; 
06698:  MOVLB  3
0669A:  BRA    66EE
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
0669C:  MOVFF  388,3CD
066A0:  MOVFF  387,3CC
066A4:  CALL   4876
....................          break; 
066A8:  MOVLB  3
066AA:  BRA    66EE
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
066AC:  MOVLW  01
066AE:  MOVLB  3
066B0:  MOVWF  x8D
....................          ps->smState = TCP_LAST_ACK; 
066B2:  MOVFF  387,FE9
066B6:  MOVFF  388,FEA
066BA:  MOVLW  09
066BC:  MOVWF  FEF
....................          break; 
066BE:  BRA    66EE
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
066C0:  MOVLW  1E
066C2:  MOVLB  3
066C4:  ADDWF  x87,W
066C6:  MOVWF  FE9
066C8:  MOVLW  00
066CA:  ADDWFC x88,W
066CC:  MOVWF  FEA
066CE:  MOVF   FEF,W
066D0:  SUBLW  03
066D2:  BNC   66DA
....................             flags = FIN; 
066D4:  MOVLW  01
066D6:  MOVWF  x8D
....................          else 
066D8:  BRA    66EA
....................             CloseSocket(ps); 
066DA:  MOVFF  388,3CD
066DE:  MOVFF  387,3CC
066E2:  MOVLB  0
066E4:  CALL   4876
066E8:  MOVLB  3
....................          break; 
066EA:  BRA    66EE
066EC:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
066EE:  MOVF   x8D,F
066F0:  BTFSC  FD8.2
066F2:  BRA    6810
....................       { 
....................          if(flags & ACK) 
066F4:  BTFSS  x8D.4
066F6:  BRA    6726
....................             seq = ps->SND_SEQ; 
066F8:  MOVLW  16
066FA:  ADDWF  x87,W
066FC:  MOVWF  FE9
066FE:  MOVLW  00
06700:  ADDWFC x88,W
06702:  MOVWF  FEA
06704:  MOVFF  FEF,00
06708:  MOVFF  FEC,01
0670C:  MOVFF  FEC,02
06710:  MOVFF  FEC,03
06714:  MOVFF  03,38C
06718:  MOVFF  02,38B
0671C:  MOVFF  01,38A
06720:  MOVFF  00,389
....................          else 
06724:  BRA    676A
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
06726:  MOVLW  16
06728:  ADDWF  x87,W
0672A:  MOVWF  FE9
0672C:  MOVLW  00
0672E:  ADDWFC x88,W
06730:  MOVWF  FEA
06732:  MOVFF  FEF,00
06736:  MOVFF  FEC,01
0673A:  MOVFF  FEC,02
0673E:  MOVFF  FEC,03
06742:  MOVFF  03,38C
06746:  MOVFF  02,38B
0674A:  MOVFF  01,38A
0674E:  MOVFF  00,389
....................             ps->SND_SEQ++; 
06752:  MOVLW  16
06754:  ADDWF  x87,W
06756:  MOVWF  FE9
06758:  MOVLW  00
0675A:  ADDWFC x88,W
0675C:  MOVWF  FEA
0675E:  MOVLW  01
06760:  ADDWF  FEE,F
06762:  MOVLW  00
06764:  ADDWFC FEE,F
06766:  ADDWFC FEE,F
06768:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
0676A:  MOVLW  01
0676C:  ADDWF  x87,W
0676E:  MOVWF  01
06770:  MOVLW  00
06772:  ADDWFC x88,W
06774:  MOVWF  03
06776:  MOVFF  01,38E
0677A:  MOVWF  x8F
0677C:  MOVLW  0B
0677E:  ADDWF  x87,W
06780:  MOVWF  FE9
06782:  MOVLW  00
06784:  ADDWFC x88,W
06786:  MOVWF  FEA
06788:  MOVFF  FEC,391
0678C:  MOVF   FED,F
0678E:  MOVFF  FEF,390
06792:  MOVLW  0D
06794:  ADDWF  x87,W
06796:  MOVWF  FE9
06798:  MOVLW  00
0679A:  ADDWFC x88,W
0679C:  MOVWF  FEA
0679E:  MOVFF  FEC,393
067A2:  MOVF   FED,F
067A4:  MOVFF  FEF,392
067A8:  MOVLW  1A
067AA:  ADDWF  x87,W
067AC:  MOVWF  FE9
067AE:  MOVLW  00
067B0:  ADDWFC x88,W
067B2:  MOVWF  FEA
067B4:  MOVFF  FEF,394
067B8:  MOVFF  FEC,395
067BC:  MOVFF  FEC,396
067C0:  MOVFF  FEC,397
067C4:  MOVFF  03,3D4
067C8:  MOVFF  01,3D3
067CC:  MOVFF  391,3D6
067D0:  MOVFF  390,3D5
067D4:  MOVFF  393,3D8
067D8:  MOVFF  392,3D7
067DC:  MOVFF  38C,3DC
067E0:  MOVFF  38B,3DB
067E4:  MOVFF  38A,3DA
067E8:  MOVFF  389,3D9
067EC:  MOVFF  397,3E0
067F0:  MOVFF  396,3DF
067F4:  MOVFF  395,3DE
067F8:  MOVFF  394,3DD
067FC:  MOVFF  38D,3E1
06800:  MOVLW  FF
06802:  MOVWF  xE2
06804:  CLRF   xE4
06806:  CLRF   xE3
06808:  MOVLB  0
0680A:  CALL   4CC6
0680E:  MOVLB  3
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
06810:  INCF   x82,F
06812:  BRA    637E
06814:  MOVLB  0
.................... } 
06816:  GOTO   A336 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
059DE:  MOVLW  06
059E0:  MOVLB  3
059E2:  ADDWF  x82,W
059E4:  MOVWF  FE9
059E6:  MOVLW  00
059E8:  ADDWFC x83,W
059EA:  MOVWF  FEA
059EC:  MOVFF  FEF,00
059F0:  MOVFF  FEC,01
059F4:  MOVFF  FEC,02
059F8:  MOVFF  FEC,03
059FC:  MOVFF  03,39F
05A00:  MOVFF  02,39E
05A04:  MOVFF  01,39D
05A08:  MOVFF  00,39C
....................    pseudoHeader.DestAddress        = *localIP; 
05A0C:  MOVFF  384,FE9
05A10:  MOVFF  385,FEA
05A14:  MOVFF  FEF,00
05A18:  MOVFF  FEC,01
05A1C:  MOVFF  FEC,02
05A20:  MOVFF  FEC,03
05A24:  MOVFF  03,3A3
05A28:  MOVFF  02,3A2
05A2C:  MOVFF  01,3A1
05A30:  MOVFF  00,3A0
....................    pseudoHeader.Zero               = 0x0; 
05A34:  CLRF   xA4
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
05A36:  MOVLW  06
05A38:  MOVWF  xA5
....................    pseudoHeader.TCPLength          = len; 
05A3A:  MOVFF  387,3A7
05A3E:  MOVFF  386,3A6
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
05A42:  MOVFF  3A7,42B
05A46:  MOVFF  3A6,42A
05A4A:  MOVLB  0
05A4C:  CALL   3142
05A50:  MOVFF  02,3A7
05A54:  MOVFF  01,3A6
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
05A58:  MOVLW  03
05A5A:  MOVLB  3
05A5C:  MOVWF  xAF
05A5E:  MOVLW  9C
05A60:  MOVFF  3AF,40E
05A64:  MOVFF  FE8,40D
05A68:  MOVLB  4
05A6A:  CLRF   x10
05A6C:  MOVLW  0C
05A6E:  MOVWF  x0F
05A70:  MOVLB  0
05A72:  CALL   3DFC
05A76:  MOVFF  01,3A9
05A7A:  MOVLB  3
05A7C:  COMF   xA9,F
05A7E:  MOVFF  02,3AA
05A82:  COMF   xAA,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
05A84:  MOVFF  387,40C
05A88:  MOVFF  386,40B
05A8C:  MOVLB  0
05A8E:  CALL   3F30
05A92:  MOVFF  02,3AC
05A96:  MOVFF  01,3AB
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
05A9A:  MOVLB  3
05A9C:  MOVF   xAC,W
05A9E:  SUBWF  xA9,W
05AA0:  BNZ   5AA8
05AA2:  MOVF   xAB,W
05AA4:  SUBWF  xAA,W
05AA6:  BZ    5AB6
....................    { 
....................       MACDiscardRx(); 
05AA8:  MOVLB  0
05AAA:  CALL   3070
....................       return TRUE; 
05AAE:  MOVLW  01
05AB0:  MOVWF  01
05AB2:  BRA    5B8E
05AB4:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
05AB6:  CLRF   xB0
05AB8:  CLRF   xAF
05ABA:  MOVLB  0
05ABC:  CALL   3EEA
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
05AC0:  MOVLW  03
05AC2:  MOVLB  3
05AC4:  MOVWF  xAF
05AC6:  MOVLW  88
05AC8:  MOVFF  3AF,41A
05ACC:  MOVFF  FE8,419
05AD0:  MOVLB  4
05AD2:  CLRF   x1C
05AD4:  MOVLW  14
05AD6:  MOVWF  x1B
05AD8:  MOVLB  0
05ADA:  CALL   30DE
....................    SwapTCPHeader(&TCPHeader); 
05ADE:  MOVLW  03
05AE0:  MOVLB  4
05AE2:  MOVWF  x0C
05AE4:  MOVLW  88
05AE6:  MOVWF  x0B
05AE8:  MOVLB  0
05AEA:  CALL   4458
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
05AEE:  MOVLB  3
05AF0:  SWAPF  x94,W
05AF2:  ANDLW  0F
05AF4:  MOVWF  00
05AF6:  RLCF   00,W
05AF8:  MOVWF  xAE
05AFA:  RLCF   xAE,F
05AFC:  MOVLW  FC
05AFE:  ANDWF  xAE,F
05B00:  MOVLW  14
05B02:  SUBWF  xAE,W
05B04:  MOVWF  xAD
....................    len = len - optionsSize - sizeof(TCPHeader); 
05B06:  MOVF   xAD,W
05B08:  SUBWF  x86,W
05B0A:  MOVWF  xAE
05B0C:  MOVLW  00
05B0E:  SUBWFB x87,W
05B10:  MOVWF  xAF
05B12:  MOVLW  14
05B14:  SUBWF  xAE,W
05B16:  MOVWF  x86
05B18:  MOVLW  00
05B1A:  SUBWFB xAF,W
05B1C:  MOVWF  x87
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
05B1E:  SWAPF  x94,W
05B20:  ANDLW  0F
05B22:  MOVWF  00
05B24:  RLCF   00,W
05B26:  MOVWF  xAE
05B28:  RLCF   xAE,F
05B2A:  MOVLW  FC
05B2C:  ANDWF  xAE,F
05B2E:  CLRF   xB0
05B30:  MOVFF  3AE,3AF
05B34:  MOVLB  0
05B36:  CALL   3EEA
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
05B3A:  MOVLW  03
05B3C:  MOVLB  3
05B3E:  MOVWF  xAF
05B40:  MOVLW  88
05B42:  MOVWF  xAE
05B44:  MOVFF  383,3B1
05B48:  MOVFF  382,3B0
05B4C:  MOVLB  0
05B4E:  GOTO   467E
05B52:  MOVFF  01,3A8
....................    if(socket != INVALID_SOCKET) 
05B56:  MOVLB  3
05B58:  MOVF   xA8,W
05B5A:  SUBLW  FE
05B5C:  BZ    5B84
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
05B5E:  MOVFF  3A8,3AE
05B62:  MOVFF  383,3B0
05B66:  MOVFF  382,3AF
05B6A:  MOVLW  03
05B6C:  MOVWF  xB2
05B6E:  MOVLW  88
05B70:  MOVWF  xB1
05B72:  MOVFF  387,3B4
05B76:  MOVFF  386,3B3
05B7A:  MOVLB  0
05B7C:  GOTO   4F00
....................    } 
....................    else 
05B80:  BRA    5B8A
05B82:  MOVLB  3
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
05B84:  MOVLB  0
05B86:  CALL   3070
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
05B8A:  MOVLW  01
05B8C:  MOVWF  01
.................... } 
05B8E:  GOTO   A26E (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
04CC6:  MOVLW  01
04CC8:  MOVLB  4
04CCA:  MOVWF  x0B
04CCC:  MOVLB  0
04CCE:  RCALL  497A
04CD0:  MOVF   01,F
04CD2:  BZ    4CC6
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
04CD4:  MOVLB  3
04CD6:  INCFSZ xE2,W
04CD8:  BRA    4CEC
....................       buff = MACGetTxBuffer(TRUE); 
04CDA:  MOVLW  01
04CDC:  MOVLB  4
04CDE:  MOVWF  x0B
04CE0:  MOVLB  0
04CE2:  CALL   344A
04CE6:  MOVFF  01,3E2
04CEA:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
04CEC:  INCFSZ xE2,W
04CEE:  BRA    4CF2
....................       return; 
04CF0:  BRA    4EFC
....................  
....................    IPSetTxBuffer(buff, 0); 
04CF2:  MOVFF  3E2,424
04CF6:  MOVLB  4
04CF8:  CLRF   x26
04CFA:  MOVLW  14
04CFC:  MOVWF  x25
04CFE:  MOVLB  0
04D00:  CALL   3474
....................  
....................    header.SourcePort           = localPort; 
04D04:  MOVFF  3D6,3E8
04D08:  MOVFF  3D5,3E7
....................    header.DestPort             = remotePort; 
04D0C:  MOVFF  3D8,3EA
04D10:  MOVFF  3D7,3E9
....................    header.SeqNumber            = tseq; 
04D14:  MOVFF  3DC,3EE
04D18:  MOVFF  3DB,3ED
04D1C:  MOVFF  3DA,3EC
04D20:  MOVFF  3D9,3EB
....................    header.AckNumber            = tack; 
04D24:  MOVFF  3E0,3F2
04D28:  MOVFF  3DF,3F1
04D2C:  MOVFF  3DE,3F0
04D30:  MOVFF  3DD,3EF
....................    header.Flags.bits.Reserved2 = 0; 
04D34:  MOVLW  3F
04D36:  MOVLB  3
04D38:  ANDWF  xF4,W
04D3A:  MOVWF  xF4
....................    header.DataOffset.Reserved3 = 0; 
04D3C:  MOVLW  F0
04D3E:  ANDWF  xF3,W
04D40:  MOVWF  xF3
....................    header.Flags.b              = flags; 
04D42:  MOVFF  3E1,3F4
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
04D46:  MOVLB  0
04D48:  BRA    49A4
04D4A:  MOVFF  02,3F6
04D4E:  MOVFF  01,3F5
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
04D52:  MOVLB  3
04D54:  MOVF   xF6,F
04D56:  BNZ   4D5E
04D58:  MOVF   xF5,W
04D5A:  SUBLW  28
04D5C:  BC    4D68
....................    { 
....................       header.Window -= 40; 
04D5E:  MOVLW  28
04D60:  SUBWF  xF5,F
04D62:  MOVLW  00
04D64:  SUBWFB xF6,F
....................    } 
....................    else 
04D66:  BRA    4D6C
....................       header.Window = 0; 
04D68:  CLRF   xF6
04D6A:  CLRF   xF5
.................... #endif 
....................  
....................    header.Checksum             = 0; 
04D6C:  CLRF   xF8
04D6E:  CLRF   xF7
....................    header.UrgentPointer        = 0; 
04D70:  CLRF   xFA
04D72:  CLRF   xF9
....................  
....................    SwapTCPHeader(&header); 
04D74:  MOVLW  03
04D76:  MOVLB  4
04D78:  MOVWF  x0C
04D7A:  MOVLW  E7
04D7C:  MOVWF  x0B
04D7E:  MOVLB  0
04D80:  CALL   4458
....................  
....................    len += sizeof(header); 
04D84:  MOVLW  14
04D86:  MOVLB  3
04D88:  ADDWF  xE3,F
04D8A:  MOVLW  00
04D8C:  ADDWFC xE4,F
....................  
....................    if ( flags & SYN ) 
04D8E:  BTFSS  xE1.1
04D90:  BRA    4DB0
....................    { 
....................       len += sizeof(options); 
04D92:  MOVLW  04
04D94:  ADDWF  xE3,F
04D96:  MOVLW  00
04D98:  ADDWFC xE4,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
04D9A:  MOVLW  02
04D9C:  MOVWF  xFB
....................       options.Length = 0x04; 
04D9E:  MOVLW  04
04DA0:  MOVWF  xFC
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
04DA2:  MOVWF  xFD
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
04DA4:  CLRF   xFE
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
04DA6:  MOVLW  0F
04DA8:  ANDWF  xF3,W
04DAA:  IORLW  60
04DAC:  MOVWF  xF3
....................    } 
....................    else 
04DAE:  BRA    4DB8
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
04DB0:  MOVLW  0F
04DB2:  ANDWF  xF3,W
04DB4:  IORLW  50
04DB6:  MOVWF  xF3
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
04DB8:  MOVFF  19,402
04DBC:  MOVFF  18,401
04DC0:  MOVFF  17,400
04DC4:  MOVFF  16,3FF
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
04DC8:  MOVLW  06
04DCA:  ADDWF  xD3,W
04DCC:  MOVWF  FE9
04DCE:  MOVLW  00
04DD0:  ADDWFC xD4,W
04DD2:  MOVWF  FEA
04DD4:  MOVFF  FEF,00
04DD8:  MOVFF  FEC,01
04DDC:  MOVFF  FEC,02
04DE0:  MOVFF  FEC,03
04DE4:  MOVFF  03,406
04DE8:  MOVFF  02,405
04DEC:  MOVFF  01,404
04DF0:  MOVFF  00,403
....................    pseudoHeader.Zero           = 0x0; 
04DF4:  MOVLB  4
04DF6:  CLRF   x07
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
04DF8:  MOVLW  06
04DFA:  MOVWF  x08
....................    pseudoHeader.TCPLength      = len; 
04DFC:  MOVFF  3E4,40A
04E00:  MOVFF  3E3,409
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
04E04:  MOVFF  40A,42B
04E08:  MOVFF  409,42A
04E0C:  MOVLB  0
04E0E:  CALL   3142
04E12:  MOVFF  02,40A
04E16:  MOVFF  01,409
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
04E1A:  MOVLW  03
04E1C:  MOVLB  4
04E1E:  MOVWF  x0C
04E20:  MOVLW  FF
04E22:  MOVFF  40C,40E
04E26:  MOVWF  x0D
04E28:  CLRF   x10
04E2A:  MOVLW  0C
04E2C:  MOVWF  x0F
04E2E:  MOVLB  0
04E30:  CALL   3DFC
04E34:  MOVFF  01,3F7
04E38:  MOVLB  3
04E3A:  COMF   xF7,F
04E3C:  MOVFF  02,3F8
04E40:  COMF   xF8,F
....................    checkSum.Val = header.Checksum; 
04E42:  MOVFF  3F8,3E6
04E46:  MOVFF  3F7,3E5
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
04E4A:  MOVFF  3D4,40C
04E4E:  MOVFF  3D3,40B
04E52:  MOVLW  06
04E54:  MOVLB  4
04E56:  MOVWF  x0D
04E58:  MOVFF  3E4,40F
04E5C:  MOVFF  3E3,40E
04E60:  MOVLB  0
04E62:  RCALL  4B96
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
04E64:  MOVLW  03
04E66:  MOVLB  4
04E68:  MOVWF  x0C
04E6A:  MOVLW  E7
04E6C:  MOVFF  40C,430
04E70:  MOVWF  x2F
04E72:  CLRF   x32
04E74:  MOVLW  14
04E76:  MOVWF  x31
04E78:  MOVLB  0
04E7A:  CALL   353C
....................  
....................    if ( flags & SYN ) 
04E7E:  MOVLB  3
04E80:  BTFSS  xE1.1
04E82:  BRA    4E9E
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
04E84:  MOVLW  03
04E86:  MOVLB  4
04E88:  MOVWF  x0C
04E8A:  MOVLW  FB
04E8C:  MOVFF  40C,430
04E90:  MOVWF  x2F
04E92:  CLRF   x32
04E94:  MOVLW  04
04E96:  MOVWF  x31
04E98:  MOVLB  0
04E9A:  CALL   353C
....................  
....................    IPSetTxBuffer(buff, 0); 
04E9E:  MOVFF  3E2,424
04EA2:  MOVLB  4
04EA4:  CLRF   x26
04EA6:  MOVLW  14
04EA8:  MOVWF  x25
04EAA:  MOVLB  0
04EAC:  CALL   3474
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
04EB0:  MOVFF  3E4,40C
04EB4:  MOVFF  3E3,40B
04EB8:  CALL   3F30
04EBC:  MOVFF  02,3E6
04EC0:  MOVFF  01,3E5
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
04EC4:  MOVFF  3E2,424
04EC8:  MOVLB  4
04ECA:  CLRF   x26
04ECC:  MOVLW  24
04ECE:  MOVWF  x25
04ED0:  MOVLB  0
04ED2:  CALL   3474
....................    MACPut(checkSum.v[1]); 
04ED6:  MOVFF  3E6,42E
04EDA:  CALL   351E
....................    MACPut(checkSum.v[0]); 
04EDE:  MOVFF  3E5,42E
04EE2:  CALL   351E
....................    MACSetTxBuffer(buff, 0); 
04EE6:  MOVFF  3E2,424
04EEA:  MOVLB  4
04EEC:  CLRF   x26
04EEE:  CLRF   x25
04EF0:  MOVLB  0
04EF2:  CALL   3474
....................  
....................    MACFlush(); 
04EF6:  CALL   3658
04EFA:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
04EFC:  MOVLB  0
04EFE:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
0467E:  MOVLW  FE
04680:  MOVLB  3
04682:  MOVWF  xB5
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
04684:  CLRF   xB4
04686:  MOVF   xB4,W
04688:  SUBLW  04
0468A:  BTFSS  FD8.0
0468C:  BRA    4782
....................    { 
....................       ps = &TCB[s]; 
0468E:  MOVF   xB4,W
04690:  MULLW  24
04692:  MOVF   FF3,W
04694:  CLRF   03
04696:  ADDLW  8C
04698:  MOVWF  01
0469A:  MOVLW  00
0469C:  ADDWFC 03,F
0469E:  MOVFF  01,3B2
046A2:  MOVFF  03,3B3
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
046A6:  MOVFF  3B2,FE9
046AA:  MOVFF  3B3,FEA
046AE:  MOVF   FEF,W
046B0:  SUBLW  0A
046B2:  BZ    477E
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
046B4:  MOVLW  0B
046B6:  ADDWF  xB2,W
046B8:  MOVWF  FE9
046BA:  MOVLW  00
046BC:  ADDWFC xB3,W
046BE:  MOVWF  FEA
046C0:  MOVFF  FEC,3B7
046C4:  MOVF   FED,F
046C6:  MOVFF  FEF,3B6
046CA:  MOVLW  02
046CC:  ADDWF  xAE,W
046CE:  MOVWF  FE9
046D0:  MOVLW  00
046D2:  ADDWFC xAF,W
046D4:  MOVWF  FEA
046D6:  MOVFF  FEC,03
046DA:  MOVF   FED,F
046DC:  MOVF   FEF,W
046DE:  SUBWF  xB6,W
046E0:  BNZ   477E
046E2:  MOVF   03,W
046E4:  SUBWF  xB7,W
046E6:  BNZ   477E
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
046E8:  MOVFF  3B2,FE9
046EC:  MOVFF  3B3,FEA
046F0:  MOVF   FEF,F
046F2:  BNZ   46F8
....................                partialMatch = s; 
046F4:  MOVFF  3B4,3B5
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
046F8:  MOVLW  0D
046FA:  ADDWF  xB2,W
046FC:  MOVWF  FE9
046FE:  MOVLW  00
04700:  ADDWFC xB3,W
04702:  MOVWF  FEA
04704:  MOVFF  FEC,3B7
04708:  MOVF   FED,F
0470A:  MOVFF  FEF,3B6
0470E:  MOVFF  3AE,FE9
04712:  MOVFF  3AF,FEA
04716:  MOVFF  FEC,03
0471A:  MOVF   FED,F
0471C:  MOVF   FEF,W
0471E:  SUBWF  xB6,W
04720:  BNZ   477E
04722:  MOVF   03,W
04724:  SUBWF  xB7,W
04726:  BNZ   477E
04728:  MOVLW  07
0472A:  ADDWF  xB2,W
0472C:  MOVWF  FE9
0472E:  MOVLW  00
04730:  ADDWFC xB3,W
04732:  MOVWF  FEA
04734:  MOVFF  FEF,3B6
04738:  MOVFF  FEC,3B7
0473C:  MOVFF  FEC,3B8
04740:  MOVFF  FEC,3B9
04744:  MOVLW  06
04746:  ADDWF  xB0,W
04748:  MOVWF  FE9
0474A:  MOVLW  00
0474C:  ADDWFC xB1,W
0474E:  MOVWF  FEA
04750:  MOVFF  FEF,00
04754:  MOVFF  FEC,01
04758:  MOVFF  FEC,02
0475C:  MOVFF  FEC,03
04760:  MOVF   00,W
04762:  SUBWF  xB6,W
04764:  BNZ   477E
04766:  MOVF   01,W
04768:  SUBWF  xB7,W
0476A:  BNZ   477E
0476C:  MOVF   02,W
0476E:  SUBWF  xB8,W
04770:  BNZ   477E
04772:  MOVF   03,W
04774:  SUBWF  xB9,W
04776:  BNZ   477E
....................             { 
....................                return s; 
04778:  MOVFF  3B4,01
0477C:  BRA    4856
....................             } 
....................          } 
....................       } 
....................    } 
0477E:  INCF   xB4,F
04780:  BRA    4686
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
04782:  MOVF   xB5,W
04784:  SUBLW  FE
04786:  BNZ   478E
....................       return INVALID_SOCKET; 
04788:  MOVLW  FE
0478A:  MOVWF  01
0478C:  BRA    4856
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
0478E:  MOVF   xB5,W
04790:  MULLW  24
04792:  MOVF   FF3,W
04794:  CLRF   03
04796:  ADDLW  8C
04798:  MOVWF  01
0479A:  MOVLW  00
0479C:  ADDWFC 03,F
0479E:  MOVFF  01,3B2
047A2:  MOVFF  03,3B3
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
047A6:  MOVLW  01
047A8:  ADDWF  xB2,W
047AA:  MOVWF  xB6
047AC:  MOVLW  00
047AE:  ADDWFC xB3,W
047B0:  MOVWF  xB7
047B2:  MOVWF  FEA
047B4:  MOVFF  3B6,FE9
047B8:  MOVFF  3B1,FE2
047BC:  MOVFF  3B0,FE1
047C0:  MOVLW  0A
047C2:  MOVWF  01
047C4:  MOVFF  FE6,FEE
047C8:  DECFSZ 01,F
047CA:  BRA    47C4
....................    ps->remotePort          = h->SourcePort; 
047CC:  MOVLW  0D
047CE:  ADDWF  xB2,W
047D0:  MOVWF  01
047D2:  MOVLW  00
047D4:  ADDWFC xB3,W
047D6:  MOVFF  3AE,FE9
047DA:  MOVFF  3AF,FEA
047DE:  MOVFF  FEC,03
047E2:  MOVF   FED,F
047E4:  MOVFF  FEF,3B8
047E8:  MOVWF  FEA
047EA:  MOVFF  01,FE9
047EE:  MOVFF  03,FEC
047F2:  MOVF   FED,F
047F4:  MOVFF  3B8,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
047F8:  MOVLW  23
047FA:  ADDWF  xB2,W
047FC:  MOVWF  FE9
047FE:  MOVLW  00
04800:  ADDWFC xB3,W
04802:  MOVWF  FEA
04804:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
04806:  MOVLW  0F
04808:  ADDWF  xB2,W
0480A:  MOVWF  FE9
0480C:  MOVLW  00
0480E:  ADDWFC xB3,W
04810:  MOVWF  FEA
04812:  INCFSZ FEF,W
04814:  BRA    4818
04816:  BRA    4844
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
04818:  MOVLW  0F
0481A:  ADDWF  xB2,W
0481C:  MOVWF  FE9
0481E:  MOVLW  00
04820:  ADDWFC xB3,W
04822:  MOVWF  FEA
04824:  MOVFF  FEF,3B6
04828:  MOVFF  3B6,3CF
0482C:  MOVLB  0
0482E:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
04832:  MOVLW  0F
04834:  MOVLB  3
04836:  ADDWF  xB2,W
04838:  MOVWF  FE9
0483A:  MOVLW  00
0483C:  ADDWFC xB3,W
0483E:  MOVWF  FEA
04840:  MOVLW  FF
04842:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
04844:  MOVLW  23
04846:  ADDWF  xB2,W
04848:  MOVWF  FE9
0484A:  MOVLW  00
0484C:  ADDWFC xB3,W
0484E:  MOVWF  FEA
04850:  BSF    FEF.1
....................  
....................    return partialMatch; 
04852:  MOVFF  3B5,01
.................... } 
04856:  MOVLB  0
04858:  GOTO   5B52 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
04458:  MOVLB  4
0445A:  MOVFF  40B,01
0445E:  MOVFF  40C,03
04462:  MOVFF  40B,40D
04466:  MOVFF  40C,40E
0446A:  MOVFF  40B,FE9
0446E:  MOVFF  40C,FEA
04472:  MOVFF  FEC,410
04476:  MOVF   FED,F
04478:  MOVFF  FEF,40F
0447C:  MOVFF  410,42B
04480:  MOVFF  40F,42A
04484:  MOVLB  0
04486:  CALL   3142
0448A:  MOVFF  40E,FEA
0448E:  MOVFF  40D,FE9
04492:  MOVFF  02,FEC
04496:  MOVF   FED,F
04498:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
0449C:  MOVLW  02
0449E:  MOVLB  4
044A0:  ADDWF  x0B,W
044A2:  MOVWF  01
044A4:  MOVLW  00
044A6:  ADDWFC x0C,W
044A8:  MOVWF  03
044AA:  MOVFF  01,40D
044AE:  MOVWF  x0E
044B0:  MOVLW  02
044B2:  ADDWF  x0B,W
044B4:  MOVWF  FE9
044B6:  MOVLW  00
044B8:  ADDWFC x0C,W
044BA:  MOVWF  FEA
044BC:  MOVFF  FEC,410
044C0:  MOVF   FED,F
044C2:  MOVFF  FEF,40F
044C6:  MOVFF  410,42B
044CA:  MOVFF  40F,42A
044CE:  MOVLB  0
044D0:  CALL   3142
044D4:  MOVFF  40E,FEA
044D8:  MOVFF  40D,FE9
044DC:  MOVFF  02,FEC
044E0:  MOVF   FED,F
044E2:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
044E6:  MOVLW  04
044E8:  MOVLB  4
044EA:  ADDWF  x0B,W
044EC:  MOVWF  01
044EE:  MOVLW  00
044F0:  ADDWFC x0C,W
044F2:  MOVWF  03
044F4:  MOVFF  01,40D
044F8:  MOVWF  x0E
044FA:  MOVLW  04
044FC:  ADDWF  x0B,W
044FE:  MOVWF  FE9
04500:  MOVLW  00
04502:  ADDWFC x0C,W
04504:  MOVWF  FEA
04506:  MOVFF  FEF,40F
0450A:  MOVFF  FEC,410
0450E:  MOVFF  FEC,411
04512:  MOVFF  FEC,412
04516:  MOVFF  412,416
0451A:  MOVFF  411,415
0451E:  MOVFF  410,414
04522:  MOVFF  40F,413
04526:  MOVLB  0
04528:  RCALL  4436
0452A:  MOVFF  40E,FEA
0452E:  MOVFF  40D,FE9
04532:  MOVFF  00,FEF
04536:  MOVFF  01,FEC
0453A:  MOVFF  02,FEC
0453E:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
04542:  MOVLW  08
04544:  MOVLB  4
04546:  ADDWF  x0B,W
04548:  MOVWF  01
0454A:  MOVLW  00
0454C:  ADDWFC x0C,W
0454E:  MOVWF  03
04550:  MOVFF  01,40D
04554:  MOVWF  x0E
04556:  MOVLW  08
04558:  ADDWF  x0B,W
0455A:  MOVWF  FE9
0455C:  MOVLW  00
0455E:  ADDWFC x0C,W
04560:  MOVWF  FEA
04562:  MOVFF  FEF,40F
04566:  MOVFF  FEC,410
0456A:  MOVFF  FEC,411
0456E:  MOVFF  FEC,412
04572:  MOVFF  412,416
04576:  MOVFF  411,415
0457A:  MOVFF  410,414
0457E:  MOVFF  40F,413
04582:  MOVLB  0
04584:  RCALL  4436
04586:  MOVFF  40E,FEA
0458A:  MOVFF  40D,FE9
0458E:  MOVFF  00,FEF
04592:  MOVFF  01,FEC
04596:  MOVFF  02,FEC
0459A:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
0459E:  MOVLW  0E
045A0:  MOVLB  4
045A2:  ADDWF  x0B,W
045A4:  MOVWF  01
045A6:  MOVLW  00
045A8:  ADDWFC x0C,W
045AA:  MOVWF  03
045AC:  MOVFF  01,40D
045B0:  MOVWF  x0E
045B2:  MOVLW  0E
045B4:  ADDWF  x0B,W
045B6:  MOVWF  FE9
045B8:  MOVLW  00
045BA:  ADDWFC x0C,W
045BC:  MOVWF  FEA
045BE:  MOVFF  FEC,410
045C2:  MOVF   FED,F
045C4:  MOVFF  FEF,40F
045C8:  MOVFF  410,42B
045CC:  MOVFF  40F,42A
045D0:  MOVLB  0
045D2:  CALL   3142
045D6:  MOVFF  40E,FEA
045DA:  MOVFF  40D,FE9
045DE:  MOVFF  02,FEC
045E2:  MOVF   FED,F
045E4:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
045E8:  MOVLW  10
045EA:  MOVLB  4
045EC:  ADDWF  x0B,W
045EE:  MOVWF  01
045F0:  MOVLW  00
045F2:  ADDWFC x0C,W
045F4:  MOVWF  03
045F6:  MOVFF  01,40D
045FA:  MOVWF  x0E
045FC:  MOVLW  10
045FE:  ADDWF  x0B,W
04600:  MOVWF  FE9
04602:  MOVLW  00
04604:  ADDWFC x0C,W
04606:  MOVWF  FEA
04608:  MOVFF  FEC,410
0460C:  MOVF   FED,F
0460E:  MOVFF  FEF,40F
04612:  MOVFF  410,42B
04616:  MOVFF  40F,42A
0461A:  MOVLB  0
0461C:  CALL   3142
04620:  MOVFF  40E,FEA
04624:  MOVFF  40D,FE9
04628:  MOVFF  02,FEC
0462C:  MOVF   FED,F
0462E:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
04632:  MOVLW  12
04634:  MOVLB  4
04636:  ADDWF  x0B,W
04638:  MOVWF  01
0463A:  MOVLW  00
0463C:  ADDWFC x0C,W
0463E:  MOVWF  03
04640:  MOVFF  01,40D
04644:  MOVWF  x0E
04646:  MOVLW  12
04648:  ADDWF  x0B,W
0464A:  MOVWF  FE9
0464C:  MOVLW  00
0464E:  ADDWFC x0C,W
04650:  MOVWF  FEA
04652:  MOVFF  FEC,410
04656:  MOVF   FED,F
04658:  MOVFF  FEF,40F
0465C:  MOVFF  410,42B
04660:  MOVFF  40F,42A
04664:  MOVLB  0
04666:  CALL   3142
0466A:  MOVFF  40E,FEA
0466E:  MOVFF  40D,FE9
04672:  MOVFF  02,FEC
04676:  MOVF   FED,F
04678:  MOVFF  01,FEF
.................... } 
0467C:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
04876:  MOVLW  0F
04878:  MOVLB  3
0487A:  ADDWF  xCC,W
0487C:  MOVWF  FE9
0487E:  MOVLW  00
04880:  ADDWFC xCD,W
04882:  MOVWF  FEA
04884:  INCFSZ FEF,W
04886:  BRA    488A
04888:  BRA    48C4
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
0488A:  MOVLW  0F
0488C:  ADDWF  xCC,W
0488E:  MOVWF  FE9
04890:  MOVLW  00
04892:  ADDWFC xCD,W
04894:  MOVWF  FEA
04896:  MOVFF  FEF,3CE
0489A:  MOVFF  3CE,3CF
0489E:  MOVLB  0
048A0:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
048A4:  MOVLW  0F
048A6:  MOVLB  3
048A8:  ADDWF  xCC,W
048AA:  MOVWF  FE9
048AC:  MOVLW  00
048AE:  ADDWFC xCD,W
048B0:  MOVWF  FEA
048B2:  MOVLW  FF
048B4:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
048B6:  MOVLW  23
048B8:  ADDWF  xCC,W
048BA:  MOVWF  FE9
048BC:  MOVLW  00
048BE:  ADDWFC xCD,W
048C0:  MOVWF  FEA
048C2:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
048C4:  MOVLW  07
048C6:  ADDWF  xCC,W
048C8:  MOVWF  FE9
048CA:  MOVLW  00
048CC:  ADDWFC xCD,W
048CE:  MOVWF  FEA
048D0:  MOVF   FEE,F
048D2:  MOVF   FEE,F
048D4:  CLRF   FEC
048D6:  MOVF   FED,F
048D8:  CLRF   FEF
048DA:  MOVF   FED,F
048DC:  CLRF   FEF
048DE:  MOVF   FED,F
048E0:  CLRF   FEF
....................     ps->remotePort = 0x00; 
048E2:  MOVLW  0D
048E4:  ADDWF  xCC,W
048E6:  MOVWF  FE9
048E8:  MOVLW  00
048EA:  ADDWFC xCD,W
048EC:  MOVWF  FEA
048EE:  CLRF   FEC
048F0:  MOVF   FED,F
048F2:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
048F4:  MOVLW  23
048F6:  ADDWF  xCC,W
048F8:  MOVWF  FE9
048FA:  MOVLW  00
048FC:  ADDWFC xCD,W
048FE:  MOVWF  FEA
04900:  BTFSS  FEF.3
04902:  BRA    490C
....................     { 
....................         MACDiscardRx(); 
04904:  MOVLB  0
04906:  CALL   3070
0490A:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
0490C:  MOVLW  23
0490E:  ADDWF  xCC,W
04910:  MOVWF  FE9
04912:  MOVLW  00
04914:  ADDWFC xCD,W
04916:  MOVWF  FEA
04918:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
0491A:  MOVLW  21
0491C:  ADDWF  xCC,W
0491E:  MOVWF  FE9
04920:  MOVLW  00
04922:  ADDWFC xCD,W
04924:  MOVWF  FEA
04926:  CLRF   FEC
04928:  MOVF   FED,F
0492A:  MOVLW  1E
0492C:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
0492E:  MOVLW  23
04930:  ADDWF  xCC,W
04932:  MOVWF  FE9
04934:  MOVLW  00
04936:  ADDWFC xCD,W
04938:  MOVWF  FEA
0493A:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
0493C:  MOVLW  23
0493E:  ADDWF  xCC,W
04940:  MOVWF  FE9
04942:  MOVLW  00
04944:  ADDWFC xCD,W
04946:  MOVWF  FEA
04948:  BTFSS  FEF.0
0494A:  BRA    4958
....................     { 
....................         ps->smState = TCP_LISTEN; 
0494C:  MOVFF  3CC,FE9
04950:  MOVFF  3CD,FEA
04954:  CLRF   FEF
....................     } 
....................     else 
04956:  BRA    4964
....................     { 
....................         ps->smState = TCP_CLOSED; 
04958:  MOVFF  3CC,FE9
0495C:  MOVFF  3CD,FEA
04960:  MOVLW  0A
04962:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
04964:  MOVLW  10
04966:  ADDWF  xCC,W
04968:  MOVWF  FE9
0496A:  MOVLW  00
0496C:  ADDWFC xCD,W
0496E:  MOVWF  FEA
04970:  CLRF   FEC
04972:  MOVF   FED,F
04974:  CLRF   FEF
....................  
....................     return; 
.................... } 
04976:  MOVLB  0
04978:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
04F00:  MOVLB  3
04F02:  MOVF   xAE,W
04F04:  MULLW  24
04F06:  MOVF   FF3,W
04F08:  CLRF   03
04F0A:  ADDLW  8C
04F0C:  MOVWF  01
04F0E:  MOVLW  00
04F10:  ADDWFC 03,F
04F12:  MOVFF  01,3C5
04F16:  MOVFF  03,3C6
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
04F1A:  CLRF   xC7
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
04F1C:  MOVLW  1E
04F1E:  ADDWF  xC5,W
04F20:  MOVWF  FE9
04F22:  MOVLW  00
04F24:  ADDWFC xC6,W
04F26:  MOVWF  FEA
04F28:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
04F2A:  MOVLW  1F
04F2C:  ADDWF  xC5,W
04F2E:  MOVWF  01
04F30:  MOVLW  00
04F32:  ADDWFC xC6,W
04F34:  MOVWF  03
04F36:  MOVFF  01,3CC
04F3A:  MOVWF  xCD
04F3C:  MOVLB  0
04F3E:  RCALL  485C
04F40:  MOVFF  3CD,FEA
04F44:  MOVFF  3CC,FE9
04F48:  MOVFF  02,FEC
04F4C:  MOVF   FED,F
04F4E:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
04F52:  MOVLW  21
04F54:  MOVLB  3
04F56:  ADDWF  xC5,W
04F58:  MOVWF  FE9
04F5A:  MOVLW  00
04F5C:  ADDWFC xC6,W
04F5E:  MOVWF  FEA
04F60:  CLRF   FEC
04F62:  MOVF   FED,F
04F64:  MOVLW  1E
04F66:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
04F68:  MOVLW  0D
04F6A:  ADDWF  xB1,W
04F6C:  MOVWF  FE9
04F6E:  MOVLW  00
04F70:  ADDWFC xB2,W
04F72:  MOVWF  FEA
04F74:  BTFSS  FEF.2
04F76:  BRA    4FB4
....................    { 
....................       MACDiscardRx(); 
04F78:  MOVLB  0
04F7A:  CALL   3070
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
04F7E:  MOVLB  3
04F80:  MOVFF  3C5,01
04F84:  MOVFF  3C6,03
04F88:  MOVFF  3C5,3CC
04F8C:  MOVFF  3C6,3CD
04F90:  MOVLW  23
04F92:  ADDWF  xC5,W
04F94:  MOVWF  FE9
04F96:  MOVLW  00
04F98:  ADDWFC xC6,W
04F9A:  MOVWF  FEA
04F9C:  BTFSS  FEF.0
04F9E:  BRA    4FA4
04FA0:  MOVLW  00
04FA2:  BRA    4FA6
04FA4:  MOVLW  01
04FA6:  MOVFF  3CD,FEA
04FAA:  MOVFF  3CC,FE9
04FAE:  MOVWF  FEF
....................       return; 
04FB0:  GOTO   59D8
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
04FB4:  MOVLW  16
04FB6:  ADDWF  xC5,W
04FB8:  MOVWF  FE9
04FBA:  MOVLW  00
04FBC:  ADDWFC xC6,W
04FBE:  MOVWF  FEA
04FC0:  MOVFF  FEF,00
04FC4:  MOVFF  FEC,01
04FC8:  MOVFF  FEC,02
04FCC:  MOVFF  FEC,03
04FD0:  MOVFF  03,3BC
04FD4:  MOVFF  02,3BB
04FD8:  MOVFF  01,3BA
04FDC:  MOVFF  00,3B9
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
04FE0:  MOVLW  0E
04FE2:  ADDWF  xB1,W
04FE4:  MOVWF  FE9
04FE6:  MOVLW  00
04FE8:  ADDWFC xB2,W
04FEA:  MOVWF  FEA
04FEC:  MOVFF  FEC,03
04FF0:  MOVF   FED,F
04FF2:  MOVFF  FEF,3CC
04FF6:  MOVFF  03,3CD
04FFA:  CLRF   xCE
04FFC:  CLRF   xCF
04FFE:  MOVLW  08
05000:  ADDWF  xB1,W
05002:  MOVWF  FE9
05004:  MOVLW  00
05006:  ADDWFC xB2,W
05008:  MOVWF  FEA
0500A:  MOVFF  FEF,00
0500E:  MOVFF  FEC,01
05012:  MOVFF  FEC,02
05016:  MOVFF  FEC,03
0501A:  MOVF   00,W
0501C:  SUBWF  xB9,W
0501E:  MOVWF  00
05020:  MOVF   01,W
05022:  SUBWFB xBA,W
05024:  MOVWF  01
05026:  MOVF   02,W
05028:  SUBWFB xBB,W
0502A:  MOVWF  02
0502C:  MOVF   03,W
0502E:  SUBWFB xBC,W
05030:  MOVWF  03
05032:  MOVF   00,W
05034:  SUBWF  xCC,F
05036:  MOVF   01,W
05038:  SUBWFB xCD,F
0503A:  MOVF   02,W
0503C:  SUBWFB xCE,F
0503E:  MOVF   03,W
05040:  SUBWFB xCF,F
05042:  MOVLW  10
05044:  ADDWF  xC5,W
05046:  MOVWF  FE9
05048:  MOVLW  00
0504A:  ADDWFC xC6,W
0504C:  MOVWF  FEA
0504E:  MOVFF  FEC,03
05052:  MOVF   FED,F
05054:  MOVFF  FEF,00
05058:  MOVFF  03,01
0505C:  CLRF   02
0505E:  CLRF   03
05060:  MOVF   00,W
05062:  SUBWF  xCC,W
05064:  MOVWF  xC8
05066:  MOVF   01,W
05068:  SUBWFB xCD,W
0506A:  MOVWF  xC9
0506C:  MOVF   02,W
0506E:  SUBWFB xCE,W
05070:  MOVWF  xCA
05072:  MOVF   03,W
05074:  SUBWFB xCF,W
05076:  MOVWF  xCB
....................    if(temp < 0) 
05078:  BTFSC  xCB.7
0507A:  BRA    507E
0507C:  BRA    5092
....................    { 
....................       ps->RemoteWindow = 0; 
0507E:  MOVLW  14
05080:  ADDWF  xC5,W
05082:  MOVWF  FE9
05084:  MOVLW  00
05086:  ADDWFC xC6,W
05088:  MOVWF  FEA
0508A:  CLRF   FEC
0508C:  MOVF   FED,F
0508E:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
05090:  BRA    50A6
....................    { 
....................       ps->RemoteWindow = ack; 
05092:  MOVLW  14
05094:  ADDWF  xC5,W
05096:  MOVWF  FE9
05098:  MOVLW  00
0509A:  ADDWFC xC6,W
0509C:  MOVWF  FEA
0509E:  MOVFF  3B5,FEF
050A2:  MOVFF  3B6,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
050A6:  MOVFF  3C5,FE9
050AA:  MOVFF  3C6,FEA
050AE:  DECFSZ FEF,W
050B0:  BRA    522E
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
050B2:  MOVLW  0D
050B4:  ADDWF  xB1,W
050B6:  MOVWF  FE9
050B8:  MOVLW  00
050BA:  ADDWFC xB2,W
050BC:  MOVWF  FEA
050BE:  BTFSC  FEF.1
050C0:  BRA    50E6
....................       { 
....................          MACDiscardRx(); 
050C2:  MOVLB  0
050C4:  CALL   3070
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
050C8:  MOVLW  0D
050CA:  MOVLB  3
050CC:  ADDWF  xB1,W
050CE:  MOVWF  FE9
050D0:  MOVLW  00
050D2:  ADDWFC xB2,W
050D4:  MOVWF  FEA
050D6:  BTFSS  FEF.4
050D8:  BRA    50E2
....................           { 
....................             flags = RST; 
050DA:  MOVLW  04
050DC:  MOVWF  xC7
....................             goto SendTCPControlPacket; 
050DE:  GOTO   5960
....................            } 
....................  
....................          return; 
050E2:  GOTO   59D8
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
050E6:  MOVLW  1A
050E8:  ADDWF  xC5,W
050EA:  MOVWF  01
050EC:  MOVLW  00
050EE:  ADDWFC xC6,W
050F0:  MOVFF  01,3CC
050F4:  MOVWF  xCD
050F6:  MOVLW  04
050F8:  ADDWF  xB1,W
050FA:  MOVWF  FE9
050FC:  MOVLW  00
050FE:  ADDWFC xB2,W
05100:  MOVWF  FEA
05102:  MOVFF  FEF,3CE
05106:  MOVFF  FEC,3CF
0510A:  MOVFF  FEC,3D0
0510E:  MOVFF  FEC,3D1
05112:  MOVF   xB3,W
05114:  ADDWF  xCE,F
05116:  MOVF   xB4,W
05118:  ADDWFC xCF,F
0511A:  MOVLW  00
0511C:  ADDWFC xD0,F
0511E:  ADDWFC xD1,F
05120:  MOVLW  01
05122:  ADDWF  xCE,W
05124:  MOVWF  00
05126:  MOVLW  00
05128:  ADDWFC xCF,W
0512A:  MOVWF  01
0512C:  MOVLW  00
0512E:  ADDWFC xD0,W
05130:  MOVWF  02
05132:  MOVLW  00
05134:  ADDWFC xD1,W
05136:  MOVFF  3CD,FEA
0513A:  MOVFF  3CC,FE9
0513E:  MOVFF  00,FEF
05142:  MOVFF  01,FEC
05146:  MOVFF  02,FEC
0514A:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
0514C:  MOVLW  1A
0514E:  ADDWF  xC5,W
05150:  MOVWF  FE9
05152:  MOVLW  00
05154:  ADDWFC xC6,W
05156:  MOVWF  FEA
05158:  MOVFF  FEF,00
0515C:  MOVFF  FEC,01
05160:  MOVFF  FEC,02
05164:  MOVFF  FEC,03
05168:  MOVFF  03,3B8
0516C:  MOVFF  02,3B7
05170:  MOVFF  01,3B6
05174:  MOVFF  00,3B5
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
05178:  MOVLW  0D
0517A:  ADDWF  xB1,W
0517C:  MOVWF  FE9
0517E:  MOVLW  00
05180:  ADDWFC xB2,W
05182:  MOVWF  FEA
05184:  BTFSC  FEF.4
05186:  BRA    51A4
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
05188:  MOVFF  3C5,FE9
0518C:  MOVFF  3C6,FEA
05190:  MOVLW  02
05192:  MOVWF  FEF
....................          MACDiscardRx(); 
05194:  MOVLB  0
05196:  CALL   3070
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
0519A:  MOVLW  12
0519C:  MOVLB  3
0519E:  MOVWF  xC7
....................          goto SendTCPControlPacket; 
051A0:  GOTO   5960
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
051A4:  MOVFF  3C5,FE9
051A8:  MOVFF  3C6,FEA
051AC:  MOVLW  03
051AE:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
051B0:  MOVLW  10
051B2:  MOVWF  xC7
....................  
....................       ps->RemoteWindow = h->Window; 
051B4:  MOVLW  14
051B6:  ADDWF  xC5,W
051B8:  MOVWF  01
051BA:  MOVLW  00
051BC:  ADDWFC xC6,W
051BE:  MOVWF  03
051C0:  MOVWF  xCD
051C2:  MOVLW  0E
051C4:  ADDWF  xB1,W
051C6:  MOVWF  FE9
051C8:  MOVLW  00
051CA:  ADDWFC xB2,W
051CC:  MOVWF  FEA
051CE:  MOVFF  FEC,03
051D2:  MOVF   FED,F
051D4:  MOVFF  FEF,3CE
051D8:  MOVFF  3CD,FEA
051DC:  MOVFF  01,FE9
051E0:  MOVFF  03,FEC
051E4:  MOVF   FED,F
051E6:  MOVFF  3CE,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
051EA:  MOVF   xB3,W
051EC:  IORWF  xB4,W
051EE:  BZ    5224
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
051F0:  MOVLW  23
051F2:  ADDWF  xC5,W
051F4:  MOVWF  FE9
051F6:  MOVLW  00
051F8:  ADDWFC xC6,W
051FA:  MOVWF  FEA
051FC:  BSF    FEF.3
....................          ps->RxCount             = len; 
051FE:  MOVLW  12
05200:  ADDWF  xC5,W
05202:  MOVWF  FE9
05204:  MOVLW  00
05206:  ADDWFC xC6,W
05208:  MOVWF  FEA
0520A:  MOVFF  3B4,FEC
0520E:  MOVF   FED,F
05210:  MOVFF  3B3,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
05214:  MOVLW  23
05216:  ADDWF  xC5,W
05218:  MOVWF  FE9
0521A:  MOVLW  00
0521C:  ADDWFC xC6,W
0521E:  MOVWF  FEA
05220:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
05222:  BRA    522C
....................       { 
....................          MACDiscardRx(); 
05224:  MOVLB  0
05226:  CALL   3070
0522A:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
0522C:  BRA    5960
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
0522E:  MOVFF  3C5,FE9
05232:  MOVFF  3C6,FEA
05236:  MOVF   FEF,F
05238:  BTFSS  FD8.2
0523A:  BRA    53CA
....................    { 
....................       MACDiscardRx(); 
0523C:  MOVLB  0
0523E:  CALL   3070
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
05242:  MOVLW  0D
05244:  MOVLB  3
05246:  ADDWF  xB1,W
05248:  MOVWF  FE9
0524A:  MOVLW  00
0524C:  ADDWFC xB2,W
0524E:  MOVWF  FEA
05250:  BTFSC  FEF.1
05252:  BRA    525A
....................       { 
....................          flags = RST; 
05254:  MOVLW  04
05256:  MOVWF  xC7
....................          goto SendTCPControlPacket; 
05258:  BRA    5960
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
0525A:  MOVLW  1A
0525C:  ADDWF  xC5,W
0525E:  MOVWF  01
05260:  MOVLW  00
05262:  ADDWFC xC6,W
05264:  MOVFF  01,3CC
05268:  MOVWF  xCD
0526A:  MOVLW  04
0526C:  ADDWF  xB1,W
0526E:  MOVWF  FE9
05270:  MOVLW  00
05272:  ADDWFC xB2,W
05274:  MOVWF  FEA
05276:  MOVFF  FEF,3CE
0527A:  MOVFF  FEC,3CF
0527E:  MOVFF  FEC,3D0
05282:  MOVFF  FEC,3D1
05286:  MOVF   xB3,W
05288:  ADDWF  xCE,F
0528A:  MOVF   xB4,W
0528C:  ADDWFC xCF,F
0528E:  MOVLW  00
05290:  ADDWFC xD0,F
05292:  ADDWFC xD1,F
05294:  MOVLW  01
05296:  ADDWF  xCE,W
05298:  MOVWF  00
0529A:  MOVLW  00
0529C:  ADDWFC xCF,W
0529E:  MOVWF  01
052A0:  MOVLW  00
052A2:  ADDWFC xD0,W
052A4:  MOVWF  02
052A6:  MOVLW  00
052A8:  ADDWFC xD1,W
052AA:  MOVFF  3CD,FEA
052AE:  MOVFF  3CC,FE9
052B2:  MOVFF  00,FEF
052B6:  MOVFF  01,FEC
052BA:  MOVFF  02,FEC
052BE:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
052C0:  MOVLW  14
052C2:  ADDWF  xC5,W
052C4:  MOVWF  01
052C6:  MOVLW  00
052C8:  ADDWFC xC6,W
052CA:  MOVWF  03
052CC:  MOVWF  xCD
052CE:  MOVLW  0E
052D0:  ADDWF  xB1,W
052D2:  MOVWF  FE9
052D4:  MOVLW  00
052D6:  ADDWFC xB2,W
052D8:  MOVWF  FEA
052DA:  MOVFF  FEC,03
052DE:  MOVF   FED,F
052E0:  MOVFF  FEF,3CE
052E4:  MOVFF  3CD,FEA
052E8:  MOVFF  01,FE9
052EC:  MOVFF  03,FEC
052F0:  MOVF   FED,F
052F2:  MOVFF  3CE,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
052F6:  MOVLW  01
052F8:  ADDWF  xC5,W
052FA:  MOVWF  xCC
052FC:  MOVLW  00
052FE:  ADDWFC xC6,W
05300:  MOVWF  xCD
05302:  MOVWF  FEA
05304:  MOVFF  3CC,FE9
05308:  MOVFF  3B0,FE2
0530C:  MOVFF  3AF,FE1
05310:  MOVLW  0A
05312:  MOVWF  01
05314:  MOVFF  FE6,FEE
05318:  DECFSZ 01,F
0531A:  BRA    5314
....................       ps->remotePort = h->SourcePort; 
0531C:  MOVLW  0D
0531E:  ADDWF  xC5,W
05320:  MOVWF  01
05322:  MOVLW  00
05324:  ADDWFC xC6,W
05326:  MOVFF  3B1,FE9
0532A:  MOVFF  3B2,FEA
0532E:  MOVFF  FEC,03
05332:  MOVF   FED,F
05334:  MOVFF  FEF,3CE
05338:  MOVWF  FEA
0533A:  MOVFF  01,FE9
0533E:  MOVFF  03,FEC
05342:  MOVF   FED,F
05344:  MOVFF  3CE,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
05348:  MOVFF  3C5,FE9
0534C:  MOVFF  3C6,FEA
05350:  MOVLW  02
05352:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
05354:  MOVLW  16
05356:  ADDWF  xC5,W
05358:  MOVWF  FE9
0535A:  MOVLW  00
0535C:  ADDWFC xC6,W
0535E:  MOVWF  FEA
05360:  MOVFF  FEF,00
05364:  MOVFF  FEC,01
05368:  MOVFF  FEC,02
0536C:  MOVFF  FEC,03
05370:  MOVFF  03,3BC
05374:  MOVFF  02,3BB
05378:  MOVFF  01,3BA
0537C:  MOVFF  00,3B9
....................       ps->SND_SEQ++; 
05380:  MOVLW  16
05382:  ADDWF  xC5,W
05384:  MOVWF  FE9
05386:  MOVLW  00
05388:  ADDWFC xC6,W
0538A:  MOVWF  FEA
0538C:  MOVLW  01
0538E:  ADDWF  FEE,F
05390:  MOVLW  00
05392:  ADDWFC FEE,F
05394:  ADDWFC FEE,F
05396:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
05398:  MOVLW  1A
0539A:  ADDWF  xC5,W
0539C:  MOVWF  FE9
0539E:  MOVLW  00
053A0:  ADDWFC xC6,W
053A2:  MOVWF  FEA
053A4:  MOVFF  FEF,00
053A8:  MOVFF  FEC,01
053AC:  MOVFF  FEC,02
053B0:  MOVFF  FEC,03
053B4:  MOVFF  03,3B8
053B8:  MOVFF  02,3B7
053BC:  MOVFF  01,3B6
053C0:  MOVFF  00,3B5
....................       flags = SYN | ACK; 
053C4:  MOVLW  12
053C6:  MOVWF  xC7
....................       goto SendTCPControlPacket; 
053C8:  BRA    5960
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
053CA:  MOVLW  1A
053CC:  ADDWF  xC5,W
053CE:  MOVWF  FE9
053D0:  MOVLW  00
053D2:  ADDWFC xC6,W
053D4:  MOVWF  FEA
053D6:  MOVFF  FEF,00
053DA:  MOVFF  FEC,01
053DE:  MOVFF  FEC,02
053E2:  MOVFF  FEC,03
053E6:  MOVFF  03,3C0
053EA:  MOVFF  02,3BF
053EE:  MOVFF  01,3BE
053F2:  MOVFF  00,3BD
....................    prevSeq = ps->SND_SEQ; 
053F6:  MOVLW  16
053F8:  ADDWF  xC5,W
053FA:  MOVWF  FE9
053FC:  MOVLW  00
053FE:  ADDWFC xC6,W
05400:  MOVWF  FEA
05402:  MOVFF  FEF,00
05406:  MOVFF  FEC,01
0540A:  MOVFF  FEC,02
0540E:  MOVFF  FEC,03
05412:  MOVFF  03,3C4
05416:  MOVFF  02,3C3
0541A:  MOVFF  01,3C2
0541E:  MOVFF  00,3C1
....................  
....................    ack = h->SeqNumber; 
05422:  MOVLW  04
05424:  ADDWF  xB1,W
05426:  MOVWF  FE9
05428:  MOVLW  00
0542A:  ADDWFC xB2,W
0542C:  MOVWF  FEA
0542E:  MOVFF  FEF,00
05432:  MOVFF  FEC,01
05436:  MOVFF  FEC,02
0543A:  MOVFF  FEC,03
0543E:  MOVFF  03,3B8
05442:  MOVFF  02,3B7
05446:  MOVFF  01,3B6
0544A:  MOVFF  00,3B5
....................    ack += (DWORD)len; 
0544E:  CLRF   02
05450:  CLRF   03
05452:  MOVF   xB3,W
05454:  ADDWF  xB5,F
05456:  MOVF   xB4,W
05458:  ADDWFC xB6,F
0545A:  MOVF   02,W
0545C:  ADDWFC xB7,F
0545E:  MOVF   03,W
05460:  ADDWFC xB8,F
....................    seq = ps->SND_SEQ; 
05462:  MOVLW  16
05464:  ADDWF  xC5,W
05466:  MOVWF  FE9
05468:  MOVLW  00
0546A:  ADDWFC xC6,W
0546C:  MOVWF  FEA
0546E:  MOVFF  FEF,00
05472:  MOVFF  FEC,01
05476:  MOVFF  FEC,02
0547A:  MOVFF  FEC,03
0547E:  MOVFF  03,3BC
05482:  MOVFF  02,3BB
05486:  MOVFF  01,3BA
0548A:  MOVFF  00,3B9
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
0548E:  MOVLW  04
05490:  ADDWF  xB1,W
05492:  MOVWF  FE9
05494:  MOVLW  00
05496:  ADDWFC xB2,W
05498:  MOVWF  FEA
0549A:  MOVFF  FEF,3CC
0549E:  MOVFF  FEC,3CD
054A2:  MOVFF  FEC,3CE
054A6:  MOVFF  FEC,3CF
054AA:  MOVF   xBD,W
054AC:  SUBWF  xCC,W
054AE:  BTFSS  FD8.2
054B0:  BRA    5944
054B2:  MOVF   xBE,W
054B4:  SUBWF  xCD,W
054B6:  BTFSS  FD8.2
054B8:  BRA    5944
054BA:  MOVF   xBF,W
054BC:  SUBWF  xCE,W
054BE:  BTFSS  FD8.2
054C0:  BRA    5944
054C2:  MOVF   xC0,W
054C4:  SUBWF  xCF,W
054C6:  BTFSS  FD8.2
054C8:  BRA    5944
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
054CA:  MOVFF  3C5,FE9
054CE:  MOVFF  3C6,FEA
054D2:  MOVF   FEF,W
054D4:  SUBLW  02
054D6:  BNZ   555E
....................          { 
....................             if(h->Flags.bits.flagACK) 
054D8:  MOVLW  0D
054DA:  ADDWF  xB1,W
054DC:  MOVWF  FE9
054DE:  MOVLW  00
054E0:  ADDWFC xB2,W
054E2:  MOVWF  FEA
054E4:  BTFSS  FEF.4
054E6:  BRA    5554
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
054E8:  MOVLW  1A
054EA:  ADDWF  xC5,W
054EC:  MOVWF  FE9
054EE:  MOVLW  00
054F0:  ADDWFC xC6,W
054F2:  MOVWF  FEA
054F4:  MOVFF  3B5,FEF
054F8:  MOVFF  3B6,FEC
054FC:  MOVFF  3B7,FEC
05500:  MOVFF  3B8,FEC
....................                ps->smState = TCP_ESTABLISHED; 
05504:  MOVFF  3C5,FE9
05508:  MOVFF  3C6,FEA
0550C:  MOVLW  03
0550E:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
05510:  MOVF   xB3,W
05512:  IORWF  xB4,W
05514:  BZ    554A
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
05516:  MOVLW  23
05518:  ADDWF  xC5,W
0551A:  MOVWF  FE9
0551C:  MOVLW  00
0551E:  ADDWFC xC6,W
05520:  MOVWF  FEA
05522:  BSF    FEF.3
....................                   ps->RxCount             = len; 
05524:  MOVLW  12
05526:  ADDWF  xC5,W
05528:  MOVWF  FE9
0552A:  MOVLW  00
0552C:  ADDWFC xC6,W
0552E:  MOVWF  FEA
05530:  MOVFF  3B4,FEC
05534:  MOVF   FED,F
05536:  MOVFF  3B3,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
0553A:  MOVLW  23
0553C:  ADDWF  xC5,W
0553E:  MOVWF  FE9
05540:  MOVLW  00
05542:  ADDWFC xC6,W
05544:  MOVWF  FEA
05546:  BSF    FEF.2
....................                } 
....................                else 
05548:  BRA    5552
....................                   MACDiscardRx(); 
0554A:  MOVLB  0
0554C:  CALL   3070
05550:  MOVLB  3
....................             } 
....................             else   // No ACK to our SYN 
05552:  BRA    555C
....................             { 
....................                MACDiscardRx(); 
05554:  MOVLB  0
05556:  CALL   3070
0555A:  MOVLB  3
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
0555C:  BRA    5942
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
0555E:  MOVLW  1A
05560:  ADDWF  xC5,W
05562:  MOVWF  FE9
05564:  MOVLW  00
05566:  ADDWFC xC6,W
05568:  MOVWF  FEA
0556A:  MOVFF  3B5,FEF
0556E:  MOVFF  3B6,FEC
05572:  MOVFF  3B7,FEC
05576:  MOVFF  3B8,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
0557A:  MOVFF  3C5,FE9
0557E:  MOVFF  3C6,FEA
05582:  MOVF   FEF,W
05584:  SUBLW  03
05586:  BTFSS  FD8.2
05588:  BRA    5754
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
0558A:  MOVLW  0D
0558C:  ADDWF  xB1,W
0558E:  MOVWF  FE9
05590:  MOVLW  00
05592:  ADDWFC xB2,W
05594:  MOVWF  FEA
05596:  BTFSS  FEF.4
05598:  BRA    55F6
0559A:  MOVLW  23
0559C:  ADDWF  xC5,W
0559E:  MOVWF  FE9
055A0:  MOVLW  00
055A2:  ADDWFC xC6,W
055A4:  MOVWF  FEA
055A6:  BTFSC  FEF.1
055A8:  BRA    55F6
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
055AA:  MOVLW  0F
055AC:  ADDWF  xC5,W
055AE:  MOVWF  FE9
055B0:  MOVLW  00
055B2:  ADDWFC xC6,W
055B4:  MOVWF  FEA
055B6:  INCFSZ FEF,W
055B8:  BRA    55BC
055BA:  BRA    55F6
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
055BC:  MOVLW  0F
055BE:  ADDWF  xC5,W
055C0:  MOVWF  FE9
055C2:  MOVLW  00
055C4:  ADDWFC xC6,W
055C6:  MOVWF  FEA
055C8:  MOVFF  FEF,3CC
055CC:  MOVFF  3CC,3CF
055D0:  MOVLB  0
055D2:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
055D6:  MOVLW  0F
055D8:  MOVLB  3
055DA:  ADDWF  xC5,W
055DC:  MOVWF  FE9
055DE:  MOVLW  00
055E0:  ADDWFC xC6,W
055E2:  MOVWF  FEA
055E4:  MOVLW  FF
055E6:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
055E8:  MOVLW  23
055EA:  ADDWF  xC5,W
055EC:  MOVWF  FE9
055EE:  MOVLW  00
055F0:  ADDWFC xC6,W
055F2:  MOVWF  FEA
055F4:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
055F6:  MOVLW  0D
055F8:  ADDWF  xB1,W
055FA:  MOVWF  FE9
055FC:  MOVLW  00
055FE:  ADDWFC xB2,W
05600:  MOVWF  FEA
05602:  BTFSS  FEF.0
05604:  BRA    56BC
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
05606:  MOVLW  11
05608:  MOVWF  xC7
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
0560A:  MOVLW  16
0560C:  ADDWF  xC5,W
0560E:  MOVWF  FE9
05610:  MOVLW  00
05612:  ADDWFC xC6,W
05614:  MOVWF  FEA
05616:  MOVFF  FEF,00
0561A:  MOVFF  FEC,01
0561E:  MOVFF  FEC,02
05622:  MOVFF  FEC,03
05626:  MOVFF  03,3BC
0562A:  MOVFF  02,3BB
0562E:  MOVFF  01,3BA
05632:  MOVFF  00,3B9
....................                   ps->SND_SEQ++; 
05636:  MOVLW  16
05638:  ADDWF  xC5,W
0563A:  MOVWF  FE9
0563C:  MOVLW  00
0563E:  ADDWFC xC6,W
05640:  MOVWF  FEA
05642:  MOVLW  01
05644:  ADDWF  FEE,F
05646:  MOVLW  00
05648:  ADDWFC FEE,F
0564A:  ADDWFC FEE,F
0564C:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
0564E:  MOVLW  1A
05650:  ADDWF  xC5,W
05652:  MOVWF  FE9
05654:  MOVLW  00
05656:  ADDWFC xC6,W
05658:  MOVWF  FEA
0565A:  MOVLW  01
0565C:  ADDWF  FEF,W
0565E:  MOVWF  00
05660:  MOVLW  00
05662:  ADDWFC FEC,W
05664:  MOVWF  01
05666:  MOVLW  00
05668:  ADDWFC FEC,W
0566A:  MOVWF  02
0566C:  MOVLW  00
0566E:  ADDWFC FEC,W
05670:  MOVF   FED,F
05672:  MOVF   FED,F
05674:  MOVF   FED,F
05676:  MOVFF  00,FEF
0567A:  MOVFF  01,FEC
0567E:  MOVFF  02,FEC
05682:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
05684:  MOVLW  1A
05686:  ADDWF  xC5,W
05688:  MOVWF  FE9
0568A:  MOVLW  00
0568C:  ADDWFC xC6,W
0568E:  MOVWF  FEA
05690:  MOVFF  FEF,00
05694:  MOVFF  FEC,01
05698:  MOVFF  FEC,02
0569C:  MOVFF  FEC,03
056A0:  MOVFF  03,3B8
056A4:  MOVFF  02,3B7
056A8:  MOVFF  01,3B6
056AC:  MOVFF  00,3B5
....................                   ps->smState = TCP_LAST_ACK; 
056B0:  MOVFF  3C5,FE9
056B4:  MOVFF  3C6,FEA
056B8:  MOVLW  09
056BA:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
056BC:  MOVF   xB3,W
056BE:  IORWF  xB4,W
056C0:  BZ    574A
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
056C2:  MOVLW  23
056C4:  ADDWF  xC5,W
056C6:  MOVWF  FE9
056C8:  MOVLW  00
056CA:  ADDWFC xC6,W
056CC:  MOVWF  FEA
056CE:  BTFSC  FEF.3
056D0:  BRA    5708
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
056D2:  MOVLW  23
056D4:  ADDWF  xC5,W
056D6:  MOVWF  FE9
056D8:  MOVLW  00
056DA:  ADDWFC xC6,W
056DC:  MOVWF  FEA
056DE:  BSF    FEF.3
....................                      ps->RxCount             = len; 
056E0:  MOVLW  12
056E2:  ADDWF  xC5,W
056E4:  MOVWF  FE9
056E6:  MOVLW  00
056E8:  ADDWFC xC6,W
056EA:  MOVWF  FEA
056EC:  MOVFF  3B4,FEC
056F0:  MOVF   FED,F
056F2:  MOVFF  3B3,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
056F6:  MOVLW  23
056F8:  ADDWF  xC5,W
056FA:  MOVWF  FE9
056FC:  MOVLW  00
056FE:  ADDWFC xC6,W
05700:  MOVWF  FEA
05702:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
05704:  BSF    xC7.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
05706:  BRA    5748
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
05708:  MOVLW  16
0570A:  ADDWF  xC5,W
0570C:  MOVWF  FE9
0570E:  MOVLW  00
05710:  ADDWFC xC6,W
05712:  MOVWF  FEA
05714:  MOVFF  3C1,FEF
05718:  MOVFF  3C2,FEC
0571C:  MOVFF  3C3,FEC
05720:  MOVFF  3C4,FEC
....................                      ps->SND_ACK = prevAck; 
05724:  MOVLW  1A
05726:  ADDWF  xC5,W
05728:  MOVWF  FE9
0572A:  MOVLW  00
0572C:  ADDWFC xC6,W
0572E:  MOVWF  FEA
05730:  MOVFF  3BD,FEF
05734:  MOVFF  3BE,FEC
05738:  MOVFF  3BF,FEC
0573C:  MOVFF  3C0,FEC
....................  
....................                      MACDiscardRx(); 
05740:  MOVLB  0
05742:  CALL   3070
05746:  MOVLB  3
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
05748:  BRA    5752
....................                { 
....................                   MACDiscardRx(); 
0574A:  MOVLB  0
0574C:  CALL   3070
05750:  MOVLB  3
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
05752:  BRA    5942
05754:  MOVFF  3C5,FE9
05758:  MOVFF  3C6,FEA
0575C:  MOVF   FEF,W
0575E:  SUBLW  09
05760:  BNZ   578C
....................             { 
....................                MACDiscardRx(); 
05762:  MOVLB  0
05764:  CALL   3070
....................  
....................                if(h->Flags.bits.flagACK) 
05768:  MOVLW  0D
0576A:  MOVLB  3
0576C:  ADDWF  xB1,W
0576E:  MOVWF  FE9
05770:  MOVLW  00
05772:  ADDWFC xB2,W
05774:  MOVWF  FEA
05776:  BTFSS  FEF.4
05778:  BRA    578A
....................                { 
....................                   CloseSocket(ps); 
0577A:  MOVFF  3C6,3CD
0577E:  MOVFF  3C5,3CC
05782:  MOVLB  0
05784:  CALL   4876
05788:  MOVLB  3
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
0578A:  BRA    5942
0578C:  MOVFF  3C5,FE9
05790:  MOVFF  3C6,FEA
05794:  MOVF   FEF,W
05796:  SUBLW  04
05798:  BNZ   586E
....................             { 
....................                MACDiscardRx(); 
0579A:  MOVLB  0
0579C:  CALL   3070
....................  
....................                if(h->Flags.bits.flagFIN) 
057A0:  MOVLW  0D
057A2:  MOVLB  3
057A4:  ADDWF  xB1,W
057A6:  MOVWF  FE9
057A8:  MOVLW  00
057AA:  ADDWFC xB2,W
057AC:  MOVWF  FEA
057AE:  BTFSS  FEF.0
057B0:  BRA    584C
....................                { 
....................                   flags = ACK; 
057B2:  MOVLW  10
057B4:  MOVWF  xC7
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
057B6:  MOVLW  1A
057B8:  ADDWF  xC5,W
057BA:  MOVWF  FE9
057BC:  MOVLW  00
057BE:  ADDWFC xC6,W
057C0:  MOVWF  FEA
057C2:  MOVLW  01
057C4:  ADDWF  FEF,W
057C6:  MOVWF  00
057C8:  MOVLW  00
057CA:  ADDWFC FEC,W
057CC:  MOVWF  01
057CE:  MOVLW  00
057D0:  ADDWFC FEC,W
057D2:  MOVWF  02
057D4:  MOVLW  00
057D6:  ADDWFC FEC,W
057D8:  MOVF   FED,F
057DA:  MOVF   FED,F
057DC:  MOVF   FED,F
057DE:  MOVFF  00,FEF
057E2:  MOVFF  01,FEC
057E6:  MOVFF  02,FEC
057EA:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
057EC:  MOVLW  1A
057EE:  ADDWF  xC5,W
057F0:  MOVWF  FE9
057F2:  MOVLW  00
057F4:  ADDWFC xC6,W
057F6:  MOVWF  FEA
057F8:  MOVFF  FEF,00
057FC:  MOVFF  FEC,01
05800:  MOVFF  FEC,02
05804:  MOVFF  FEC,03
05808:  MOVFF  03,3B8
0580C:  MOVFF  02,3B7
05810:  MOVFF  01,3B6
05814:  MOVFF  00,3B5
....................                   if(h->Flags.bits.flagACK) 
05818:  MOVLW  0D
0581A:  ADDWF  xB1,W
0581C:  MOVWF  FE9
0581E:  MOVLW  00
05820:  ADDWFC xB2,W
05822:  MOVWF  FEA
05824:  BTFSS  FEF.4
05826:  BRA    583A
....................                   { 
....................                      CloseSocket(ps); 
05828:  MOVFF  3C6,3CD
0582C:  MOVFF  3C5,3CC
05830:  MOVLB  0
05832:  CALL   4876
....................                   } 
....................                   else 
05836:  BRA    5848
05838:  MOVLB  3
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
0583A:  MOVFF  3C5,FE9
0583E:  MOVFF  3C6,FEA
05842:  MOVLW  06
05844:  MOVWF  FEF
05846:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
05848:  BRA    586A
0584A:  MOVLB  3
0584C:  MOVLW  0D
0584E:  ADDWF  xB1,W
05850:  MOVWF  FE9
05852:  MOVLW  00
05854:  ADDWFC xB2,W
05856:  MOVWF  FEA
05858:  BTFSS  FEF.4
0585A:  BRA    5868
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
0585C:  MOVFF  3C5,FE9
05860:  MOVFF  3C6,FEA
05864:  MOVLW  05
05866:  MOVWF  FEF
05868:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
0586A:  BRA    5940
0586C:  MOVLB  3
0586E:  MOVFF  3C5,FE9
05872:  MOVFF  3C6,FEA
05876:  MOVF   FEF,W
05878:  SUBLW  05
0587A:  BNZ   590C
....................             { 
....................                MACDiscardRx(); 
0587C:  MOVLB  0
0587E:  CALL   3070
....................  
....................                if(h->Flags.bits.flagFIN) 
05882:  MOVLW  0D
05884:  MOVLB  3
05886:  ADDWF  xB1,W
05888:  MOVWF  FE9
0588A:  MOVLW  00
0588C:  ADDWFC xB2,W
0588E:  MOVWF  FEA
05890:  BTFSS  FEF.0
05892:  BRA    590A
....................                { 
....................                   flags = ACK; 
05894:  MOVLW  10
05896:  MOVWF  xC7
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
05898:  MOVLW  1A
0589A:  ADDWF  xC5,W
0589C:  MOVWF  FE9
0589E:  MOVLW  00
058A0:  ADDWFC xC6,W
058A2:  MOVWF  FEA
058A4:  MOVLW  01
058A6:  ADDWF  FEF,W
058A8:  MOVWF  00
058AA:  MOVLW  00
058AC:  ADDWFC FEC,W
058AE:  MOVWF  01
058B0:  MOVLW  00
058B2:  ADDWFC FEC,W
058B4:  MOVWF  02
058B6:  MOVLW  00
058B8:  ADDWFC FEC,W
058BA:  MOVF   FED,F
058BC:  MOVF   FED,F
058BE:  MOVF   FED,F
058C0:  MOVFF  00,FEF
058C4:  MOVFF  01,FEC
058C8:  MOVFF  02,FEC
058CC:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
058CE:  MOVLW  1A
058D0:  ADDWF  xC5,W
058D2:  MOVWF  FE9
058D4:  MOVLW  00
058D6:  ADDWFC xC6,W
058D8:  MOVWF  FEA
058DA:  MOVFF  FEF,00
058DE:  MOVFF  FEC,01
058E2:  MOVFF  FEC,02
058E6:  MOVFF  FEC,03
058EA:  MOVFF  03,3B8
058EE:  MOVFF  02,3B7
058F2:  MOVFF  01,3B6
058F6:  MOVFF  00,3B5
....................                   CloseSocket(ps); 
058FA:  MOVFF  3C6,3CD
058FE:  MOVFF  3C5,3CC
05902:  MOVLB  0
05904:  CALL   4876
05908:  MOVLB  3
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
0590A:  BRA    5942
0590C:  MOVFF  3C5,FE9
05910:  MOVFF  3C6,FEA
05914:  MOVF   FEF,W
05916:  SUBLW  06
05918:  BNZ   5942
....................             { 
....................                MACDiscardRx(); 
0591A:  MOVLB  0
0591C:  CALL   3070
....................  
....................                if ( h->Flags.bits.flagACK ) 
05920:  MOVLW  0D
05922:  MOVLB  3
05924:  ADDWF  xB1,W
05926:  MOVWF  FE9
05928:  MOVLW  00
0592A:  ADDWFC xB2,W
0592C:  MOVWF  FEA
0592E:  BTFSS  FEF.4
05930:  BRA    5942
....................                { 
....................                   CloseSocket(ps); 
05932:  MOVFF  3C6,3CD
05936:  MOVFF  3C5,3CC
0593A:  MOVLB  0
0593C:  CALL   4876
05940:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
05942:  BRA    5960
....................       { 
....................          MACDiscardRx(); 
05944:  MOVLB  0
05946:  CALL   3070
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
0594A:  MOVLW  10
0594C:  MOVLB  3
0594E:  MOVWF  xC7
....................          ack = prevAck; 
05950:  MOVFF  3C0,3B8
05954:  MOVFF  3BF,3B7
05958:  MOVFF  3BE,3B6
0595C:  MOVFF  3BD,3B5
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
05960:  MOVF   xC7,F
05962:  BZ    59D8
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
05964:  MOVLW  02
05966:  ADDWF  xB1,W
05968:  MOVWF  FE9
0596A:  MOVLW  00
0596C:  ADDWFC xB2,W
0596E:  MOVWF  FEA
05970:  MOVFF  FEC,3CD
05974:  MOVF   FED,F
05976:  MOVFF  FEF,3CC
0597A:  MOVFF  3B1,FE9
0597E:  MOVFF  3B2,FEA
05982:  MOVFF  FEC,3CF
05986:  MOVF   FED,F
05988:  MOVFF  FEF,3CE
0598C:  MOVFF  3B0,3D4
05990:  MOVFF  3AF,3D3
05994:  MOVFF  3CD,3D6
05998:  MOVFF  3CC,3D5
0599C:  MOVFF  3CF,3D8
059A0:  MOVFF  3CE,3D7
059A4:  MOVFF  3BC,3DC
059A8:  MOVFF  3BB,3DB
059AC:  MOVFF  3BA,3DA
059B0:  MOVFF  3B9,3D9
059B4:  MOVFF  3B8,3E0
059B8:  MOVFF  3B7,3DF
059BC:  MOVFF  3B6,3DE
059C0:  MOVFF  3B5,3DD
059C4:  MOVFF  3C7,3E1
059C8:  MOVLW  FF
059CA:  MOVWF  xE2
059CC:  CLRF   xE4
059CE:  CLRF   xE3
059D0:  MOVLB  0
059D2:  CALL   4CC6
059D6:  MOVLB  3
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
059D8:  MOVLB  0
059DA:  GOTO   5B80 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder		9/9/04	Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder		1/5/06	Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
05C72:  MOVLW  03
05C74:  MOVLB  3
05C76:  MOVWF  xDB
05C78:  MOVLW  8E
05C7A:  MOVFF  3DB,41A
05C7E:  MOVFF  FE8,419
05C82:  MOVLB  4
05C84:  CLRF   x1C
05C86:  MOVLW  08
05C88:  MOVWF  x1B
05C8A:  MOVLB  0
05C8C:  CALL   30DE
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Calculate the checksum using the Microchip MAC's DMA module 
.................... 	// The checksum data includes the precomputed checksum in the 
.................... 	// header, so a valid packet will always have a checksum of 
.................... 	// 0x0000 if the packet is not disturbed. 
.................... 	ReceivedChecksum = 0x0000; 
05C90:  MOVLB  3
05C92:  CLRF   xD9
05C94:  CLRF   xD8
.................... 	CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
05C96:  MOVFF  389,03
05C9A:  MOVFF  388,FE9
05C9E:  MOVFF  389,FEA
05CA2:  MOVFF  FEF,3DA
05CA6:  CLRF   xDC
05CA8:  MOVLW  14
05CAA:  MOVWF  xDB
05CAC:  CLRF   xDE
05CAE:  MOVFF  3DA,3DD
05CB2:  MOVLB  0
05CB4:  CALL   3AA2
05CB8:  MOVFF  02,3D7
05CBC:  MOVFF  01,3D6
.................... #endif 
....................  
.................... 	// Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
05CC0:  MOVLB  3
05CC2:  MOVFF  388,FE9
05CC6:  MOVFF  389,FEA
05CCA:  MOVLW  08
05CCC:  SUBWF  FEF,W
05CCE:  MOVWF  FEF
....................     MACGetArray(data, *len); 
05CD0:  MOVFF  389,03
05CD4:  MOVFF  388,FE9
05CD8:  MOVFF  389,FEA
05CDC:  MOVFF  FEF,3DA
05CE0:  MOVFF  387,41A
05CE4:  MOVFF  386,419
05CE8:  MOVLB  4
05CEA:  CLRF   x1C
05CEC:  MOVFF  3DA,41B
05CF0:  MOVLB  0
05CF2:  CALL   30DE
....................  
....................  
.................... #if !defined(MCHP_MAC) 
.................... 	// Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
05CF6:  MOVLW  03
05CF8:  MOVLB  3
05CFA:  MOVWF  xDB
05CFC:  MOVLW  8E
05CFE:  MOVWF  xDA
05D00:  MOVLB  0
05D02:  RCALL  5B92
....................  
....................     *code = packet.Type; 
05D04:  MOVLB  3
05D06:  MOVFF  384,FE9
05D0A:  MOVFF  385,FEA
05D0E:  MOVFF  38E,FEF
....................     *id = packet.Identifier; 
05D12:  MOVFF  38A,FE9
05D16:  MOVFF  38B,FEA
05D1A:  MOVFF  393,FEC
05D1E:  MOVF   FED,F
05D20:  MOVFF  392,FEF
....................     *seq = packet.SequenceNumber; 
05D24:  MOVFF  38C,FE9
05D28:  MOVFF  38D,FEA
05D2C:  MOVFF  395,FEC
05D30:  MOVF   FED,F
05D32:  MOVFF  394,FEF
....................  
....................     debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
05D36:  MOVF   xD8,W
05D38:  SUBWF  xD6,W
05D3A:  BNZ   5D42
05D3C:  MOVF   xD9,W
05D3E:  SUBWF  xD7,W
05D40:  BZ    5D46
05D42:  MOVLW  00
05D44:  BRA    5D46
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
05D46:  MOVF   xD8,W
05D48:  SUBWF  xD6,W
05D4A:  BNZ   5D52
05D4C:  MOVF   xD9,W
05D4E:  SUBWF  xD7,W
05D50:  BZ    5D56
05D52:  MOVLW  00
05D54:  BRA    5D58
05D56:  MOVLW  01
05D58:  MOVWF  01
.................... } 
05D5A:  MOVLB  0
05D5C:  GOTO   A2C0 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET	packet; 
....................     WORD ICMPLen; 
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
05D60:  MOVLW  01
05D62:  MOVLB  4
05D64:  MOVWF  x0B
05D66:  MOVLB  0
05D68:  CALL   344A
05D6C:  MOVFF  01,3D6
....................  
.................... 	// Abort if there is no where in the Ethernet controller to 
.................... 	// store this packet. 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
05D70:  MOVLB  3
05D72:  INCFSZ xD6,W
05D74:  BRA    5D78
.................... 		return; 
05D76:  BRA    5E76
....................  
.................... 	IPSetTxBuffer(MyTxBuffer, 0); 
05D78:  MOVFF  3D6,424
05D7C:  MOVLB  4
05D7E:  CLRF   x26
05D80:  MOVLW  14
05D82:  MOVWF  x25
05D84:  MOVLB  0
05D86:  CALL   3474
....................  
....................  
.................... 	ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
05D8A:  CLRF   03
05D8C:  MOVLB  3
05D8E:  MOVF   x87,W
05D90:  ADDLW  08
05D92:  MOVWF  xD4
05D94:  MOVLW  00
05D96:  ADDWFC 03,W
05D98:  MOVWF  xD5
....................  
....................     packet.Code             = 0; 
05D9A:  CLRF   x8D
....................     packet.Type             = code; 
05D9C:  MOVFF  384,38C
....................     packet.Checksum         = 0; 
05DA0:  CLRF   x8F
05DA2:  CLRF   x8E
....................     packet.Identifier       = id; 
05DA4:  MOVFF  389,391
05DA8:  MOVFF  388,390
....................     packet.SequenceNumber   = seq; 
05DAC:  MOVFF  38B,393
05DB0:  MOVFF  38A,392
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
05DB4:  MOVLW  03
05DB6:  MOVWF  FEA
05DB8:  MOVLW  94
05DBA:  MOVWF  FE9
05DBC:  MOVFF  386,FE2
05DC0:  MOVFF  385,FE1
05DC4:  MOVF   x87,W
05DC6:  MOVWF  01
05DC8:  BZ    5DD2
05DCA:  MOVFF  FE6,FEE
05DCE:  DECFSZ 01,F
05DD0:  BRA    5DCA
....................  
....................     SwapICMPPacket(&packet); 
05DD2:  MOVLW  03
05DD4:  MOVWF  xDB
05DD6:  MOVLW  8C
05DD8:  MOVWF  xDA
05DDA:  MOVLB  0
05DDC:  RCALL  5B92
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
05DDE:  MOVLW  08
05DE0:  MOVLB  3
05DE2:  ADDWF  x87,W
05DE4:  CLRF   xD8
05DE6:  MOVWF  xD7
05DE8:  MOVFF  383,40C
05DEC:  MOVFF  382,40B
05DF0:  MOVLW  01
05DF2:  MOVLB  4
05DF4:  MOVWF  x0D
05DF6:  MOVFF  3D8,40F
05DFA:  MOVFF  3D7,40E
05DFE:  MOVLB  0
05E00:  CALL   4B96
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
05E04:  MOVLW  03
05E06:  MOVLB  3
05E08:  MOVWF  xD8
05E0A:  MOVLW  8C
05E0C:  MOVFF  3D8,430
05E10:  MOVFF  FE8,42F
05E14:  MOVFF  3D5,432
05E18:  MOVFF  3D4,431
05E1C:  MOVLB  0
05E1E:  CALL   353C
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
.................... 	packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
05E22:  MOVLB  4
05E24:  CLRF   x25
05E26:  MOVLW  14
05E28:  MOVWF  x24
05E2A:  MOVFF  3D5,427
05E2E:  MOVFF  3D4,426
05E32:  MOVLB  0
05E34:  CALL   4ABE
05E38:  MOVFF  02,38F
05E3C:  MOVFF  01,38E
.................... 	IPSetTxBuffer(MyTxBuffer, 2); 
05E40:  MOVFF  3D6,424
05E44:  MOVLB  4
05E46:  CLRF   x26
05E48:  MOVLW  16
05E4A:  MOVWF  x25
05E4C:  MOVLB  0
05E4E:  CALL   3474
.................... 	MACPutArray((BYTE*)&packet.Checksum, 2); 
05E52:  MOVLW  03
05E54:  MOVLB  3
05E56:  MOVWF  xD8
05E58:  MOVLW  8E
05E5A:  MOVFF  3D8,430
05E5E:  MOVFF  FE8,42F
05E62:  MOVLB  4
05E64:  CLRF   x32
05E66:  MOVLW  02
05E68:  MOVWF  x31
05E6A:  MOVLB  0
05E6C:  CALL   353C
.................... #endif 
....................  
....................  
....................     MACFlush(); 
05E70:  CALL   3658
05E74:  MOVLB  3
.................... } 
05E76:  MOVLB  0
05E78:  GOTO   A31E (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
05B92:  MOVLW  04
05B94:  MOVLB  3
05B96:  ADDWF  xDA,W
05B98:  MOVWF  01
05B9A:  MOVLW  00
05B9C:  ADDWFC xDB,W
05B9E:  MOVWF  03
05BA0:  MOVFF  01,3DC
05BA4:  MOVWF  xDD
05BA6:  MOVLW  04
05BA8:  ADDWF  xDA,W
05BAA:  MOVWF  FE9
05BAC:  MOVLW  00
05BAE:  ADDWFC xDB,W
05BB0:  MOVWF  FEA
05BB2:  MOVFF  FEC,3DF
05BB6:  MOVF   FED,F
05BB8:  MOVFF  FEF,3DE
05BBC:  MOVFF  3DF,42B
05BC0:  MOVFF  3DE,42A
05BC4:  MOVLB  0
05BC6:  CALL   3142
05BCA:  MOVFF  3DD,FEA
05BCE:  MOVFF  3DC,FE9
05BD2:  MOVFF  02,FEC
05BD6:  MOVF   FED,F
05BD8:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
05BDC:  MOVLW  06
05BDE:  MOVLB  3
05BE0:  ADDWF  xDA,W
05BE2:  MOVWF  01
05BE4:  MOVLW  00
05BE6:  ADDWFC xDB,W
05BE8:  MOVWF  03
05BEA:  MOVFF  01,3DC
05BEE:  MOVWF  xDD
05BF0:  MOVLW  06
05BF2:  ADDWF  xDA,W
05BF4:  MOVWF  FE9
05BF6:  MOVLW  00
05BF8:  ADDWFC xDB,W
05BFA:  MOVWF  FEA
05BFC:  MOVFF  FEC,3DF
05C00:  MOVF   FED,F
05C02:  MOVFF  FEF,3DE
05C06:  MOVFF  3DF,42B
05C0A:  MOVFF  3DE,42A
05C0E:  MOVLB  0
05C10:  CALL   3142
05C14:  MOVFF  3DD,FEA
05C18:  MOVFF  3DC,FE9
05C1C:  MOVFF  02,FEC
05C20:  MOVF   FED,F
05C22:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
05C26:  MOVLW  02
05C28:  MOVLB  3
05C2A:  ADDWF  xDA,W
05C2C:  MOVWF  01
05C2E:  MOVLW  00
05C30:  ADDWFC xDB,W
05C32:  MOVWF  03
05C34:  MOVFF  01,3DC
05C38:  MOVWF  xDD
05C3A:  MOVLW  02
05C3C:  ADDWF  xDA,W
05C3E:  MOVWF  FE9
05C40:  MOVLW  00
05C42:  ADDWFC xDB,W
05C44:  MOVWF  FEA
05C46:  MOVFF  FEC,3DF
05C4A:  MOVF   FED,F
05C4C:  MOVFF  FEF,3DE
05C50:  MOVFF  3DF,42B
05C54:  MOVFF  3DE,42A
05C58:  MOVLB  0
05C5A:  CALL   3142
05C5E:  MOVFF  3DD,FEA
05C62:  MOVFF  3DC,FE9
05C66:  MOVFF  02,FEC
05C6A:  MOVF   FED,F
05C6C:  MOVFF  01,FEF
.................... } 
05C70:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Darren Rook (CCS)     06/28/04 CCS Port now incorporates 2.20 fixes (above) 
....................  * Darren Rook (CCS)     06/29/04 UDPSocketInfo[] and FindMatching_UDP_Socket() 
....................  *                                no longer static. 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug 
....................  *                         when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets 
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would 
....................  *                         unintentionally keep the remote MAC 
....................  *                         address cached, even after calling 
....................  *                         UDPInit(), UDPClose(), or resetting 
....................  *                         the part without clearing all the 
....................  *                         PICmicro memory. 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
....................  
.................... #if !(STACK_USE_UDP) 
....................  #error do not include UDP.C/UDP.H if STACK_USE_UDP is set to FALSE 
.................... #endif 
....................  
.................... #define debug_udp 
.................... //#define debug_udp debug_printf 
....................  
.................... UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, NODE_INFO *remoteNode, IP_ADDR *localIP); 
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
0155A:  MOVLB  3
0155C:  CLRF   x7C
0155E:  MOVF   x7C,W
01560:  SUBLW  01
01562:  BNC   1572
....................     { 
....................       UDPClose(s); 
01564:  MOVFF  37C,38F
01568:  MOVLB  0
0156A:  RCALL  14DC
....................     } 
0156C:  MOVLB  3
0156E:  INCF   x7C,F
01570:  BRA    155E
.................... } 
01572:  MOVLB  0
01574:  GOTO   1990 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, broadcast node address is set. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A valid port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            This call must always have valid localPort 
....................  *                  value. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................  
....................     p = &UDPSocketInfo[0]; 
*
05E7C:  MOVLB  3
05E7E:  CLRF   x97
05E80:  MOVLW  59
05E82:  MOVWF  x96
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
05E84:  CLRF   x95
05E86:  MOVF   x95,W
05E88:  SUBLW  01
05E8A:  BNC   5F3A
....................     { 
....................         if ( p->localPort == INVALID_UDP_PORT ) 
05E8C:  MOVLW  0C
05E8E:  ADDWF  x96,W
05E90:  MOVWF  FE9
05E92:  MOVLW  00
05E94:  ADDWFC x97,W
05E96:  MOVWF  FEA
05E98:  MOVFF  FEC,399
05E9C:  MOVF   FED,F
05E9E:  MOVFF  FEF,398
05EA2:  MOVF   x98,F
05EA4:  BNZ   5F2E
05EA6:  MOVF   x99,F
05EA8:  BNZ   5F2E
....................         { 
....................             p->localPort    = localPort; 
05EAA:  MOVLW  0C
05EAC:  ADDWF  x96,W
05EAE:  MOVWF  FE9
05EB0:  MOVLW  00
05EB2:  ADDWFC x97,W
05EB4:  MOVWF  FEA
05EB6:  MOVFF  390,FEC
05EBA:  MOVF   FED,F
05EBC:  MOVFF  38F,FEF
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if ( remoteNode ) 
05EC0:  MOVF   x91,W
05EC2:  IORWF  x92,W
05EC4:  BZ    5EEA
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
05EC6:  MOVFF  396,398
05ECA:  MOVFF  397,399
05ECE:  MOVFF  397,FEA
05ED2:  MOVFF  396,FE9
05ED6:  MOVFF  392,FE2
05EDA:  MOVFF  391,FE1
05EDE:  MOVLW  0A
05EE0:  MOVWF  01
05EE2:  MOVFF  FE6,FEE
05EE6:  DECFSZ 01,F
05EE8:  BRA    5EE2
....................             } 
....................             // else Set broadcast address - TO BE DONE */ 
....................  
....................  
....................             p->remotePort   = remotePort; 
05EEA:  MOVLW  0A
05EEC:  ADDWF  x96,W
05EEE:  MOVWF  FE9
05EF0:  MOVLW  00
05EF2:  ADDWFC x97,W
05EF4:  MOVWF  FEA
05EF6:  MOVFF  394,FEC
05EFA:  MOVF   FED,F
05EFC:  MOVFF  393,FEF
....................             p->TxCount      = 0; 
05F00:  MOVLW  0E
05F02:  ADDWF  x96,W
05F04:  MOVWF  FE9
05F06:  MOVLW  00
05F08:  ADDWFC x97,W
05F0A:  MOVWF  FEA
05F0C:  CLRF   FEC
05F0E:  MOVF   FED,F
05F10:  CLRF   FEF
....................             p->RxCount      = 0; 
05F12:  MOVLW  10
05F14:  ADDWF  x96,W
05F16:  MOVWF  FE9
05F18:  MOVLW  00
05F1A:  ADDWFC x97,W
05F1C:  MOVWF  FEA
05F1E:  CLRF   FEC
05F20:  MOVF   FED,F
05F22:  CLRF   FEF
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
05F24:  MOVFF  395,58
....................             return s; 
05F28:  MOVFF  395,01
05F2C:  BRA    5F3E
....................         } 
....................         p++; 
05F2E:  MOVLW  16
05F30:  ADDWF  x96,F
05F32:  BTFSC  FD8.0
05F34:  INCF   x97,F
....................     } 
05F36:  INCF   x95,F
05F38:  BRA    5E86
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
05F3A:  MOVLW  FF
05F3C:  MOVWF  01
.................... } 
05F3E:  MOVLB  0
05F40:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................     UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
*
014DC:  MOVLB  3
014DE:  MOVF   x8F,W
014E0:  MULLW  16
014E2:  MOVF   FF3,W
014E4:  CLRF   x91
014E6:  MOVWF  x90
014E8:  MOVLW  0C
014EA:  ADDWF  x90,W
014EC:  MOVWF  01
014EE:  MOVLW  00
014F0:  ADDWFC x91,W
014F2:  MOVWF  03
014F4:  MOVF   01,W
014F6:  ADDLW  59
014F8:  MOVWF  FE9
014FA:  MOVLW  00
014FC:  ADDWFC 03,W
014FE:  MOVWF  FEA
01500:  CLRF   FEC
01502:  MOVF   FED,F
01504:  CLRF   FEF
....................    UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000; 
01506:  MOVF   x8F,W
01508:  MULLW  16
0150A:  MOVF   FF3,W
0150C:  CLRF   x91
0150E:  MOVWF  x90
01510:  MOVLW  06
01512:  ADDWF  x90,F
01514:  MOVLW  00
01516:  ADDWFC x91,F
01518:  MOVLW  59
0151A:  ADDWF  x90,W
0151C:  MOVWF  FE9
0151E:  MOVLW  00
01520:  ADDWFC x91,W
01522:  MOVWF  FEA
01524:  MOVF   FEE,F
01526:  MOVF   FEE,F
01528:  CLRF   FEC
0152A:  MOVF   FED,F
0152C:  CLRF   FEF
0152E:  MOVF   FED,F
01530:  CLRF   FEF
01532:  MOVF   FED,F
01534:  CLRF   FEF
....................     UDPSocketInfo[s].Flags.bFirstRead = FALSE; 
01536:  MOVF   x8F,W
01538:  MULLW  16
0153A:  MOVF   FF3,W
0153C:  CLRF   x91
0153E:  MOVWF  x90
01540:  MOVLW  15
01542:  ADDWF  x90,F
01544:  MOVLW  00
01546:  ADDWFC x91,F
01548:  MOVLW  59
0154A:  ADDWF  x90,W
0154C:  MOVWF  FE9
0154E:  MOVLW  00
01550:  ADDWFC x91,W
01552:  MOVWF  FEA
01554:  BCF    FEF.0
.................... } 
01556:  MOVLB  0
01558:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................     UDP_SOCKET_INFO *p; 
....................     //WORD temp; 
....................     WORD tempOffset; 
....................     WORD tempCount; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
060AE:  MOVF   58,W
060B0:  MULLW  16
060B2:  MOVF   FF3,W
060B4:  CLRF   03
060B6:  ADDLW  59
060B8:  MOVWF  01
060BA:  MOVLW  00
060BC:  ADDWFC 03,F
060BE:  MOVFF  01,392
060C2:  MOVLB  3
060C4:  MOVFF  03,393
....................  
....................     tempCount=p->TxCount; 
060C8:  MOVLW  0E
060CA:  ADDWF  x92,W
060CC:  MOVWF  FE9
060CE:  MOVLW  00
060D0:  ADDWFC x93,W
060D2:  MOVWF  FEA
060D4:  MOVFF  FEC,03
060D8:  MOVF   FED,F
060DA:  MOVFF  FEF,396
060DE:  MOVFF  03,397
....................  
....................     if ( tempCount == 0 ) 
060E2:  MOVF   x96,F
060E4:  BNZ   6162
060E6:  MOVF   x97,F
060E8:  BNZ   6162
....................     { 
....................         // This is the very first byte that is loaded in UDP buffer. 
....................         // Remember what transmit buffer we are loading, and 
....................         // start loading this and next bytes in data area of UDP packet. 
....................         p->TxBuffer = MACGetTxBuffer(TRUE); 
060EA:  MOVLW  12
060EC:  ADDWF  x92,W
060EE:  MOVWF  01
060F0:  MOVLW  00
060F2:  ADDWFC x93,W
060F4:  MOVWF  03
060F6:  MOVFF  01,398
060FA:  MOVWF  x99
060FC:  MOVLW  01
060FE:  MOVLB  4
06100:  MOVWF  x0B
06102:  MOVLB  0
06104:  CALL   344A
06108:  MOVFF  399,FEA
0610C:  MOVFF  398,FE9
06110:  MOVFF  01,FEF
....................  
....................       // Make sure that we received a TX buffer 
....................       if(p->TxBuffer == INVALID_BUFFER) 
06114:  MOVLW  12
06116:  MOVLB  3
06118:  ADDWF  x92,W
0611A:  MOVWF  FE9
0611C:  MOVLW  00
0611E:  ADDWFC x93,W
06120:  MOVWF  FEA
06122:  INCFSZ FEF,W
06124:  BRA    612C
....................          return FALSE; 
06126:  MOVLW  00
06128:  MOVWF  01
0612A:  BRA    61E8
....................  
....................         IPSetTxBuffer(p->TxBuffer, sizeof(UDP_HEADER)); 
0612C:  MOVLW  12
0612E:  ADDWF  x92,W
06130:  MOVWF  FE9
06132:  MOVLW  00
06134:  ADDWFC x93,W
06136:  MOVWF  FEA
06138:  MOVFF  FEF,398
0613C:  MOVFF  398,424
06140:  MOVLB  4
06142:  CLRF   x26
06144:  MOVLW  1C
06146:  MOVWF  x25
06148:  MOVLB  0
0614A:  CALL   3474
....................  
....................         p->TxOffset = 0; 
0614E:  MOVLW  13
06150:  MOVLB  3
06152:  ADDWF  x92,W
06154:  MOVWF  FE9
06156:  MOVLW  00
06158:  ADDWFC x93,W
0615A:  MOVWF  FEA
0615C:  CLRF   FEC
0615E:  MOVF   FED,F
06160:  CLRF   FEF
....................     } 
....................  
....................     tempOffset=p->TxOffset; 
06162:  MOVLW  13
06164:  ADDWF  x92,W
06166:  MOVWF  FE9
06168:  MOVLW  00
0616A:  ADDWFC x93,W
0616C:  MOVWF  FEA
0616E:  MOVFF  FEC,03
06172:  MOVF   FED,F
06174:  MOVFF  FEF,394
06178:  MOVFF  03,395
....................  
....................    /*if (v>=0x20) 
....................       debug_udp("-%c", v); 
....................    else 
....................       debug_udp("-0x%X", v);*/ 
....................        
....................     // Load it. 
....................     MACPut(v); 
0617C:  MOVFF  391,42E
06180:  MOVLB  0
06182:  CALL   351E
....................  
....................     // Keep track of number of bytes loaded. 
....................     // If total bytes fill up buffer, transmit it. 
....................     if (tempOffset >= tempCount) 
06186:  MOVLB  3
06188:  MOVF   x97,W
0618A:  SUBWF  x95,W
0618C:  BNC   619C
0618E:  BNZ   6196
06190:  MOVF   x96,W
06192:  SUBWF  x94,W
06194:  BNC   619C
....................     { 
....................       tempCount++; 
06196:  INCF   x96,F
06198:  BTFSC  FD8.2
0619A:  INCF   x97,F
....................     } 
....................     tempOffset++; 
0619C:  INCF   x94,F
0619E:  BTFSC  FD8.2
061A0:  INCF   x95,F
....................  
....................     /* //broken in ccs? 
....................     if ( p->TxOffset++ >= p->TxCount ) 
....................     { 
....................         p->TxCount++; 
....................         debug_udp("!"); 
....................     } 
....................     */ 
....................  
....................  
....................  
.................... #define SIZEOF_MAC_HEADER       (14) 
....................  
....................     // Depending on what communication media is used, allowable UDP 
....................     // data length will vary. 
.................... #if STACK_USE_SLIP 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - SIZEOF_MAC_HEADER - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) 
.................... #else 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) ) 
.................... #endif 
....................  
....................    p->TxOffset = tempOffset; 
061A2:  MOVLW  13
061A4:  ADDWF  x92,W
061A6:  MOVWF  FE9
061A8:  MOVLW  00
061AA:  ADDWFC x93,W
061AC:  MOVWF  FEA
061AE:  MOVFF  395,FEC
061B2:  MOVF   FED,F
061B4:  MOVFF  394,FEF
....................  
....................     //temp = p->TxCount; 
....................     //if ( temp >= MAX_UDP_DATA ) 
....................     p->TxCount = tempCount; 
061B8:  MOVLW  0E
061BA:  ADDWF  x92,W
061BC:  MOVWF  FE9
061BE:  MOVLW  00
061C0:  ADDWFC x93,W
061C2:  MOVWF  FEA
061C4:  MOVFF  397,FEC
061C8:  MOVF   FED,F
061CA:  MOVFF  396,FEF
....................     if (tempCount >= MAX_UDP_DATA) 
061CE:  MOVF   x97,W
061D0:  SUBLW  02
061D2:  BC    61E4
061D4:  XORLW  FF
061D6:  BNZ   61DE
061D8:  MOVF   x96,W
061DA:  SUBLW  E3
061DC:  BC    61E4
....................     { 
....................         UDPFlush(); 
061DE:  MOVLB  0
061E0:  RCALL  5F56
061E2:  MOVLB  3
....................     } 
.................... #undef MAX_UDP_DATA 
....................  
....................  
....................     return TRUE; 
061E4:  MOVLW  01
061E6:  MOVWF  01
.................... } 
061E8:  MOVLB  0
061EA:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     // Wait for TX hardware to become available (finish transmitting 
....................     // any previous packet) 
....................     while( !IPIsTxReady(TRUE) ); 
*
05F56:  MOVLW  01
05F58:  MOVLB  4
05F5A:  MOVWF  x0B
05F5C:  MOVLB  0
05F5E:  CALL   497A
05F62:  MOVF   01,F
05F64:  BZ    5F56
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
05F66:  MOVF   58,W
05F68:  MULLW  16
05F6A:  MOVF   FF3,W
05F6C:  CLRF   03
05F6E:  ADDLW  59
05F70:  MOVWF  01
05F72:  MOVLW  00
05F74:  ADDWFC 03,F
05F76:  MOVFF  01,3A0
05F7A:  MOVLB  3
05F7C:  MOVFF  03,3A1
....................  
....................     debug_udp("\r\nUDP FLUSH - Sok:%U TxC:%LU SP:%LU DP:%LU ", 
....................          activeUDPSocket, 
....................          p->TxCount, 
....................          p->localPort, 
....................          p->remotePort 
....................       ); 
....................     debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          p->remoteNode.MACAddr.v[0], 
....................          p->remoteNode.MACAddr.v[1], 
....................          p->remoteNode.MACAddr.v[2], 
....................          p->remoteNode.MACAddr.v[3], 
....................          p->remoteNode.MACAddr.v[4], 
....................          p->remoteNode.MACAddr.v[5] 
....................       ); 
....................  
....................  
....................     h.SourcePort        = swaps(p->localPort); 
05F80:  MOVLW  0C
05F82:  ADDWF  xA0,W
05F84:  MOVWF  FE9
05F86:  MOVLW  00
05F88:  ADDWFC xA1,W
05F8A:  MOVWF  FEA
05F8C:  MOVFF  FEC,3A3
05F90:  MOVF   FED,F
05F92:  MOVFF  FEF,3A2
05F96:  MOVFF  3A3,42B
05F9A:  MOVFF  3A2,42A
05F9E:  MOVLB  0
05FA0:  CALL   3142
05FA4:  MOVFF  02,399
05FA8:  MOVFF  01,398
....................     h.DestinationPort   = swaps(p->remotePort); 
05FAC:  MOVLW  0A
05FAE:  MOVLB  3
05FB0:  ADDWF  xA0,W
05FB2:  MOVWF  FE9
05FB4:  MOVLW  00
05FB6:  ADDWFC xA1,W
05FB8:  MOVWF  FEA
05FBA:  MOVFF  FEC,3A3
05FBE:  MOVF   FED,F
05FC0:  MOVFF  FEF,3A2
05FC4:  MOVFF  3A3,42B
05FC8:  MOVFF  3A2,42A
05FCC:  MOVLB  0
05FCE:  CALL   3142
05FD2:  MOVFF  02,39B
05FD6:  MOVFF  01,39A
....................     h.Length            = (WORD)((WORD)p->TxCount + (WORD)sizeof(UDP_HEADER)); 
05FDA:  MOVLW  0E
05FDC:  MOVLB  3
05FDE:  ADDWF  xA0,W
05FE0:  MOVWF  FE9
05FE2:  MOVLW  00
05FE4:  ADDWFC xA1,W
05FE6:  MOVWF  FEA
05FE8:  MOVFF  FEC,3A3
05FEC:  MOVF   FED,F
05FEE:  MOVFF  FEF,3A2
05FF2:  MOVLW  08
05FF4:  ADDWF  xA2,W
05FF6:  MOVWF  x9C
05FF8:  MOVLW  00
05FFA:  ADDWFC xA3,W
05FFC:  MOVWF  x9D
....................     // Do not swap h.Length yet.  It is needed in IPPutHeader. 
....................     h.Checksum          = 0x0000; 
05FFE:  CLRF   x9F
06000:  CLRF   x9E
....................  
....................     IPSetTxBuffer(p->TxBuffer, 0); 
06002:  MOVLW  12
06004:  ADDWF  xA0,W
06006:  MOVWF  FE9
06008:  MOVLW  00
0600A:  ADDWFC xA1,W
0600C:  MOVWF  FEA
0600E:  MOVFF  FEF,3A2
06012:  MOVFF  3A2,424
06016:  MOVLB  4
06018:  CLRF   x26
0601A:  MOVLW  14
0601C:  MOVWF  x25
0601E:  MOVLB  0
06020:  CALL   3474
....................  
....................     /* 
....................      * Load IP header. 
....................      */ 
....................  
....................     IPPutHeader( &p->remoteNode, 
....................                  IP_PROT_UDP, 
....................                  h.Length ); 
06024:  MOVFF  3A0,01
06028:  MOVFF  3A1,03
0602C:  MOVFF  3A0,3A2
06030:  MOVFF  3A1,3A3
06034:  MOVFF  3A1,40C
06038:  MOVFF  3A0,40B
0603C:  MOVLW  11
0603E:  MOVLB  4
06040:  MOVWF  x0D
06042:  MOVFF  39D,40F
06046:  MOVFF  39C,40E
0604A:  MOVLB  0
0604C:  CALL   4B96
....................  
....................  
....................     // Now swap h.Length. 
....................     h.Length            = swaps(h.Length); 
06050:  MOVFF  39D,42B
06054:  MOVFF  39C,42A
06058:  CALL   3142
0605C:  MOVFF  02,39D
06060:  MOVFF  01,39C
....................  
....................     // Now load UDP header. 
....................     IPPutArray((BYTE*)&h, sizeof(h)); 
06064:  MOVLW  03
06066:  MOVLB  3
06068:  MOVWF  xA3
0606A:  MOVLW  98
0606C:  MOVFF  3A3,430
06070:  MOVFF  FE8,42F
06074:  MOVLB  4
06076:  CLRF   x32
06078:  MOVLW  08
0607A:  MOVWF  x31
0607C:  MOVLB  0
0607E:  CALL   353C
....................  
....................      // Update checksum. 
....................      // TO BE IMPLEMENTED 
....................  
....................     MACFlush(); 
06082:  CALL   3658
....................  
....................     // The buffer was reserved with AutoFree, so we can immediately 
....................    // discard it.  The MAC layer will free it after transmission. 
....................     p->TxBuffer         = INVALID_BUFFER; 
06086:  MOVLW  12
06088:  MOVLB  3
0608A:  ADDWF  xA0,W
0608C:  MOVWF  FE9
0608E:  MOVLW  00
06090:  ADDWFC xA1,W
06092:  MOVWF  FEA
06094:  MOVLW  FF
06096:  MOVWF  FEF
....................     p->TxCount          = 0; 
06098:  MOVLW  0E
0609A:  ADDWF  xA0,W
0609C:  MOVWF  FE9
0609E:  MOVLW  00
060A0:  ADDWFC xA1,W
060A2:  MOVWF  FEA
060A4:  CLRF   FEC
060A6:  MOVF   FED,F
060A8:  CLRF   FEF
....................  
.................... } 
060AA:  MOVLB  0
060AC:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
09690:  MOVFF  38F,58
....................     return ( UDPSocketInfo[activeUDPSocket].RxCount > 0); 
09694:  MOVF   58,W
09696:  MULLW  16
09698:  MOVF   FF3,W
0969A:  MOVLB  3
0969C:  CLRF   x91
0969E:  MOVWF  x90
096A0:  MOVLW  10
096A2:  ADDWF  x90,W
096A4:  MOVWF  01
096A6:  MOVLW  00
096A8:  ADDWFC x91,W
096AA:  MOVWF  03
096AC:  MOVF   01,W
096AE:  ADDLW  59
096B0:  MOVWF  FE9
096B2:  MOVLW  00
096B4:  ADDWFC 03,W
096B6:  MOVWF  FEA
096B8:  MOVFF  FEC,391
096BC:  MOVF   FED,F
096BE:  MOVFF  FEF,390
096C2:  MOVF   x90,F
096C4:  BNZ   96CE
096C6:  MOVF   x91,F
096C8:  BNZ   96CE
096CA:  MOVLW  00
096CC:  BRA    96D0
096CE:  MOVLW  01
096D0:  MOVWF  01
.................... } 
096D2:  MOVLB  0
096D4:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................     // CALLER MUST MAKE SURE THAT THERE IS ENOUGH DATA BYTE IN BUFFER 
....................     // BEFORE CALLING THIS FUNCTION. 
....................     // USE UDPIsGetReady() TO CONFIRM. 
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
096D6:  MOVF   58,W
096D8:  MULLW  16
096DA:  MOVF   FF3,W
096DC:  MOVLB  3
096DE:  CLRF   x9B
096E0:  MOVWF  x9A
096E2:  MOVLW  10
096E4:  ADDWF  x9A,W
096E6:  MOVWF  01
096E8:  MOVLW  00
096EA:  ADDWFC x9B,W
096EC:  MOVWF  03
096EE:  MOVF   01,W
096F0:  ADDLW  59
096F2:  MOVWF  FE9
096F4:  MOVLW  00
096F6:  ADDWFC 03,W
096F8:  MOVWF  FEA
096FA:  MOVFF  FEC,39B
096FE:  MOVF   FED,F
09700:  MOVFF  FEF,39A
09704:  MOVF   x9A,F
09706:  BNZ   9712
09708:  MOVF   x9B,F
0970A:  BNZ   9712
....................         return FALSE; 
0970C:  MOVLW  00
0970E:  MOVWF  01
09710:  BRA    97EC
....................  
....................     // If if this very first read to packet, set MAC Rx Pointer to 
....................     // beginig of UDP data area. 
....................     if ( UDPSocketInfo[activeUDPSocket].Flags.bFirstRead ) 
09712:  MOVF   58,W
09714:  MULLW  16
09716:  MOVF   FF3,W
09718:  CLRF   x9B
0971A:  MOVWF  x9A
0971C:  MOVLW  15
0971E:  ADDWF  x9A,F
09720:  MOVLW  00
09722:  ADDWFC x9B,F
09724:  MOVLW  59
09726:  ADDWF  x9A,W
09728:  MOVWF  FE9
0972A:  MOVLW  00
0972C:  ADDWFC x9B,W
0972E:  MOVWF  FEA
09730:  BTFSS  FEF.0
09732:  BRA    9760
....................     { 
....................         UDPSocketInfo[activeUDPSocket].Flags.bFirstRead = FALSE; 
09734:  MOVF   58,W
09736:  MULLW  16
09738:  MOVF   FF3,W
0973A:  CLRF   x9B
0973C:  MOVWF  x9A
0973E:  MOVLW  15
09740:  ADDWF  x9A,F
09742:  MOVLW  00
09744:  ADDWFC x9B,F
09746:  MOVLW  59
09748:  ADDWF  x9A,W
0974A:  MOVWF  FE9
0974C:  MOVLW  00
0974E:  ADDWFC x9B,W
09750:  MOVWF  FEA
09752:  BCF    FEF.0
....................         UDPSetRxBuffer(0); 
09754:  CLRF   xB0
09756:  MOVLW  08
09758:  MOVWF  xAF
0975A:  MOVLB  0
0975C:  CALL   3EEA
....................     } 
....................  
....................     *v = MACGet(); 
09760:  MOVFF  399,03
09764:  MOVFF  398,39A
09768:  MOVFF  399,39B
0976C:  MOVLB  0
0976E:  CALL   3F04
09772:  MOVFF  39B,FEA
09776:  MOVFF  39A,FE9
0977A:  MOVFF  01,FEF
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount--; 
0977E:  MOVF   58,W
09780:  MULLW  16
09782:  MOVF   FF3,W
09784:  MOVLB  3
09786:  CLRF   x9B
09788:  MOVWF  x9A
0978A:  MOVLW  10
0978C:  ADDWF  x9A,W
0978E:  MOVWF  01
09790:  MOVLW  00
09792:  ADDWFC x9B,W
09794:  MOVWF  03
09796:  MOVF   01,W
09798:  ADDLW  59
0979A:  MOVWF  FE9
0979C:  MOVLW  00
0979E:  ADDWFC 03,W
097A0:  MOVWF  FEA
097A2:  MOVLW  FF
097A4:  ADDWF  FEF,F
097A6:  BC    97AC
097A8:  MOVF   FEE,F
097AA:  DECF   FED,F
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
097AC:  MOVF   58,W
097AE:  MULLW  16
097B0:  MOVF   FF3,W
097B2:  CLRF   x9B
097B4:  MOVWF  x9A
097B6:  MOVLW  10
097B8:  ADDWF  x9A,W
097BA:  MOVWF  01
097BC:  MOVLW  00
097BE:  ADDWFC x9B,W
097C0:  MOVWF  03
097C2:  MOVF   01,W
097C4:  ADDLW  59
097C6:  MOVWF  FE9
097C8:  MOVLW  00
097CA:  ADDWFC 03,W
097CC:  MOVWF  FEA
097CE:  MOVFF  FEC,39B
097D2:  MOVF   FED,F
097D4:  MOVFF  FEF,39A
097D8:  MOVF   x9A,F
097DA:  BNZ   97E8
097DC:  MOVF   x9B,F
097DE:  BNZ   97E8
....................     { 
....................         MACDiscardRx(); 
097E0:  MOVLB  0
097E2:  CALL   3070
097E6:  MOVLB  3
....................     } 
....................  
....................     return TRUE; 
097E8:  MOVLW  01
097EA:  MOVWF  01
.................... } 
097EC:  MOVLB  0
097EE:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount ) 
097F0:  MOVF   58,W
097F2:  MULLW  16
097F4:  MOVF   FF3,W
097F6:  MOVLB  3
097F8:  CLRF   x99
097FA:  MOVWF  x98
097FC:  MOVLW  10
097FE:  ADDWF  x98,W
09800:  MOVWF  01
09802:  MOVLW  00
09804:  ADDWFC x99,W
09806:  MOVWF  03
09808:  MOVF   01,W
0980A:  ADDLW  59
0980C:  MOVWF  FE9
0980E:  MOVLW  00
09810:  ADDWFC 03,W
09812:  MOVWF  FEA
09814:  MOVF   FEF,F
09816:  BNZ   981C
09818:  MOVF   FEC,F
0981A:  BZ    9824
....................         MACDiscardRx(); 
0981C:  MOVLB  0
0981E:  CALL   3070
09822:  MOVLB  3
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount = 0; 
09824:  MOVF   58,W
09826:  MULLW  16
09828:  MOVF   FF3,W
0982A:  CLRF   x99
0982C:  MOVWF  x98
0982E:  MOVLW  10
09830:  ADDWF  x98,W
09832:  MOVWF  01
09834:  MOVLW  00
09836:  ADDWFC x99,W
09838:  MOVWF  03
0983A:  MOVF   01,W
0983C:  ADDLW  59
0983E:  MOVWF  FE9
09840:  MOVLW  00
09842:  ADDWFC 03,W
09844:  MOVWF  FEA
09846:  CLRF   FEC
09848:  MOVF   FED,F
0984A:  CLRF   FEF
.................... } 
0984C:  MOVLB  0
0984E:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... /* 
....................  * Pseudo header as defined by rfc 793. 
....................  */ 
.................... typedef struct _UDP_PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } UDP_PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER h; 
....................     UDP_SOCKET s; 
....................     UDP_PSEUDO_HEADER pseudoHeader; 
....................     WORD_VAL   checksum; 
....................  
....................     /* 
....................      * Retrieve UDP header. 
....................      */ 
....................     //MACGetArray((BYTE*)&h, sizeof(h)); 
....................     MACGetArray(&h, sizeof(UDP_HEADER)); 
*
0422C:  MOVLW  03
0422E:  MOVLB  4
04230:  MOVWF  x1A
04232:  MOVLW  88
04234:  MOVWF  x19
04236:  CLRF   x1C
04238:  MOVLW  08
0423A:  MOVWF  x1B
0423C:  MOVLB  0
0423E:  CALL   30DE
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
04242:  MOVFF  389,42B
04246:  MOVFF  388,42A
0424A:  CALL   3142
0424E:  MOVFF  02,389
04252:  MOVFF  01,388
....................     h.DestinationPort   = swaps(h.DestinationPort); 
04256:  MOVFF  38B,42B
0425A:  MOVFF  38A,42A
0425E:  CALL   3142
04262:  MOVFF  02,38B
04266:  MOVFF  01,38A
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
0426A:  MOVFF  38D,42B
0426E:  MOVFF  38C,42A
04272:  CALL   3142
04276:  MOVLW  08
04278:  MOVLB  3
0427A:  SUBWF  01,W
0427C:  MOVWF  x8C
0427E:  MOVLW  00
04280:  SUBWFB 02,W
04282:  MOVWF  x8D
....................  
....................       debug_udp("\r\nUDP PROCESS SP=%LX DP=%LX PAYLOAD=%LX ", 
....................             h.SourcePort, 
....................             h.DestinationPort, 
....................             h.Length 
....................          ); 
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
04284:  MOVF   x8E,W
04286:  IORWF  x8F,W
04288:  BTFSC  FD8.2
0428A:  BRA    43B0
....................    { 
....................        h.Checksum          = swaps(h.Checksum); 
0428C:  MOVFF  38F,42B
04290:  MOVFF  38E,42A
04294:  MOVLB  0
04296:  CALL   3142
0429A:  MOVFF  02,38F
0429E:  MOVFF  01,38E
....................  
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
042A2:  MOVLW  06
042A4:  MOVLB  3
042A6:  ADDWF  x82,W
042A8:  MOVWF  FE9
042AA:  MOVLW  00
042AC:  ADDWFC x83,W
042AE:  MOVWF  FEA
042B0:  MOVFF  FEF,00
042B4:  MOVFF  FEC,01
042B8:  MOVFF  FEC,02
042BC:  MOVFF  FEC,03
042C0:  MOVFF  03,394
042C4:  MOVFF  02,393
042C8:  MOVFF  01,392
042CC:  MOVFF  00,391
....................        pseudoHeader.DestAddress.v[0]   = localIP->v[0]; 
042D0:  MOVFF  384,FE9
042D4:  MOVFF  385,FEA
042D8:  MOVFF  FEF,395
....................        pseudoHeader.DestAddress.v[1]   = localIP->v[1]; 
042DC:  MOVLW  01
042DE:  ADDWF  x84,W
042E0:  MOVWF  FE9
042E2:  MOVLW  00
042E4:  ADDWFC x85,W
042E6:  MOVWF  FEA
042E8:  MOVFF  FEF,396
....................        pseudoHeader.DestAddress.v[2]   = localIP->v[2]; 
042EC:  MOVLW  02
042EE:  ADDWF  x84,W
042F0:  MOVWF  FE9
042F2:  MOVLW  00
042F4:  ADDWFC x85,W
042F6:  MOVWF  FEA
042F8:  MOVFF  FEF,397
....................        pseudoHeader.DestAddress.v[3]   = localIP->v[3]; 
042FC:  MOVLW  03
042FE:  ADDWF  x84,W
04300:  MOVWF  FE9
04302:  MOVLW  00
04304:  ADDWFC x85,W
04306:  MOVWF  FEA
04308:  MOVFF  FEF,398
....................        pseudoHeader.Zero               = 0x0; 
0430C:  CLRF   x99
....................        pseudoHeader.Protocol           = IP_PROT_UDP; 
0430E:  MOVLW  11
04310:  MOVWF  x9A
....................        pseudoHeader.Length             = len; 
04312:  MOVFF  387,39C
04316:  MOVFF  386,39B
....................  
....................        SwapPseudoHeader(pseudoHeader); 
0431A:  MOVFF  39C,42B
0431E:  MOVFF  39B,42A
04322:  MOVLB  0
04324:  CALL   3142
04328:  MOVFF  02,39C
0432C:  MOVFF  01,39B
....................  
....................        checksum.Val = ~CalcIPChecksum(&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
04330:  MOVLW  03
04332:  MOVLB  4
04334:  MOVWF  x0E
04336:  MOVLW  91
04338:  MOVWF  x0D
0433A:  CLRF   x10
0433C:  MOVLW  0C
0433E:  MOVWF  x0F
04340:  MOVLB  0
04342:  RCALL  3DFC
04344:  MOVFF  01,39D
04348:  MOVLB  3
0434A:  COMF   x9D,F
0434C:  MOVFF  02,39E
04350:  COMF   x9E,F
....................  
....................  
....................        // Set UDP packet checksum = pseudo header checksum in MAC RAM. 
....................        IPSetRxBuffer(6); 
04352:  CLRF   xB0
04354:  MOVLW  06
04356:  MOVWF  xAF
04358:  MOVLB  0
0435A:  RCALL  3EEA
....................        MACPut(checksum.v[0]); 
0435C:  MOVFF  39D,42E
04360:  CALL   351E
....................       // In case if the end of the RX buffer is reached and a wraparound is needed, set the next address to prevent writing to the wrong address. 
....................        IPSetRxBuffer(7); 
04364:  MOVLB  3
04366:  CLRF   xB0
04368:  MOVLW  07
0436A:  MOVWF  xAF
0436C:  MOVLB  0
0436E:  RCALL  3EEA
....................        MACPut(checksum.v[1]); 
04370:  MOVFF  39E,42E
04374:  CALL   351E
....................        IPSetRxBuffer(0); 
04378:  MOVLB  3
0437A:  CLRF   xB0
0437C:  CLRF   xAF
0437E:  MOVLB  0
04380:  RCALL  3EEA
....................  
....................        // Now calculate UDP packet checksum in NIC RAM - including 
....................        // pesudo header. 
....................        checksum.Val = CalcIPBufferChecksum(len); 
04382:  MOVFF  387,40C
04386:  MOVFF  386,40B
0438A:  RCALL  3F30
0438C:  MOVFF  02,39E
04390:  MOVFF  01,39D
....................  
....................        if ( checksum.Val != h.Checksum ) 
04394:  MOVLB  3
04396:  MOVF   x8E,W
04398:  SUBWF  x9D,W
0439A:  BNZ   43A2
0439C:  MOVF   x8F,W
0439E:  SUBWF  x9E,W
043A0:  BZ    43B0
....................        { 
....................            debug_udp("INVALID-CS "); 
....................            MACDiscardRx(); 
043A2:  MOVLB  0
043A4:  CALL   3070
....................            return TRUE; 
043A8:  MOVLW  01
043AA:  MOVWF  01
043AC:  BRA    4432
043AE:  MOVLB  3
....................        } 
....................    } 
....................  
....................     s = FindMatching_UDP_Socket(&h, remoteNode, localIP); 
043B0:  MOVLW  03
043B2:  MOVWF  xA0
043B4:  MOVLW  88
043B6:  MOVWF  x9F
043B8:  MOVFF  383,3A2
043BC:  MOVFF  382,3A1
043C0:  MOVFF  385,3A4
043C4:  MOVFF  384,3A3
043C8:  MOVLB  0
043CA:  BRA    4088
043CC:  MOVFF  01,390
....................     if ( s == INVALID_UDP_SOCKET ) 
043D0:  MOVLB  3
043D2:  INCFSZ x90,W
043D4:  BRA    43E0
....................     { 
....................         /* 
....................          * If there is no matching socket, There is no one to handle 
....................          * this data.  Discard it. 
....................          */ 
....................         debug_udp("INVALID-SOCKET "); 
....................         MACDiscardRx(); 
043D6:  MOVLB  0
043D8:  CALL   3070
....................     } 
....................     else { 
043DC:  BRA    442E
043DE:  MOVLB  3
....................         UDPSocketInfo[s].RxCount = h.Length; 
043E0:  MOVF   x90,W
043E2:  MULLW  16
043E4:  MOVF   FF3,W
043E6:  CLRF   xA0
043E8:  MOVWF  x9F
043EA:  MOVLW  10
043EC:  ADDWF  x9F,W
043EE:  MOVWF  01
043F0:  MOVLW  00
043F2:  ADDWFC xA0,W
043F4:  MOVWF  03
043F6:  MOVF   01,W
043F8:  ADDLW  59
043FA:  MOVWF  FE9
043FC:  MOVLW  00
043FE:  ADDWFC 03,W
04400:  MOVWF  FEA
04402:  MOVFF  38D,FEC
04406:  MOVF   FED,F
04408:  MOVFF  38C,FEF
....................         UDPSocketInfo[s].Flags.bFirstRead = TRUE; 
0440C:  MOVF   x90,W
0440E:  MULLW  16
04410:  MOVF   FF3,W
04412:  CLRF   xA0
04414:  MOVWF  x9F
04416:  MOVLW  15
04418:  ADDWF  x9F,F
0441A:  MOVLW  00
0441C:  ADDWFC xA0,F
0441E:  MOVLW  59
04420:  ADDWF  x9F,W
04422:  MOVWF  FE9
04424:  MOVLW  00
04426:  ADDWFC xA0,W
04428:  MOVWF  FEA
0442A:  BSF    FEF.0
0442C:  MOVLB  0
....................  
....................     debug_udp("MATCH AS:%U ", s); 
....................     /*debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          remoteNode->MACAddr.v[0], 
....................          remoteNode->MACAddr.v[1], 
....................          remoteNode->MACAddr.v[2], 
....................          remoteNode->MACAddr.v[3], 
....................          remoteNode->MACAddr.v[4], 
....................          remoteNode->MACAddr.v[5] 
....................       );*/ 
....................     } 
....................  
....................     return TRUE; 
0442E:  MOVLW  01
04430:  MOVWF  01
.................... } 
04432:  GOTO   A242 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, 
....................  *                                NODE_INFO *remoteNode, 
....................  *                                IP_ADDR *localIP) 
....................  * 
....................  * PreCondition:    UDP Segment header has been retrieved from buffer 
....................  *                  The IP header has also been retrieved 
....................  * 
....................  * Input:           remoteNode      - Remote node info from IP header 
....................  *                  h               - header of UDP semgent. 
....................  * 
....................  * Output:          matching UDP socket or INVALID_UDP_SOCKET 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define BROADCAST_ADDRESS   (0xffffffffL) 
.................... static UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET partialMatch; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     partialMatch = INVALID_UDP_SOCKET; 
*
04088:  MOVLW  FF
0408A:  MOVLB  3
0408C:  MOVWF  xA6
....................  
....................     p = UDPSocketInfo; 
0408E:  CLRF   xA8
04090:  MOVLW  59
04092:  MOVWF  xA7
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
04094:  CLRF   xA5
04096:  MOVF   xA5,W
04098:  SUBLW  01
0409A:  BTFSS  FD8.0
0409C:  BRA    41B0
....................     { 
....................         /* 
....................          * This packet is said to be matching with current socket 
....................          * 1. If its destination port matches with our local port. 
....................          * 2. This socket does not have any data pending. 
....................          * 3. Packet source IP address matches with socket remote IP address. 
....................          *    OR this socket had transmitted packet with destination address 
....................          *       as broadcast. 
....................          */ 
....................         if ( p->localPort == h->DestinationPort ) 
0409E:  MOVLW  0C
040A0:  ADDWF  xA7,W
040A2:  MOVWF  FE9
040A4:  MOVLW  00
040A6:  ADDWFC xA8,W
040A8:  MOVWF  FEA
040AA:  MOVFF  FEC,3AA
040AE:  MOVF   FED,F
040B0:  MOVFF  FEF,3A9
040B4:  MOVLW  02
040B6:  ADDWF  x9F,W
040B8:  MOVWF  FE9
040BA:  MOVLW  00
040BC:  ADDWFC xA0,W
040BE:  MOVWF  FEA
040C0:  MOVFF  FEC,03
040C4:  MOVF   FED,F
040C6:  MOVF   FEF,W
040C8:  SUBWF  xA9,W
040CA:  BTFSS  FD8.2
040CC:  BRA    41A4
040CE:  MOVF   03,W
040D0:  SUBWF  xAA,W
040D2:  BNZ   41A4
....................         { 
....................             if ( (p->remotePort == h->SourcePort) && (p->RxCount == 0L) ) 
040D4:  MOVLW  0A
040D6:  ADDWF  xA7,W
040D8:  MOVWF  FE9
040DA:  MOVLW  00
040DC:  ADDWFC xA8,W
040DE:  MOVWF  FEA
040E0:  MOVFF  FEC,3AA
040E4:  MOVF   FED,F
040E6:  MOVFF  FEF,3A9
040EA:  MOVFF  39F,FE9
040EE:  MOVFF  3A0,FEA
040F2:  MOVFF  FEC,03
040F6:  MOVF   FED,F
040F8:  MOVF   FEF,W
040FA:  SUBWF  xA9,W
040FC:  BNZ   41A0
040FE:  MOVF   03,W
04100:  SUBWF  xAA,W
04102:  BNZ   41A0
04104:  MOVLW  10
04106:  ADDWF  xA7,W
04108:  MOVWF  FE9
0410A:  MOVLW  00
0410C:  ADDWFC xA8,W
0410E:  MOVWF  FEA
04110:  MOVFF  FEC,3AA
04114:  MOVF   FED,F
04116:  MOVFF  FEF,3A9
0411A:  MOVF   xA9,F
0411C:  BNZ   41A0
0411E:  MOVF   xAA,F
04120:  BNZ   41A0
....................             { 
....................                 if ( (p->remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) || 
....................                      (localIP->Val == BROADCAST_ADDRESS) ) 
04122:  MOVLW  06
04124:  ADDWF  xA7,W
04126:  MOVWF  FE9
04128:  MOVLW  00
0412A:  ADDWFC xA8,W
0412C:  MOVWF  FEA
0412E:  MOVFF  FEF,3A9
04132:  MOVFF  FEC,3AA
04136:  MOVFF  FEC,3AB
0413A:  MOVFF  FEC,3AC
0413E:  MOVLW  06
04140:  ADDWF  xA1,W
04142:  MOVWF  FE9
04144:  MOVLW  00
04146:  ADDWFC xA2,W
04148:  MOVWF  FEA
0414A:  MOVFF  FEF,00
0414E:  MOVFF  FEC,01
04152:  MOVFF  FEC,02
04156:  MOVFF  FEC,03
0415A:  MOVF   00,W
0415C:  SUBWF  xA9,W
0415E:  BNZ   4172
04160:  MOVF   01,W
04162:  SUBWF  xAA,W
04164:  BNZ   4172
04166:  MOVF   02,W
04168:  SUBWF  xAB,W
0416A:  BNZ   4172
0416C:  MOVF   03,W
0416E:  SUBWF  xAC,W
04170:  BZ    419A
04172:  MOVFF  3A3,FE9
04176:  MOVFF  3A4,FEA
0417A:  MOVFF  FEF,3A9
0417E:  MOVFF  FEC,3AA
04182:  MOVFF  FEC,3AB
04186:  MOVFF  FEC,3AC
0418A:  INCFSZ xA9,W
0418C:  BRA    41A0
0418E:  INCFSZ xAA,W
04190:  BRA    41A0
04192:  INCFSZ xAB,W
04194:  BRA    41A0
04196:  INCFSZ xAC,W
04198:  BRA    41A0
....................                 { 
....................                     return s; 
0419A:  MOVFF  3A5,01
0419E:  BRA    4226
....................                 } 
....................             } 
....................  
....................             partialMatch = s; 
041A0:  MOVFF  3A5,3A6
....................         } 
....................         p++; 
041A4:  MOVLW  16
041A6:  ADDWF  xA7,F
041A8:  BTFSC  FD8.0
041AA:  INCF   xA8,F
....................     } 
041AC:  INCF   xA5,F
041AE:  BRA    4096
....................  
....................     if ( partialMatch != INVALID_UDP_SOCKET ) 
041B0:  INCFSZ xA6,W
041B2:  BRA    41B6
041B4:  BRA    4222
....................     { 
....................         p = &UDPSocketInfo[partialMatch]; 
041B6:  MOVF   xA6,W
041B8:  MULLW  16
041BA:  MOVF   FF3,W
041BC:  CLRF   03
041BE:  ADDLW  59
041C0:  MOVWF  01
041C2:  MOVLW  00
041C4:  ADDWFC 03,F
041C6:  MOVFF  01,3A7
041CA:  MOVFF  03,3A8
....................  
....................         memcpy(&p->remoteNode, 
....................                 remoteNode, sizeof(NODE_INFO) ); 
041CE:  MOVFF  3A8,03
041D2:  MOVFF  3A7,3A9
041D6:  MOVFF  3A8,3AA
041DA:  MOVFF  3A8,FEA
041DE:  MOVFF  3A7,FE9
041E2:  MOVFF  3A2,FE2
041E6:  MOVFF  3A1,FE1
041EA:  MOVLW  0A
041EC:  MOVWF  01
041EE:  MOVFF  FE6,FEE
041F2:  DECFSZ 01,F
041F4:  BRA    41EE
....................  
....................         p->remotePort = h->SourcePort; 
041F6:  MOVLW  0A
041F8:  ADDWF  xA7,W
041FA:  MOVWF  01
041FC:  MOVLW  00
041FE:  ADDWFC xA8,W
04200:  MOVFF  39F,FE9
04204:  MOVFF  3A0,FEA
04208:  MOVFF  FEC,03
0420C:  MOVF   FED,F
0420E:  MOVFF  FEF,3AB
04212:  MOVWF  FEA
04214:  MOVFF  01,FE9
04218:  MOVFF  03,FEC
0421C:  MOVF   FED,F
0421E:  MOVFF  3AB,FEF
....................     } 
....................     return partialMatch; 
04222:  MOVFF  3A6,01
.................... } 
04226:  MOVLB  0
04228:  GOTO   43CC (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
....................  *                                               (Rev 2.11) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/14/04 DHCP will force set IP Address to 0.0.0.0 during init. 
....................  * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
....................  * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
....................  *                              where UDPPut was called before setting 
....................  *                              active socket. 
....................  * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
....................  *                              NAK and renew existing IP address. 
....................  * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
....................  *                              chaddr field before accpting the packet. 
....................  *                              Fixed DHCPTask() where it would not 
....................  *                              reply to first OFFER. 
....................  * Darren Rook (CCS)    6/28/04 CCS Port now uses 2.20 (see above) 
....................  * Darren Rook (CCS)    6/29/04 DHCPServerID, DHCPLeaseTime, tempIPAddress, 
....................  *                              tempGateway, tempMask, _DHCPReceive() 
....................  *                              and _DHCPSend() no longer static. 
....................  * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
....................  *                              state to adjust for irregular TICK_SECOND 
....................  *                              Without this logic, actual lease time count 
....................  *                              down may be incorrect. 
....................  * Darren Rook (CCS)    7/13/06 Implemented Nilesh's 03/1/04 fix 
....................  * Howard Schlunder      5/11/06   Fixed tickDiff usage, reducing 
....................  *                        accumulated timing error.  Fixed DHCP 
....................  *                        state machine requesting IP 0.0.0.0 
....................  *                        after lease expiration. 
....................  * Howard Schlunder      6/01/06   Added DHCPState.bits.bOfferReceived flag to 
....................  *                        allow operation on networks with multiple 
....................  *                        DHCP servers offering multiple addresses 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack 
....................  * Howard Schlunder      8/01/06 Added DNS server option to DHCP request,  
....................  *                        untested Host Name option to DHCP request 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_SIIP) 
....................     #error DHCP module is not available when SLIP is used. 
.................... #endif 
....................  
.................... #define debug_dhcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_dhcp debug_printf 
....................  
.................... #define DHCP_TIMEOUT                    (2 * TICKS_PER_SECOND) 
....................  
....................  
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u) 
.................... #define BOOT_REPLY                      (2u) 
.................... #define HW_TYPE                         (1u) 
.................... #define LEN_OF_HW_TYPE                  (6u) 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u) 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u) 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u) 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u) 
.................... #define DHCP_OFFER_MESSAGE              (2u) 
.................... #define DHCP_REQUEST_MESSAGE            (3u) 
.................... #define DHCP_DECLINE_MESSAGE            (4u) 
.................... #define DHCP_ACK_MESSAGE                (5u) 
.................... #define DHCP_NAK_MESSAGE                (6u) 
.................... #define DHCP_RELEASE_MESSAGE            (7u) 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u) 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u) 
....................  
.................... #define DHCP_PARAM_REQUEST_LIST         (55u) 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u) 
.................... #define DHCP_SUBNET_MASK                (1u) 
.................... #define DHCP_ROUTER                     (3u) 
.................... #define DHCP_DNS                  (6u) 
.................... #define DHCP_HOST_NAME               (12u) 
.................... #define DHCP_IP_LEASE_TIME              (51u) 
.................... #define DHCP_END_OPTION                 (255u) 
....................  
.................... #define HALF_HOUR                       (WORD)((WORD)60 * (WORD)30) 
....................  
.................... static UDP_SOCKET DHCPSocket = INVALID_UDP_SOCKET; 
....................  
.................... static DWORD_VAL DHCPServerID; 
.................... static DWORD_VAL DHCPLeaseTime; 
....................  
.................... static IP_ADDR tempIPAddress; 
.................... static IP_ADDR tempGateway; 
.................... static IP_ADDR tempMask; 
.................... #if STACK_USE_DNS 
.................... static IP_ADDR tempDNS; 
.................... #endif 
.................... //static BYTE tempHostName[16]; 
....................  
.................... static union 
.................... { 
....................    struct 
....................    { 
....................       char IPAddress:1; 
....................       char Gateway:1; 
....................       char Mask:1; 
....................       char DNS:1; 
....................       char HostName:1; 
....................    } bits; 
....................    BYTE Val; 
.................... } ValidValues; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType); 
....................  
.................... BYTE DHCPBindCount = 0; 
....................  
....................  
....................  
.................... #define USARTPut(a) 
....................  
.................... void DHCPReset(void) 
.................... { 
....................     // Do not reset DHCP if it was previously disabled. 
....................     if ( smDHCPState == SM_DHCP_DISABLED ) 
*
017EC:  MOVF   x85,W
017EE:  SUBLW  08
017F0:  BNZ   17F4
....................         return; 
017F2:  BRA    1816
....................  
....................     if ( DHCPSocket != INVALID_UDP_SOCKET ) 
017F4:  MOVLB  1
017F6:  INCFSZ x42,W
017F8:  BRA    17FC
017FA:  BRA    1806
....................         UDPClose(DHCPSocket); 
017FC:  MOVFF  142,38F
01800:  MOVLB  0
01802:  RCALL  14DC
01804:  MOVLB  1
....................  
....................     DHCPSocket = INVALID_UDP_SOCKET; 
01806:  MOVLW  FF
01808:  MOVWF  x42
....................  
....................     smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
0180A:  MOVLB  0
0180C:  CLRF   x85
....................     DHCPBindCount = 0; 
0180E:  MOVLB  1
01810:  CLRF   x58
....................     DHCPState.bits.bIsBound = FALSE; 
01812:  MOVLB  0
01814:  BCF    x86.0
.................... } 
01816:  RETLW  00
....................  
.................... void DebugDHCPDisplayState(int8 st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case SM_DHCP_INIT_FIRST_TIME:   debug_dhcp("INIT_FIRST_TIME");   break; 
....................       case SM_DHCP_INIT:              debug_dhcp("INIT");   break; 
....................       case SM_DHCP_RESET_WAIT:        debug_dhcp("RESET_WAIT");   break; 
....................       case SM_DHCP_BROADCAST:         debug_dhcp("BROADCAST");   break; 
....................       case SM_DHCP_DISCOVER:          debug_dhcp("DISCOVER");   break; 
....................       case SM_DHCP_REQUEST:           debug_dhcp("REQUEST");   break; 
....................       case SM_DHCP_BIND:              debug_dhcp("BIND");   break; 
....................       case SM_DHCP_BOUND:             debug_dhcp("BOUND");   break; 
....................       case SM_DHCP_DISABLED:          debug_dhcp("DISABLED");   break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
....................    NODE_INFO DHCPServerNode; 
....................    static TICKTYPE lastTryTick; 
....................    BYTE DHCPRecvReturnValue; 
....................    TICKTYPE tickDiff; 
....................    //static int8 debugLastState; 
....................  
....................    //debugLastState = smDHCPState; 
....................  
....................     switch(smDHCPState) 
....................     { 
*
09C8C:  MOVF   x85,W
09C8E:  ADDLW  F8
09C90:  BTFSC  FD8.0
09C92:  BRA    A0DE
09C94:  ADDLW  08
09C96:  GOTO   A0E4
....................    case SM_DHCP_INIT_FIRST_TIME: 
....................         tempIPAddress.Val = 0x0; 
09C9A:  MOVLB  1
09C9C:  CLRF   x4E
09C9E:  CLRF   x4D
09CA0:  CLRF   x4C
09CA2:  CLRF   x4B
09CA4:  MOVLB  0
.................... //        smDHCPState = SM_DHCP_INIT;         // State automatically changes 
....................         /* No break */ 
....................  
....................     case SM_DHCP_INIT: 
....................         //debug(debug_putc,"\r\n\r\nDHCP: INIT"); 
....................  
....................         //dsr add 061404 
....................         //MY_IP=0; 
....................  
....................         DHCPServerNode.MACAddr.v[0] = 0xff; 
09CA6:  MOVLW  FF
09CA8:  MOVLB  3
09CAA:  MOVWF  x82
....................         DHCPServerNode.MACAddr.v[1] = 0xff; 
09CAC:  MOVWF  x83
....................         DHCPServerNode.MACAddr.v[2] = 0xff; 
09CAE:  MOVWF  x84
....................         DHCPServerNode.MACAddr.v[3] = 0xff; 
09CB0:  MOVWF  x85
....................         DHCPServerNode.MACAddr.v[4] = 0xff; 
09CB2:  MOVWF  x86
....................         DHCPServerNode.MACAddr.v[5] = 0xff; 
09CB4:  MOVWF  x87
....................         DHCPServerNode.IPAddr.Val = 0xffffffff; 
09CB6:  MOVWF  x8B
09CB8:  MOVWF  x8A
09CBA:  MOVWF  x89
09CBC:  MOVWF  x88
....................         DHCPSocket = UDPOpen(DHCP_CLIENT_PORT, 
....................                              &DHCPServerNode, 
....................                              DHCP_SERVER_PORT); 
09CBE:  CLRF   x90
09CC0:  MOVLW  44
09CC2:  MOVWF  x8F
09CC4:  MOVLW  03
09CC6:  MOVWF  x92
09CC8:  MOVLW  82
09CCA:  MOVWF  x91
09CCC:  CLRF   x94
09CCE:  MOVLW  43
09CD0:  MOVWF  x93
09CD2:  MOVLB  0
09CD4:  CALL   5E7C
09CD8:  MOVFF  01,142
....................         lastTryTick = TickGet(); 
09CDC:  CALL   485C
09CE0:  MOVFF  02,15A
09CE4:  MOVFF  01,159
....................         smDHCPState = SM_DHCP_RESET_WAIT; 
09CE8:  MOVLW  02
09CEA:  MOVWF  x85
....................         /* No break */ 
....................  
....................     case SM_DHCP_RESET_WAIT: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= (TICKS_PER_SECOND/5) ) 
09CEC:  CALL   485C
09CF0:  MOVFF  02,390
09CF4:  MOVFF  01,38F
09CF8:  MOVLB  3
09CFA:  MOVF   02,W
09CFC:  MOVLB  1
09CFE:  SUBWF  x5A,W
09D00:  BNC   9D14
09D02:  BNZ   9D18
09D04:  MOVF   x59,W
09D06:  MOVLB  3
09D08:  SUBWF  x8F,W
09D0A:  BTFSC  FD8.0
09D0C:  BRA    9D12
09D0E:  MOVLB  1
09D10:  BRA    9D18
09D12:  MOVLB  1
09D14:  MOVLW  00
09D16:  BRA    9D1A
09D18:  MOVLW  01
09D1A:  CLRF   03
09D1C:  IORWF  03,W
09D1E:  BZ    9D54
09D20:  MOVLW  FF
09D22:  BSF    FD8.0
09D24:  SUBFWB x59,W
09D26:  MOVLB  3
09D28:  MOVWF  x8F
09D2A:  MOVLW  FF
09D2C:  MOVLB  1
09D2E:  SUBFWB x5A,W
09D30:  MOVLB  3
09D32:  MOVWF  x90
09D34:  MOVLB  0
09D36:  CALL   485C
09D3A:  MOVF   01,W
09D3C:  MOVLB  3
09D3E:  ADDWF  x8F,F
09D40:  MOVF   02,W
09D42:  ADDWFC x90,F
09D44:  MOVLW  01
09D46:  ADDWF  x8F,W
09D48:  MOVWF  01
09D4A:  MOVLW  00
09D4C:  ADDWFC x90,W
09D4E:  MOVWF  03
09D50:  MOVF   01,W
09D52:  BRA    9D78
09D54:  MOVLB  0
09D56:  CALL   485C
09D5A:  MOVFF  02,390
09D5E:  MOVFF  01,38F
09D62:  MOVLB  1
09D64:  MOVF   x59,W
09D66:  MOVLB  3
09D68:  SUBWF  01,W
09D6A:  MOVWF  00
09D6C:  MOVLB  1
09D6E:  MOVF   x5A,W
09D70:  MOVLB  3
09D72:  SUBWFB 02,W
09D74:  MOVWF  03
09D76:  MOVF   00,W
09D78:  SUBLW  01
09D7A:  BC    9D82
....................             //debug(debug_putc,"\r\n\r\nDHCP: RESET_WAIT"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
09D7C:  MOVLW  03
09D7E:  MOVLB  0
09D80:  MOVWF  x85
....................         break; 
09D82:  MOVLB  0
09D84:  BRA    A0DE
....................  
....................     case SM_DHCP_BROADCAST: 
....................        // Assume default IP Lease time of 60 seconds. 
....................        // This should be minimum possible to make sure that if 
....................        // server did not specify lease time, we try again after this minimum time. 
....................        DHCPLeaseTime.Val = 60; 
09D86:  MOVLB  1
09D88:  CLRF   x4A
09D8A:  CLRF   x49
09D8C:  CLRF   x48
09D8E:  MOVLW  3C
09D90:  MOVWF  x47
....................  
....................         // If we have already obtained some IP address, renew it. 
....................         if(DHCPState.bits.bIsBound) 
09D92:  MOVLB  0
09D94:  BTFSS  x86.0
09D96:  BRA    9D9E
....................         { 
....................             smDHCPState = SM_DHCP_REQUEST; 
09D98:  MOVLW  05
09D9A:  MOVWF  x85
....................         } 
....................         else if ( UDPIsPutReady(DHCPSocket) ) 
09D9C:  BRA    9DCC
09D9E:  MOVFF  142,38F
09DA2:  CALL   5F42
09DA6:  MOVF   01,F
09DA8:  BZ    9DCC
....................         { 
....................             // To minimize code requirement, user must make sure that 
....................             // above call will be successful by making at least one 
....................             // UDP socket available. 
....................             // Usually this will be the case, given that DHCP will be 
....................             // the first one to use UDP socket. 
....................             // Also, we will not check for transmitter readiness, 
....................             // we assume it to be ready. 
....................             _DHCPSend(DHCP_DISCOVER_MESSAGE); 
09DAA:  MOVLW  01
09DAC:  MOVLB  3
09DAE:  MOVWF  x8F
09DB0:  MOVLB  0
09DB2:  CALL   9436
....................          ValidValues.Val = 0x00; 
09DB6:  MOVLB  1
09DB8:  CLRF   x57
....................  
....................             lastTryTick = TickGet(); 
09DBA:  MOVLB  0
09DBC:  CALL   485C
09DC0:  MOVFF  02,15A
09DC4:  MOVFF  01,159
....................             smDHCPState = SM_DHCP_DISCOVER; 
09DC8:  MOVLW  04
09DCA:  MOVWF  x85
....................         } 
....................  
....................         break; 
09DCC:  BRA    A0DE
....................  
....................  
....................     case SM_DHCP_DISCOVER: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
09DCE:  CALL   485C
09DD2:  MOVFF  02,390
09DD6:  MOVFF  01,38F
09DDA:  MOVLB  3
09DDC:  MOVF   02,W
09DDE:  MOVLB  1
09DE0:  SUBWF  x5A,W
09DE2:  BNC   9DF6
09DE4:  BNZ   9DFA
09DE6:  MOVF   x59,W
09DE8:  MOVLB  3
09DEA:  SUBWF  x8F,W
09DEC:  BTFSC  FD8.0
09DEE:  BRA    9DF4
09DF0:  MOVLB  1
09DF2:  BRA    9DFA
09DF4:  MOVLB  1
09DF6:  MOVLW  00
09DF8:  BRA    9DFC
09DFA:  MOVLW  01
09DFC:  CLRF   03
09DFE:  IORWF  03,W
09E00:  BZ    9E36
09E02:  MOVLW  FF
09E04:  BSF    FD8.0
09E06:  SUBFWB x59,W
09E08:  MOVLB  3
09E0A:  MOVWF  x8F
09E0C:  MOVLW  FF
09E0E:  MOVLB  1
09E10:  SUBFWB x5A,W
09E12:  MOVLB  3
09E14:  MOVWF  x90
09E16:  MOVLB  0
09E18:  CALL   485C
09E1C:  MOVF   01,W
09E1E:  MOVLB  3
09E20:  ADDWF  x8F,F
09E22:  MOVF   02,W
09E24:  ADDWFC x90,F
09E26:  MOVLW  01
09E28:  ADDWF  x8F,W
09E2A:  MOVWF  01
09E2C:  MOVLW  00
09E2E:  ADDWFC x90,W
09E30:  MOVWF  03
09E32:  MOVF   01,W
09E34:  BRA    9E5A
09E36:  MOVLB  0
09E38:  CALL   485C
09E3C:  MOVFF  02,390
09E40:  MOVFF  01,38F
09E44:  MOVLB  1
09E46:  MOVF   x59,W
09E48:  MOVLB  3
09E4A:  SUBWF  01,W
09E4C:  MOVWF  00
09E4E:  MOVLB  1
09E50:  MOVF   x5A,W
09E52:  MOVLB  3
09E54:  SUBWFB 02,W
09E56:  MOVWF  03
09E58:  MOVF   00,W
09E5A:  SUBLW  13
09E5C:  BC    9E64
....................       { 
....................             //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER TO BROADCAST"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
09E5E:  MOVLW  03
09E60:  MOVLB  0
09E62:  MOVWF  x85
....................             //return; 
....................         } 
....................  
....................         if ( UDPIsGetReady(DHCPSocket) ) 
09E64:  MOVFF  142,38F
09E68:  MOVLB  0
09E6A:  RCALL  9690
09E6C:  MOVF   01,F
09E6E:  BZ    9E82
....................         { 
....................  
....................             if ( _DHCPReceive() == DHCP_OFFER_MESSAGE ) 
09E70:  RCALL  9850
09E72:  MOVF   01,W
09E74:  SUBLW  02
09E76:  BNZ   9E7E
....................             { 
....................                 //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER BACK TO REQUEST"); 
....................                 smDHCPState = SM_DHCP_REQUEST; 
09E78:  MOVLW  05
09E7A:  MOVWF  x85
....................             } 
....................             else 
09E7C:  BRA    9E80
....................                break; 
09E7E:  BRA    A0DE
....................         } 
....................         else 
09E80:  BRA    9E84
....................            break; 
09E82:  BRA    A0DE
....................  
....................  
....................     case SM_DHCP_REQUEST: 
....................         if ( UDPIsPutReady(DHCPSocket) ) 
09E84:  MOVFF  142,38F
09E88:  CALL   5F42
09E8C:  MOVF   01,F
09E8E:  BZ    9EAC
....................         { 
....................             _DHCPSend(DHCP_REQUEST_MESSAGE); 
09E90:  MOVLW  03
09E92:  MOVLB  3
09E94:  MOVWF  x8F
09E96:  MOVLB  0
09E98:  CALL   9436
....................             lastTryTick = TickGet(); 
09E9C:  CALL   485C
09EA0:  MOVFF  02,15A
09EA4:  MOVFF  01,159
....................             smDHCPState = SM_DHCP_BIND; 
09EA8:  MOVLW  06
09EAA:  MOVWF  x85
....................             //debug(debug_putc,"\r\n\r\nDHCP: REQUEST TO BIND"); 
....................         } 
....................         break; 
09EAC:  BRA    A0DE
....................  
....................     case SM_DHCP_BIND: 
....................         if ( UDPIsGetReady(DHCPSocket) ) 
09EAE:  MOVFF  142,38F
09EB2:  CALL   9690
09EB6:  MOVF   01,F
09EB8:  BZ    9F4C
....................         { 
....................             DHCPRecvReturnValue = _DHCPReceive(); 
09EBA:  RCALL  9850
09EBC:  MOVFF  01,38C
....................             if ( DHCPRecvReturnValue == DHCP_NAK_MESSAGE ) 
09EC0:  MOVLB  3
09EC2:  MOVF   x8C,W
09EC4:  SUBLW  06
09EC6:  BNZ   9ED4
....................             { 
....................                // (RSS) NAK recieved.  DHCP server didn't like our DHCP Request format 
....................             DHCPReset();                  // Start all over again 
09EC8:  MOVLB  0
09ECA:  CALL   17EC
....................             return; 
09ECE:  BRA    A0DE
....................             } 
....................             else if ( DHCPRecvReturnValue == DHCP_ACK_MESSAGE ) 
09ED0:  BRA    9F46
09ED2:  MOVLB  3
09ED4:  MOVF   x8C,W
09ED6:  SUBLW  05
09ED8:  BNZ   9F48
....................             { 
....................                 // Once DCHP is successful, release the UDP socket 
....................                 // This will ensure that UDP layer discards any further DHCP related packets. 
....................                 UDPClose(DHCPSocket); 
09EDA:  MOVFF  142,38F
09EDE:  MOVLB  0
09EE0:  CALL   14DC
....................                 DHCPSocket = INVALID_UDP_SOCKET; 
09EE4:  MOVLW  FF
09EE6:  MOVLB  1
09EE8:  MOVWF  x42
....................  
....................                 lastTryTick = TickGet(); 
09EEA:  MOVLB  0
09EEC:  CALL   485C
09EF0:  MOVFF  02,15A
09EF4:  MOVFF  01,159
....................                 smDHCPState = SM_DHCP_BOUND; 
09EF8:  MOVLW  07
09EFA:  MOVWF  x85
....................  
....................             if(ValidValues.bits.IPAddress) 
09EFC:  MOVLB  1
09EFE:  BTFSS  x57.0
09F00:  BRA    9F12
....................                    AppConfig.MyIPAddr = tempIPAddress; 
09F02:  MOVFF  14E,19
09F06:  MOVFF  14D,18
09F0A:  MOVFF  14C,17
09F0E:  MOVFF  14B,16
....................             if(ValidValues.bits.Mask) 
09F12:  BTFSS  x57.2
09F14:  BRA    9F26
....................                AppConfig.MyMask = tempMask; 
09F16:  MOVFF  156,23
09F1A:  MOVFF  155,22
09F1E:  MOVFF  154,21
09F22:  MOVFF  153,20
....................             if(ValidValues.bits.Gateway) 
09F26:  BTFSS  x57.1
09F28:  BRA    9F3A
....................                AppConfig.MyGateway = tempGateway; 
09F2A:  MOVFF  152,27
09F2E:  MOVFF  151,26
09F32:  MOVFF  150,25
09F36:  MOVFF  14F,24
....................          #if STACK_USE_DNS 
....................             if(ValidValues.bits.DNS) 
....................                AppConfig.PrimaryDNSServer = tempDNS; 
....................          #endif 
.................... //            if(ValidValues.bits.HostName) 
.................... //               memcpy(AppConfig.NetBIOSName, (void*)tempHostName, sizeof(AppConfig.NetBIOSName)); 
....................  
....................                 DHCPState.bits.bIsBound = TRUE; 
09F3A:  MOVLB  0
09F3C:  BSF    x86.0
....................  
....................                 DHCPBindCount++; 
09F3E:  MOVLB  1
09F40:  INCF   x58,F
....................  
....................                 return; 
09F42:  MOVLB  0
09F44:  BRA    A0DE
09F46:  MOVLB  3
....................             } 
....................         } 
....................         else if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
09F48:  BRA    9FE2
09F4A:  MOVLB  0
09F4C:  CALL   485C
09F50:  MOVFF  02,390
09F54:  MOVFF  01,38F
09F58:  MOVLB  3
09F5A:  MOVF   02,W
09F5C:  MOVLB  1
09F5E:  SUBWF  x5A,W
09F60:  BNC   9F74
09F62:  BNZ   9F78
09F64:  MOVF   x59,W
09F66:  MOVLB  3
09F68:  SUBWF  x8F,W
09F6A:  BTFSC  FD8.0
09F6C:  BRA    9F72
09F6E:  MOVLB  1
09F70:  BRA    9F78
09F72:  MOVLB  1
09F74:  MOVLW  00
09F76:  BRA    9F7A
09F78:  MOVLW  01
09F7A:  CLRF   03
09F7C:  IORWF  03,W
09F7E:  BZ    9FB4
09F80:  MOVLW  FF
09F82:  BSF    FD8.0
09F84:  SUBFWB x59,W
09F86:  MOVLB  3
09F88:  MOVWF  x8F
09F8A:  MOVLW  FF
09F8C:  MOVLB  1
09F8E:  SUBFWB x5A,W
09F90:  MOVLB  3
09F92:  MOVWF  x90
09F94:  MOVLB  0
09F96:  CALL   485C
09F9A:  MOVF   01,W
09F9C:  MOVLB  3
09F9E:  ADDWF  x8F,F
09FA0:  MOVF   02,W
09FA2:  ADDWFC x90,F
09FA4:  MOVLW  01
09FA6:  ADDWF  x8F,W
09FA8:  MOVWF  01
09FAA:  MOVLW  00
09FAC:  ADDWFC x90,W
09FAE:  MOVWF  03
09FB0:  MOVF   01,W
09FB2:  BRA    9FD8
09FB4:  MOVLB  0
09FB6:  CALL   485C
09FBA:  MOVFF  02,390
09FBE:  MOVFF  01,38F
09FC2:  MOVLB  1
09FC4:  MOVF   x59,W
09FC6:  MOVLB  3
09FC8:  SUBWF  01,W
09FCA:  MOVWF  00
09FCC:  MOVLB  1
09FCE:  MOVF   x5A,W
09FD0:  MOVLB  3
09FD2:  SUBWFB 02,W
09FD4:  MOVWF  03
09FD6:  MOVF   00,W
09FD8:  SUBLW  13
09FDA:  BC    9FE2
....................             smDHCPState = SM_DHCP_BROADCAST; 
09FDC:  MOVLW  03
09FDE:  MOVLB  0
09FE0:  MOVWF  x85
....................         break; 
09FE2:  MOVLB  0
09FE4:  BRA    A0DE
....................  
....................     case SM_DHCP_BOUND: 
....................         // Keep track of how long we use this IP configuration. 
....................         // When lease period expires, renew the configuration. 
....................         tickDiff = TickGetDiff(TickGet(), lastTryTick); 
09FE6:  CALL   485C
09FEA:  MOVFF  02,390
09FEE:  MOVFF  01,38F
09FF2:  MOVLB  3
09FF4:  MOVF   02,W
09FF6:  MOVLB  1
09FF8:  SUBWF  x5A,W
09FFA:  BNC   A00E
09FFC:  BNZ   A012
09FFE:  MOVF   x59,W
0A000:  MOVLB  3
0A002:  SUBWF  x8F,W
0A004:  BTFSC  FD8.0
0A006:  BRA    A00C
0A008:  MOVLB  1
0A00A:  BRA    A012
0A00C:  MOVLB  1
0A00E:  MOVLW  00
0A010:  BRA    A014
0A012:  MOVLW  01
0A014:  CLRF   03
0A016:  IORWF  03,W
0A018:  BZ    A04E
0A01A:  MOVLW  FF
0A01C:  BSF    FD8.0
0A01E:  SUBFWB x59,W
0A020:  MOVLB  3
0A022:  MOVWF  x8F
0A024:  MOVLW  FF
0A026:  MOVLB  1
0A028:  SUBFWB x5A,W
0A02A:  MOVLB  3
0A02C:  MOVWF  x90
0A02E:  MOVLB  0
0A030:  CALL   485C
0A034:  MOVF   01,W
0A036:  MOVLB  3
0A038:  ADDWF  x8F,F
0A03A:  MOVF   02,W
0A03C:  ADDWFC x90,F
0A03E:  MOVLW  01
0A040:  ADDWF  x8F,W
0A042:  MOVWF  01
0A044:  MOVLW  00
0A046:  ADDWFC x90,W
0A048:  MOVWF  03
0A04A:  MOVF   01,W
0A04C:  BRA    A072
0A04E:  MOVLB  0
0A050:  CALL   485C
0A054:  MOVFF  02,390
0A058:  MOVFF  01,38F
0A05C:  MOVLB  1
0A05E:  MOVF   x59,W
0A060:  MOVLB  3
0A062:  SUBWF  01,W
0A064:  MOVWF  00
0A066:  MOVLB  1
0A068:  MOVF   x5A,W
0A06A:  MOVLB  3
0A06C:  SUBWFB 02,W
0A06E:  MOVWF  03
0A070:  MOVF   00,W
0A072:  MOVWF  x8D
0A074:  MOVFF  03,38E
....................  
....................         if(tickDiff >= TICKS_PER_SECOND) 
0A078:  MOVF   x8E,F
0A07A:  BNZ   A082
0A07C:  MOVF   x8D,W
0A07E:  SUBLW  09
0A080:  BC    A0DE
....................         { 
....................          do 
....................          { 
....................                DHCPLeaseTime.Val--; 
0A082:  MOVLW  FF
0A084:  MOVLB  1
0A086:  ADDWF  x47,F
0A088:  BTFSS  FD8.0
0A08A:  ADDWF  x48,F
0A08C:  BTFSS  FD8.0
0A08E:  ADDWF  x49,F
0A090:  BTFSS  FD8.0
0A092:  ADDWF  x4A,F
....................             tickDiff -= TICKS_PER_SECOND; 
0A094:  MOVLW  0A
0A096:  MOVLB  3
0A098:  SUBWF  x8D,F
0A09A:  MOVLW  00
0A09C:  SUBWFB x8E,F
....................                if(DHCPLeaseTime.Val == 0u) 
0A09E:  MOVLB  1
0A0A0:  MOVF   x47,F
0A0A2:  BNZ   A0B6
0A0A4:  MOVF   x48,F
0A0A6:  BNZ   A0B6
0A0A8:  MOVF   x49,F
0A0AA:  BNZ   A0B6
0A0AC:  MOVF   x4A,F
0A0AE:  BNZ   A0B6
....................                   smDHCPState = SM_DHCP_INIT; 
0A0B0:  MOVLW  01
0A0B2:  MOVLB  0
0A0B4:  MOVWF  x85
....................          } while(tickDiff >= TICKS_PER_SECOND); 
0A0B6:  MOVLB  3
0A0B8:  MOVF   x8E,F
0A0BA:  BNZ   A082
0A0BC:  MOVF   x8D,W
0A0BE:  SUBLW  09
0A0C0:  BNC   A082
....................             lastTryTick = TickGet() - tickDiff; 
0A0C2:  MOVLB  0
0A0C4:  CALL   485C
0A0C8:  MOVLB  3
0A0CA:  MOVF   x8D,W
0A0CC:  SUBWF  01,W
0A0CE:  MOVLB  1
0A0D0:  MOVWF  x59
0A0D2:  MOVLB  3
0A0D4:  MOVF   x8E,W
0A0D6:  SUBWFB 02,W
0A0D8:  MOVLB  1
0A0DA:  MOVWF  x5A
0A0DC:  MOVLB  3
0A0DE:  MOVLB  0
....................         } 
....................     } 
....................  
....................    /*if (debugLastState != smDHCPState) 
....................    { 
....................       debug_dhcp("\r\nDHCP TASK - ", ); 
....................       DebugDHCPDisplayState(debugLastState); 
....................       debug_dhcp(" -> "); 
....................       DebugDHCPDisplayState(smDHCPState); 
....................    }*/ 
.................... } 
0A0E0:  GOTO   A33C (RETURN)
....................  
.................... /********************************************************************* 
....................         DHCP PACKET FORMAT AS PER RFC 1541 
....................  
....................    0                   1                   2                   3 
....................    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
....................    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
....................    |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
....................    +---------------+---------------+---------------+---------------+ 
....................    |                            xid (4)                            | 
....................    +-------------------------------+-------------------------------+ 
....................    |           secs (2)            |           flags (2)           | 
....................    +-------------------------------+-------------------------------+ 
....................    |                          ciaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          yiaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          siaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          giaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          chaddr  (16)                         | 
....................    |                                                               | 
....................    |                                                               | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          sname   (64)                         | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          file    (128)                        | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          options (312)                        | 
....................    +---------------------------------------------------------------+ 
....................  
....................  ********************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
....................     BYTE v; 
....................     BYTE i, j; 
....................     BYTE type; 
....................     BOOL lbDone; 
....................     DWORD_VAL tempServerID; 
....................  
....................  
....................     // Assume unknown message until proven otherwise. 
....................     type = DHCP_UNKNOWN_MESSAGE; 
*
09850:  MOVLB  3
09852:  CLRF   x92
....................  
....................     UDPGet(&v);                             // op 
09854:  MOVLW  03
09856:  MOVWF  x99
09858:  MOVLW  8F
0985A:  MOVWF  x98
0985C:  MOVLB  0
0985E:  RCALL  96D6
....................  
....................     //Make sure this is BOOT_REPLY. 
....................     if ( v == BOOT_REPLY ) 
09860:  MOVLB  3
09862:  MOVF   x8F,W
09864:  SUBLW  02
09866:  BTFSS  FD8.2
09868:  BRA    9C28
....................     { 
....................         //Discard htype, hlen, hops, xid, secs, flags, ciaddr. 
....................         for ( i = 0; i < 15u; i++ ) 
0986A:  CLRF   x90
0986C:  MOVF   x90,W
0986E:  SUBLW  0E
09870:  BNC   9884
....................             UDPGet(&v); 
09872:  MOVLW  03
09874:  MOVWF  x99
09876:  MOVLW  8F
09878:  MOVWF  x98
0987A:  MOVLB  0
0987C:  RCALL  96D6
0987E:  MOVLB  3
09880:  INCF   x90,F
09882:  BRA    986C
....................  
....................       // Check to see if this is the first offer 
....................       if(DHCPState.bits.bOfferReceived) 
09884:  MOVLB  0
09886:  BTFSS  x86.1
09888:  BRA    98AA
....................       { 
....................            // Discard offered IP address, we already have an offer 
....................            for ( i = 0; i < 4u; i++ ) 
0988A:  MOVLB  3
0988C:  CLRF   x90
0988E:  MOVF   x90,W
09890:  SUBLW  03
09892:  BNC   98A6
....................                UDPGet(&v); 
09894:  MOVLW  03
09896:  MOVWF  x99
09898:  MOVLW  8F
0989A:  MOVWF  x98
0989C:  MOVLB  0
0989E:  RCALL  96D6
098A0:  MOVLB  3
098A2:  INCF   x90,F
098A4:  BRA    988E
....................       } 
....................       else 
098A6:  BRA    98E8
098A8:  MOVLB  0
....................       { 
....................            // Save offered IP address until we know for sure that we have it. 
....................            UDPGet(&tempIPAddress.v[0]); 
098AA:  MOVLW  01
098AC:  MOVLB  3
098AE:  MOVWF  x99
098B0:  MOVLW  4B
098B2:  MOVWF  x98
098B4:  MOVLB  0
098B6:  RCALL  96D6
....................            UDPGet(&tempIPAddress.v[1]); 
098B8:  MOVLW  01
098BA:  MOVLB  3
098BC:  MOVWF  x99
098BE:  MOVLW  4C
098C0:  MOVWF  x98
098C2:  MOVLB  0
098C4:  RCALL  96D6
....................            UDPGet(&tempIPAddress.v[2]); 
098C6:  MOVLW  01
098C8:  MOVLB  3
098CA:  MOVWF  x99
098CC:  MOVLW  4D
098CE:  MOVWF  x98
098D0:  MOVLB  0
098D2:  RCALL  96D6
....................            UDPGet(&tempIPAddress.v[3]); 
098D4:  MOVLW  01
098D6:  MOVLB  3
098D8:  MOVWF  x99
098DA:  MOVLW  4E
098DC:  MOVWF  x98
098DE:  MOVLB  0
098E0:  RCALL  96D6
....................          ValidValues.bits.IPAddress = 1; 
098E2:  MOVLB  1
098E4:  BSF    x57.0
098E6:  MOVLB  3
....................       } 
....................  
....................         //Ignore siaddr, giaddr 
....................         for ( i = 0; i < 8u; i++ ) 
098E8:  CLRF   x90
098EA:  MOVF   x90,W
098EC:  SUBLW  07
098EE:  BNC   9902
....................             UDPGet(&v); 
098F0:  MOVLW  03
098F2:  MOVWF  x99
098F4:  MOVLW  8F
098F6:  MOVWF  x98
098F8:  MOVLB  0
098FA:  RCALL  96D6
098FC:  MOVLB  3
098FE:  INCF   x90,F
09900:  BRA    98EA
....................  
....................         //Check to see if chaddr (Client Hardware Address) belongs to us. 
....................         for ( i = 0; i < 6u; i++ ) 
09902:  CLRF   x90
09904:  MOVF   x90,W
09906:  SUBLW  05
09908:  BNC   993C
....................         { 
....................             UDPGet(&v); 
0990A:  MOVLW  03
0990C:  MOVWF  x99
0990E:  MOVLW  8F
09910:  MOVWF  x98
09912:  MOVLB  0
09914:  RCALL  96D6
....................             if ( v != AppConfig.MyMACAddr.v[i]) 
09916:  CLRF   03
09918:  MOVLB  3
0991A:  MOVF   x90,W
0991C:  ADDLW  04
0991E:  MOVWF  01
09920:  MOVLW  00
09922:  ADDWFC 03,F
09924:  MOVF   01,W
09926:  ADDLW  16
09928:  MOVWF  FE9
0992A:  MOVLW  00
0992C:  ADDWFC 03,W
0992E:  MOVWF  FEA
09930:  MOVF   FEF,W
09932:  SUBWF  x8F,W
09934:  BZ    9938
....................                 goto UDPInvalid; 
09936:  BRA    9C7E
....................         } 
09938:  INCF   x90,F
0993A:  BRA    9904
....................  
....................         //Ignore part of chaddr, sname, file, magic cookie. 
....................         for ( i = 0; i < 206u; i++ ) 
0993C:  CLRF   x90
0993E:  MOVF   x90,W
09940:  SUBLW  CD
09942:  BNC   9956
....................             UDPGet(&v); 
09944:  MOVLW  03
09946:  MOVWF  x99
09948:  MOVLW  8F
0994A:  MOVWF  x98
0994C:  MOVLB  0
0994E:  RCALL  96D6
09950:  MOVLB  3
09952:  INCF   x90,F
09954:  BRA    993E
....................  
....................         lbDone = FALSE; 
09956:  BCF    x93.0
....................         do 
....................         { 
....................          // Get the Option number 
....................          // Break out eventually in case if this is a malformed 
....................          // DHCP message, ie: missing DHCP_END_OPTION marker 
....................          if(!UDPGet(&v)) 
09958:  MOVLW  03
0995A:  MOVWF  x99
0995C:  MOVLW  8F
0995E:  MOVWF  x98
09960:  MOVLB  0
09962:  RCALL  96D6
09964:  MOVF   01,F
09966:  BNZ   9970
....................          { 
....................             lbDone = TRUE; 
09968:  MOVLB  3
0996A:  BSF    x93.0
....................             break; 
0996C:  BRA    9C28
0996E:  MOVLB  0
....................          } 
....................  
....................             switch(v) 
....................             { 
09970:  MOVLB  3
09972:  MOVF   x8F,W
09974:  XORLW  35
09976:  MOVLB  0
09978:  BZ    9998
0997A:  XORLW  34
0997C:  BZ    99D8
0997E:  XORLW  02
09980:  BTFSC  FD8.2
09982:  BRA    9A5A
09984:  XORLW  35
09986:  BTFSC  FD8.2
09988:  BRA    9AF8
0998A:  XORLW  C9
0998C:  BTFSC  FD8.2
0998E:  BRA    9B4E
09990:  XORLW  CC
09992:  BTFSC  FD8.2
09994:  BRA    9B56
09996:  BRA    9BFC
....................             case DHCP_MESSAGE_TYPE: 
....................                 UDPGet(&v);                         // Skip len 
09998:  MOVLW  03
0999A:  MOVLB  3
0999C:  MOVWF  x99
0999E:  MOVLW  8F
099A0:  MOVWF  x98
099A2:  MOVLB  0
099A4:  RCALL  96D6
....................                 // Len must be 1. 
....................                 if ( v == 1u ) 
099A6:  MOVLB  3
099A8:  DECFSZ x8F,W
099AA:  BRA    99D2
....................                 { 
....................                     UDPGet(&type);                  // Get type 
099AC:  MOVLW  03
099AE:  MOVWF  x99
099B0:  MOVLW  92
099B2:  MOVWF  x98
099B4:  MOVLB  0
099B6:  RCALL  96D6
....................  
....................                // Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
....................                if(DHCPState.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
099B8:  BTFSS  x86.1
099BA:  BRA    99CE
099BC:  MOVLB  3
099BE:  MOVF   x92,W
099C0:  SUBLW  02
099C2:  BTFSC  FD8.2
099C4:  BRA    99CA
099C6:  MOVLB  0
099C8:  BRA    99CE
....................                { 
....................                   goto UDPInvalid; 
099CA:  BRA    9C7E
099CC:  MOVLB  0
....................                } 
....................             } 
....................                 else 
099CE:  BRA    99D6
099D0:  MOVLB  3
....................                     goto UDPInvalid; 
099D2:  BRA    9C7E
099D4:  MOVLB  0
....................                 break; 
099D6:  BRA    9C22
....................  
....................             case DHCP_SUBNET_MASK: 
....................                 UDPGet(&v);                     // Skip len 
099D8:  MOVLW  03
099DA:  MOVLB  3
099DC:  MOVWF  x99
099DE:  MOVLW  8F
099E0:  MOVWF  x98
099E2:  MOVLB  0
099E4:  RCALL  96D6
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
099E6:  MOVLB  3
099E8:  MOVF   x8F,W
099EA:  SUBLW  04
099EC:  BNZ   9A54
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
099EE:  MOVLB  0
099F0:  BTFSS  x86.1
099F2:  BRA    9A14
....................                { 
....................                     // Discard offered IP mask, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
099F4:  MOVLB  3
099F6:  CLRF   x90
099F8:  MOVF   x90,W
099FA:  SUBLW  03
099FC:  BNC   9A10
....................                         UDPGet(&v); 
099FE:  MOVLW  03
09A00:  MOVWF  x99
09A02:  MOVLW  8F
09A04:  MOVWF  x98
09A06:  MOVLB  0
09A08:  RCALL  96D6
09A0A:  MOVLB  3
09A0C:  INCF   x90,F
09A0E:  BRA    99F8
....................                } 
....................                else 
09A10:  BRA    9A52
09A12:  MOVLB  0
....................                { 
....................                        UDPGet(&tempMask.v[0]); 
09A14:  MOVLW  01
09A16:  MOVLB  3
09A18:  MOVWF  x99
09A1A:  MOVLW  53
09A1C:  MOVWF  x98
09A1E:  MOVLB  0
09A20:  RCALL  96D6
....................                        UDPGet(&tempMask.v[1]); 
09A22:  MOVLW  01
09A24:  MOVLB  3
09A26:  MOVWF  x99
09A28:  MOVLW  54
09A2A:  MOVWF  x98
09A2C:  MOVLB  0
09A2E:  RCALL  96D6
....................                        UDPGet(&tempMask.v[2]); 
09A30:  MOVLW  01
09A32:  MOVLB  3
09A34:  MOVWF  x99
09A36:  MOVLW  55
09A38:  MOVWF  x98
09A3A:  MOVLB  0
09A3C:  RCALL  96D6
....................                        UDPGet(&tempMask.v[3]); 
09A3E:  MOVLW  01
09A40:  MOVLB  3
09A42:  MOVWF  x99
09A44:  MOVLW  56
09A46:  MOVWF  x98
09A48:  MOVLB  0
09A4A:  RCALL  96D6
....................                   ValidValues.bits.Mask = 1; 
09A4C:  MOVLB  1
09A4E:  BSF    x57.2
09A50:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
09A52:  BRA    9A56
....................                     goto UDPInvalid; 
09A54:  BRA    9C7E
....................                 break; 
09A56:  MOVLB  0
09A58:  BRA    9C22
....................  
....................             case DHCP_ROUTER: 
....................                 UDPGet(&j); 
09A5A:  MOVLW  03
09A5C:  MOVLB  3
09A5E:  MOVWF  x99
09A60:  MOVLW  91
09A62:  MOVWF  x98
09A64:  MOVLB  0
09A66:  RCALL  96D6
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
09A68:  MOVLB  3
09A6A:  MOVF   x91,W
09A6C:  SUBLW  03
09A6E:  BC    9AD6
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
09A70:  MOVLB  0
09A72:  BTFSS  x86.1
09A74:  BRA    9A96
....................                { 
....................                     // Discard offered Gateway address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
09A76:  MOVLB  3
09A78:  CLRF   x90
09A7A:  MOVF   x90,W
09A7C:  SUBLW  03
09A7E:  BNC   9A92
....................                         UDPGet(&v); 
09A80:  MOVLW  03
09A82:  MOVWF  x99
09A84:  MOVLW  8F
09A86:  MOVWF  x98
09A88:  MOVLB  0
09A8A:  RCALL  96D6
09A8C:  MOVLB  3
09A8E:  INCF   x90,F
09A90:  BRA    9A7A
....................                } 
....................                else 
09A92:  BRA    9AD4
09A94:  MOVLB  0
....................                { 
....................                        UDPGet(&tempGateway.v[0]); 
09A96:  MOVLW  01
09A98:  MOVLB  3
09A9A:  MOVWF  x99
09A9C:  MOVLW  4F
09A9E:  MOVWF  x98
09AA0:  MOVLB  0
09AA2:  RCALL  96D6
....................                        UDPGet(&tempGateway.v[1]); 
09AA4:  MOVLW  01
09AA6:  MOVLB  3
09AA8:  MOVWF  x99
09AAA:  MOVLW  50
09AAC:  MOVWF  x98
09AAE:  MOVLB  0
09AB0:  RCALL  96D6
....................                        UDPGet(&tempGateway.v[2]); 
09AB2:  MOVLW  01
09AB4:  MOVLB  3
09AB6:  MOVWF  x99
09AB8:  MOVLW  51
09ABA:  MOVWF  x98
09ABC:  MOVLB  0
09ABE:  RCALL  96D6
....................                        UDPGet(&tempGateway.v[3]); 
09AC0:  MOVLW  01
09AC2:  MOVLB  3
09AC4:  MOVWF  x99
09AC6:  MOVLW  52
09AC8:  MOVWF  x98
09ACA:  MOVLB  0
09ACC:  RCALL  96D6
....................                   ValidValues.bits.Gateway = 1; 
09ACE:  MOVLB  1
09AD0:  BSF    x57.1
09AD2:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
09AD4:  BRA    9AD8
....................                     goto UDPInvalid; 
09AD6:  BRA    9C7E
....................  
....................                 // Discard any other router addresses. 
....................                 j -= 4; 
09AD8:  MOVLW  04
09ADA:  SUBWF  x91,F
....................                 while(j--) 
....................                     UDPGet(&v); 
09ADC:  MOVF   x91,W
09ADE:  DECF   x91,F
09AE0:  XORLW  00
09AE2:  BZ    9AF4
09AE4:  MOVLW  03
09AE6:  MOVWF  x99
09AE8:  MOVLW  8F
09AEA:  MOVWF  x98
09AEC:  MOVLB  0
09AEE:  RCALL  96D6
09AF0:  MOVLB  3
09AF2:  BRA    9ADC
....................                 break; 
09AF4:  MOVLB  0
09AF6:  BRA    9C22
....................  
.................... #if STACK_USE_DNS 
....................             case DHCP_DNS: 
....................                 UDPGet(&j); 
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
....................                { 
....................                     // Discard offered DNS server address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
....................                         UDPGet(&v); 
....................                } 
....................                else 
....................                { 
....................                        UDPGet(&tempDNS.v[0]); 
....................                        UDPGet(&tempDNS.v[1]); 
....................                        UDPGet(&tempDNS.v[2]); 
....................                        UDPGet(&tempDNS.v[3]); 
....................                   ValidValues.bits.DNS = 1; 
....................                } 
....................                 } 
....................                 else 
....................                     goto UDPInvalid; 
....................  
....................                 // Discard any other DNS server addresses 
....................                 j -= 4; 
....................                 while(j--) 
....................                     UDPGet(&v); 
....................                 break; 
.................... #endif 
....................  
.................... //            case DHCP_HOST_NAME: 
.................... //                UDPGet(&j); 
.................... //                // Len must be >= 4. 
.................... //                if(j < 1u) 
.................... //               goto UDPInvalid; 
.................... // 
.................... //            // Check to see if this is the first offer 
.................... //            if(DHCPState.bits.bOfferReceived) 
.................... //            { 
.................... //                 // Discard offered host name, we already have an offer 
.................... //                   while(j--) 
.................... //                       UDPGet(&v); 
.................... //            } 
.................... //            else 
.................... //            { 
.................... //               for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
.................... //               { 
.................... //                  UDPGet(&tempHostName[i]); 
.................... //               } 
.................... //               while(j--) 
.................... //               { 
.................... //                  UDPGet(&v); 
.................... //               } 
.................... //               ValidValues.bits.HostName = 1; 
.................... //            } 
.................... // 
.................... //                break; 
....................  
....................             case DHCP_SERVER_IDENTIFIER: 
....................                 UDPGet(&v);                         // Get len 
09AF8:  MOVLW  03
09AFA:  MOVLB  3
09AFC:  MOVWF  x99
09AFE:  MOVLW  8F
09B00:  MOVWF  x98
09B02:  MOVLB  0
09B04:  RCALL  96D6
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
09B06:  MOVLB  3
09B08:  MOVF   x8F,W
09B0A:  SUBLW  04
09B0C:  BNZ   9B48
....................                 { 
....................                     UDPGet(&tempServerID.v[3]);   // Get the id 
09B0E:  MOVLW  03
09B10:  MOVWF  x99
09B12:  MOVLW  97
09B14:  MOVWF  x98
09B16:  MOVLB  0
09B18:  RCALL  96D6
....................                     UDPGet(&tempServerID.v[2]); 
09B1A:  MOVLW  03
09B1C:  MOVLB  3
09B1E:  MOVWF  x99
09B20:  MOVLW  96
09B22:  MOVWF  x98
09B24:  MOVLB  0
09B26:  RCALL  96D6
....................                     UDPGet(&tempServerID.v[1]); 
09B28:  MOVLW  03
09B2A:  MOVLB  3
09B2C:  MOVWF  x99
09B2E:  MOVLW  95
09B30:  MOVWF  x98
09B32:  MOVLB  0
09B34:  RCALL  96D6
....................                     UDPGet(&tempServerID.v[0]); 
09B36:  MOVLW  03
09B38:  MOVLB  3
09B3A:  MOVWF  x99
09B3C:  MOVLW  94
09B3E:  MOVWF  x98
09B40:  MOVLB  0
09B42:  RCALL  96D6
....................                 } 
....................                 else 
09B44:  BRA    9B4C
09B46:  MOVLB  3
....................                     goto UDPInvalid; 
09B48:  BRA    9C7E
09B4A:  MOVLB  0
....................                 break; 
09B4C:  BRA    9C22
....................  
....................             case DHCP_END_OPTION: 
....................                 lbDone = TRUE; 
09B4E:  MOVLB  3
09B50:  BSF    x93.0
....................                 break; 
09B52:  MOVLB  0
09B54:  BRA    9C22
....................  
....................             case DHCP_IP_LEASE_TIME: 
....................                 UDPGet(&v);                         // Get len 
09B56:  MOVLW  03
09B58:  MOVLB  3
09B5A:  MOVWF  x99
09B5C:  MOVLW  8F
09B5E:  MOVWF  x98
09B60:  MOVLB  0
09B62:  RCALL  96D6
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
09B64:  MOVLB  3
09B66:  MOVF   x8F,W
09B68:  SUBLW  04
09B6A:  BNZ   9BF6
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
09B6C:  MOVLB  0
09B6E:  BTFSS  x86.1
09B70:  BRA    9B92
....................                { 
....................                     // Discard offered lease time, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
09B72:  MOVLB  3
09B74:  CLRF   x90
09B76:  MOVF   x90,W
09B78:  SUBLW  03
09B7A:  BNC   9B8E
....................                         UDPGet(&v); 
09B7C:  MOVLW  03
09B7E:  MOVWF  x99
09B80:  MOVLW  8F
09B82:  MOVWF  x98
09B84:  MOVLB  0
09B86:  RCALL  96D6
09B88:  MOVLB  3
09B8A:  INCF   x90,F
09B8C:  BRA    9B76
....................                } 
....................                else 
09B8E:  BRA    9BF4
09B90:  MOVLB  0
....................                { 
....................                        UDPGet(&DHCPLeaseTime.v[3]); 
09B92:  MOVLW  01
09B94:  MOVLB  3
09B96:  MOVWF  x99
09B98:  MOVLW  4A
09B9A:  MOVWF  x98
09B9C:  MOVLB  0
09B9E:  RCALL  96D6
....................                        UDPGet(&DHCPLeaseTime.v[2]); 
09BA0:  MOVLW  01
09BA2:  MOVLB  3
09BA4:  MOVWF  x99
09BA6:  MOVLW  49
09BA8:  MOVWF  x98
09BAA:  MOVLB  0
09BAC:  RCALL  96D6
....................                        UDPGet(&DHCPLeaseTime.v[1]); 
09BAE:  MOVLW  01
09BB0:  MOVLB  3
09BB2:  MOVWF  x99
09BB4:  MOVLW  48
09BB6:  MOVWF  x98
09BB8:  MOVLB  0
09BBA:  RCALL  96D6
....................                        UDPGet(&DHCPLeaseTime.v[0]); 
09BBC:  MOVLW  01
09BBE:  MOVLB  3
09BC0:  MOVWF  x99
09BC2:  MOVLW  47
09BC4:  MOVWF  x98
09BC6:  MOVLB  0
09BC8:  RCALL  96D6
....................  
....................                        // Due to possible timing delays, consider actual lease 
....................                        // time less by half hour. 
....................                        if ( DHCPLeaseTime.Val > HALF_HOUR ) 
09BCA:  MOVLB  1
09BCC:  MOVF   x4A,F
09BCE:  BNZ   9BE4
09BD0:  MOVF   x49,F
09BD2:  BNZ   9BE4
09BD4:  MOVF   x48,W
09BD6:  SUBLW  06
09BD8:  BC    9BF2
09BDA:  XORLW  FF
09BDC:  BNZ   9BE4
09BDE:  MOVF   x47,W
09BE0:  SUBLW  08
09BE2:  BC    9BF2
....................                            DHCPLeaseTime.Val = DHCPLeaseTime.Val - HALF_HOUR; 
09BE4:  MOVLW  08
09BE6:  SUBWF  x47,F
09BE8:  MOVLW  07
09BEA:  SUBWFB x48,F
09BEC:  MOVLW  00
09BEE:  SUBWFB x49,F
09BF0:  SUBWFB x4A,F
09BF2:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
09BF4:  BRA    9BF8
....................                     goto UDPInvalid; 
09BF6:  BRA    9C7E
....................                 break; 
09BF8:  MOVLB  0
09BFA:  BRA    9C22
....................  
....................             default: 
....................                 // Ignore all unsupport tags. 
....................                 UDPGet(&j);                     // Get option len 
09BFC:  MOVLW  03
09BFE:  MOVLB  3
09C00:  MOVWF  x99
09C02:  MOVLW  91
09C04:  MOVWF  x98
09C06:  MOVLB  0
09C08:  RCALL  96D6
....................                 while( j-- )                    // Ignore option values 
....................                     UDPGet(&v); 
09C0A:  MOVLB  3
09C0C:  MOVF   x91,W
09C0E:  DECF   x91,F
09C10:  XORLW  00
09C12:  BZ    9C24
09C14:  MOVLW  03
09C16:  MOVWF  x99
09C18:  MOVLW  8F
09C1A:  MOVWF  x98
09C1C:  MOVLB  0
09C1E:  RCALL  96D6
09C20:  BRA    9C0A
09C22:  MOVLB  3
....................             } 
....................         } while( !lbDone ); 
09C24:  BTFSS  x93.0
09C26:  BRA    9958
....................     } 
....................  
....................     // If this is an OFFER message, remember current server id. 
....................     if ( type == DHCP_OFFER_MESSAGE ) 
09C28:  MOVF   x92,W
09C2A:  SUBLW  02
09C2C:  BNZ   9C46
....................     { 
....................         DHCPServerID.Val = tempServerID.Val; 
09C2E:  MOVFF  397,146
09C32:  MOVFF  396,145
09C36:  MOVFF  395,144
09C3A:  MOVFF  394,143
....................       DHCPState.bits.bOfferReceived = TRUE; 
09C3E:  MOVLB  0
09C40:  BSF    x86.1
....................     } 
....................     else 
09C42:  BRA    9C74
09C44:  MOVLB  3
....................     { 
....................         // For other types of messages, make sure that received 
....................         // server id matches with our previous one. 
....................         if ( DHCPServerID.Val != tempServerID.Val ) 
09C46:  MOVF   x94,W
09C48:  MOVLB  1
09C4A:  SUBWF  x43,W
09C4C:  BNZ   9C6C
09C4E:  MOVLB  3
09C50:  MOVF   x95,W
09C52:  MOVLB  1
09C54:  SUBWF  x44,W
09C56:  BNZ   9C6C
09C58:  MOVLB  3
09C5A:  MOVF   x96,W
09C5C:  MOVLB  1
09C5E:  SUBWF  x45,W
09C60:  BNZ   9C6C
09C62:  MOVLB  3
09C64:  MOVF   x97,W
09C66:  MOVLB  1
09C68:  SUBWF  x46,W
09C6A:  BZ    9C72
....................             type = DHCP_UNKNOWN_MESSAGE; 
09C6C:  MOVLB  3
09C6E:  CLRF   x92
09C70:  MOVLB  1
09C72:  MOVLB  0
....................     } 
....................  
....................     UDPDiscard();                             // We are done with this packet 
09C74:  RCALL  97F0
....................     return type; 
09C76:  MOVLB  3
09C78:  MOVFF  392,01
09C7C:  BRA    9C88
....................  
.................... UDPInvalid: 
....................     UDPDiscard(); 
09C7E:  MOVLB  0
09C80:  RCALL  97F0
....................     return DHCP_UNKNOWN_MESSAGE; 
09C82:  MOVLW  00
09C84:  MOVWF  01
09C86:  MOVLB  3
....................  
.................... } 
09C88:  MOVLB  0
09C8A:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... static void _DHCPSend(BYTE messageType) 
.................... { 
....................     BYTE  i; 
....................  
....................     UDPPut(BOOT_REQUEST);                       // op 
*
09436:  MOVLW  01
09438:  MOVLB  3
0943A:  MOVWF  x91
0943C:  MOVLB  0
0943E:  CALL   60AE
....................     UDPPut(HW_TYPE);                            // htype 
09442:  MOVLW  01
09444:  MOVLB  3
09446:  MOVWF  x91
09448:  MOVLB  0
0944A:  CALL   60AE
....................     UDPPut(LEN_OF_HW_TYPE);                     // hlen 
0944E:  MOVLW  06
09450:  MOVLB  3
09452:  MOVWF  x91
09454:  MOVLB  0
09456:  CALL   60AE
....................     UDPPut(0);                                  // hops 
0945A:  MOVLB  3
0945C:  CLRF   x91
0945E:  MOVLB  0
09460:  CALL   60AE
....................     UDPPut(0x12);                               // xid[0] 
09464:  MOVLW  12
09466:  MOVLB  3
09468:  MOVWF  x91
0946A:  MOVLB  0
0946C:  CALL   60AE
....................     UDPPut(0x23);                               // xid[1] 
09470:  MOVLW  23
09472:  MOVLB  3
09474:  MOVWF  x91
09476:  MOVLB  0
09478:  CALL   60AE
....................     UDPPut(0x34);                               // xid[2] 
0947C:  MOVLW  34
0947E:  MOVLB  3
09480:  MOVWF  x91
09482:  MOVLB  0
09484:  CALL   60AE
....................     UDPPut(0x56);                               // xid[3] 
09488:  MOVLW  56
0948A:  MOVLB  3
0948C:  MOVWF  x91
0948E:  MOVLB  0
09490:  CALL   60AE
....................     UDPPut(0);                                  // secs[0] 
09494:  MOVLB  3
09496:  CLRF   x91
09498:  MOVLB  0
0949A:  CALL   60AE
....................     UDPPut(0);                                  // secs[1] 
0949E:  MOVLB  3
094A0:  CLRF   x91
094A2:  MOVLB  0
094A4:  CALL   60AE
....................     UDPPut(0x80);                               // flags[0] with BF set 
094A8:  MOVLW  80
094AA:  MOVLB  3
094AC:  MOVWF  x91
094AE:  MOVLB  0
094B0:  CALL   60AE
....................     UDPPut(0);                                  // flags[1] 
094B4:  MOVLB  3
094B6:  CLRF   x91
094B8:  MOVLB  0
094BA:  CALL   60AE
....................  
....................  
....................      // If this is DHCP REQUEST message, use previously allocated IP address. 
.................... #if 0 
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
....................     { 
....................         UDPPut(tempIPAddress.v[0]); 
....................         UDPPut(tempIPAddress.v[1]); 
....................         UDPPut(tempIPAddress.v[2]); 
....................         UDPPut(tempIPAddress.v[3]); 
....................     } 
....................     else 
.................... #endif 
....................     { 
....................         UDPPut(0x00); 
094BE:  MOVLB  3
094C0:  CLRF   x91
094C2:  MOVLB  0
094C4:  CALL   60AE
....................         UDPPut(0x00); 
094C8:  MOVLB  3
094CA:  CLRF   x91
094CC:  MOVLB  0
094CE:  CALL   60AE
....................         UDPPut(0x00); 
094D2:  MOVLB  3
094D4:  CLRF   x91
094D6:  MOVLB  0
094D8:  CALL   60AE
....................         UDPPut(0x00); 
094DC:  MOVLB  3
094DE:  CLRF   x91
094E0:  MOVLB  0
094E2:  CALL   60AE
....................     } 
....................  
....................     // Set yiaddr, siaddr, giaddr as zeros, 
....................     for ( i = 0; i < 12u; i++ ) 
094E6:  MOVLB  3
094E8:  CLRF   x90
094EA:  MOVF   x90,W
094EC:  SUBLW  0B
094EE:  BNC   94FE
....................         UDPPut(0x00); 
094F0:  CLRF   x91
094F2:  MOVLB  0
094F4:  CALL   60AE
094F8:  MOVLB  3
094FA:  INCF   x90,F
094FC:  BRA    94EA
....................  
....................     // Load chaddr - Client hardware address. 
....................     UDPPut(AppConfig.MyMACAddr.v[0]); 
094FE:  MOVFF  1A,391
09502:  MOVLB  0
09504:  CALL   60AE
....................     UDPPut(AppConfig.MyMACAddr.v[1]); 
09508:  MOVFF  1B,391
0950C:  CALL   60AE
....................     UDPPut(AppConfig.MyMACAddr.v[2]); 
09510:  MOVFF  1C,391
09514:  CALL   60AE
....................     UDPPut(AppConfig.MyMACAddr.v[3]); 
09518:  MOVFF  1D,391
0951C:  CALL   60AE
....................     UDPPut(AppConfig.MyMACAddr.v[4]); 
09520:  MOVFF  1E,391
09524:  CALL   60AE
....................     UDPPut(AppConfig.MyMACAddr.v[5]); 
09528:  MOVFF  1F,391
0952C:  CALL   60AE
....................  
....................     // Set chaddr[6..15], sname and file as zeros. 
....................     for ( i = 0; i < 202u; i++ ) 
09530:  MOVLB  3
09532:  CLRF   x90
09534:  MOVF   x90,W
09536:  SUBLW  C9
09538:  BNC   9548
....................         UDPPut(0); 
0953A:  CLRF   x91
0953C:  MOVLB  0
0953E:  CALL   60AE
09542:  MOVLB  3
09544:  INCF   x90,F
09546:  BRA    9534
....................  
....................     // Load magic cookie as per RFC 1533. 
....................     UDPPut(99); 
09548:  MOVLW  63
0954A:  MOVWF  x91
0954C:  MOVLB  0
0954E:  CALL   60AE
....................     UDPPut(130); 
09552:  MOVLW  82
09554:  MOVLB  3
09556:  MOVWF  x91
09558:  MOVLB  0
0955A:  CALL   60AE
....................     UDPPut(83); 
0955E:  MOVLW  53
09560:  MOVLB  3
09562:  MOVWF  x91
09564:  MOVLB  0
09566:  CALL   60AE
....................     UDPPut(99); 
0956A:  MOVLW  63
0956C:  MOVLB  3
0956E:  MOVWF  x91
09570:  MOVLB  0
09572:  CALL   60AE
....................  
....................     // Load message type. 
....................     UDPPut(DHCP_MESSAGE_TYPE); 
09576:  MOVLW  35
09578:  MOVLB  3
0957A:  MOVWF  x91
0957C:  MOVLB  0
0957E:  CALL   60AE
....................     UDPPut(DHCP_MESSAGE_TYPE_LEN); 
09582:  MOVLW  01
09584:  MOVLB  3
09586:  MOVWF  x91
09588:  MOVLB  0
0958A:  CALL   60AE
....................     UDPPut(messageType); 
0958E:  MOVFF  38F,391
09592:  CALL   60AE
....................  
....................    if(messageType == DHCP_DISCOVER_MESSAGE) 
09596:  MOVLB  3
09598:  DECFSZ x8F,W
0959A:  BRA    95A2
....................    { 
....................       // Reset offered flag so we know to act upon the next valid offer 
....................       DHCPState.bits.bOfferReceived = FALSE; 
0959C:  MOVLB  0
0959E:  BCF    x86.1
095A0:  MOVLB  3
....................    } 
....................  
....................     if ( messageType != DHCP_DISCOVER_MESSAGE && tempIPAddress.Val != 0x0000u ) 
095A2:  DECFSZ x8F,W
095A4:  BRA    95A8
095A6:  BRA    95FA
095A8:  MOVLB  1
095AA:  MOVF   x4B,F
095AC:  BNZ   95C0
095AE:  MOVF   x4C,F
095B0:  BNZ   95C0
095B2:  MOVF   x4D,F
095B4:  BNZ   95C0
095B6:  MOVF   x4E,F
095B8:  BTFSS  FD8.2
095BA:  BRA    95C0
095BC:  MOVLB  3
095BE:  BRA    95FA
....................     { 
....................          // DHCP REQUEST message may include server identifier, 
....................          // to identify the server we are talking to. 
....................          // DHCP ACK may include it too.  To simplify logic, 
....................          // we will include server identifier in DHCP ACK message too. 
....................          // _DHCPReceive() would populate "serverID" when it 
....................          // receives DHCP OFFER message. We will simply use that 
....................          // when we are replying to server. 
....................          // If this is a renwal request, do not include server id. 
....................          UDPPut(DHCP_SERVER_IDENTIFIER); 
095C0:  MOVLW  36
095C2:  MOVLB  3
095C4:  MOVWF  x91
095C6:  MOVLB  0
095C8:  CALL   60AE
....................          UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
095CC:  MOVLW  04
095CE:  MOVLB  3
095D0:  MOVWF  x91
095D2:  MOVLB  0
095D4:  CALL   60AE
....................          UDPPut(DHCPServerID.v[3]); 
095D8:  MOVFF  146,391
095DC:  CALL   60AE
....................          UDPPut(DHCPServerID.v[2]); 
095E0:  MOVFF  145,391
095E4:  CALL   60AE
....................          UDPPut(DHCPServerID.v[1]); 
095E8:  MOVFF  144,391
095EC:  CALL   60AE
....................          UDPPut(DHCPServerID.v[0]); 
095F0:  MOVFF  143,391
095F4:  CALL   60AE
095F8:  MOVLB  3
....................      } 
....................  
....................     // Load our interested parameters 
....................     // This is hardcoded list.  If any new parameters are desired, 
....................     // new lines must be added here. 
....................     UDPPut(DHCP_PARAM_REQUEST_LIST); 
095FA:  MOVLW  37
095FC:  MOVWF  x91
095FE:  MOVLB  0
09600:  CALL   60AE
....................     UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
09604:  MOVLW  04
09606:  MOVLB  3
09608:  MOVWF  x91
0960A:  MOVLB  0
0960C:  CALL   60AE
....................     UDPPut(DHCP_SUBNET_MASK); 
09610:  MOVLW  01
09612:  MOVLB  3
09614:  MOVWF  x91
09616:  MOVLB  0
09618:  CALL   60AE
....................     UDPPut(DHCP_ROUTER); 
0961C:  MOVLW  03
0961E:  MOVLB  3
09620:  MOVWF  x91
09622:  MOVLB  0
09624:  CALL   60AE
....................     UDPPut(DHCP_DNS); 
09628:  MOVLW  06
0962A:  MOVLB  3
0962C:  MOVWF  x91
0962E:  MOVLB  0
09630:  CALL   60AE
....................     UDPPut(DHCP_HOST_NAME); 
09634:  MOVLW  0C
09636:  MOVLB  3
09638:  MOVWF  x91
0963A:  MOVLB  0
0963C:  CALL   60AE
....................  
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
09640:  MOVLB  3
09642:  MOVF   x8F,W
09644:  SUBLW  03
09646:  BNZ   9680
....................     { 
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
09648:  MOVLW  32
0964A:  MOVWF  x91
0964C:  MOVLB  0
0964E:  CALL   60AE
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
09652:  MOVLW  04
09654:  MOVLB  3
09656:  MOVWF  x91
09658:  MOVLB  0
0965A:  CALL   60AE
....................  
....................         UDPPut(tempIPAddress.v[0]); 
0965E:  MOVFF  14B,391
09662:  CALL   60AE
....................         UDPPut(tempIPAddress.v[1]); 
09666:  MOVFF  14C,391
0966A:  CALL   60AE
....................         UDPPut(tempIPAddress.v[2]); 
0966E:  MOVFF  14D,391
09672:  CALL   60AE
....................         UDPPut(tempIPAddress.v[3]); 
09676:  MOVFF  14E,391
0967A:  CALL   60AE
0967E:  MOVLB  3
....................     } 
....................  
....................     // Add any new paramter request here. 
....................  
....................     // End of Options. 
....................     UDPPut(DHCP_END_OPTION); 
09680:  MOVLW  FF
09682:  MOVWF  x91
09684:  MOVLB  0
09686:  CALL   60AE
....................  
....................     UDPFlush(); 
0968A:  CALL   5F56
.................... } 
0968E:  RETLW  00
....................  
....................  
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
014BC:  BCF    56.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
014BE:  MOVLW  FF
014C0:  MOVLB  1
014C2:  MOVWF  x5B
....................     Cache.MACAddr.v[1] = 0xff; 
014C4:  MOVWF  x5C
....................     Cache.MACAddr.v[2] = 0xff; 
014C6:  MOVWF  x5D
....................     Cache.MACAddr.v[3] = 0xff; 
014C8:  MOVWF  x5E
....................     Cache.MACAddr.v[4] = 0xff; 
014CA:  MOVWF  x5F
....................     Cache.MACAddr.v[5] = 0xff; 
014CC:  MOVWF  x60
....................  
....................     Cache.IPAddr.Val = 0x0; 
014CE:  CLRF   x64
014D0:  CLRF   x63
014D2:  CLRF   x62
014D4:  CLRF   x61
.................... } 
014D6:  MOVLB  0
014D8:  GOTO   198E (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
03A10:  MOVLW  00
03A12:  BTFSC  56.1
03A14:  MOVLW  01
03A16:  XORLW  00
03A18:  BZ    3A1C
03A1A:  BRA    3A7A
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
03A1C:  MOVLW  03
03A1E:  MOVLB  3
03A20:  MOVWF  x8E
03A22:  MOVLW  82
03A24:  MOVWF  x8D
03A26:  MOVLW  03
03A28:  MOVWF  x90
03A2A:  MOVLW  8C
03A2C:  MOVWF  x8F
03A2E:  MOVLB  0
03A30:  BRA    3368
03A32:  MOVF   01,F
03A34:  BNZ   3A38
....................             break; 
03A36:  BRA    3A9A
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
03A38:  CALL   3070
....................  
....................         if ( opCode == ARP_REPLY ) 
03A3C:  MOVLB  3
03A3E:  MOVF   x8C,F
03A40:  BNZ   3A76
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
03A42:  MOVLW  01
03A44:  MOVWF  FEA
03A46:  MOVLW  5B
03A48:  MOVWF  FE9
03A4A:  MOVLW  03
03A4C:  MOVWF  FE2
03A4E:  MOVLW  82
03A50:  MOVWF  FE1
03A52:  MOVLW  06
03A54:  MOVWF  01
03A56:  MOVFF  FE6,FEE
03A5A:  DECFSZ 01,F
03A5C:  BRA    3A56
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
03A5E:  MOVFF  38B,164
03A62:  MOVFF  38A,163
03A66:  MOVFF  389,162
03A6A:  MOVFF  388,161
....................             break; 
03A6E:  MOVLB  0
03A70:  BRA    3A9A
....................         } 
....................         else 
03A72:  BRA    3A7A
03A74:  MOVLB  3
....................             smARP = SM_ARP_REPLY; 
03A76:  BSF    56.1
03A78:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
03A7A:  MOVLW  03
03A7C:  MOVLB  3
03A7E:  MOVWF  x8E
03A80:  MOVLW  82
03A82:  MOVWF  x8D
03A84:  CLRF   x8F
03A86:  MOVLB  0
03A88:  BRA    3880
03A8A:  MOVF   01,F
03A8C:  BZ    3A92
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
03A8E:  BCF    56.1
.................... 		} 
....................         else 
03A90:  BRA    3A98
....................             return FALSE; 
03A92:  MOVLW  00
03A94:  MOVWF  01
03A96:  BRA    3A9E
....................         break; 
03A98:  BRA    3A9A
....................  
....................     } 
....................     return TRUE; 
03A9A:  MOVLW  01
03A9C:  MOVWF  01
.................... } 
03A9E:  GOTO   A19E (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
03368:  MOVLW  03
0336A:  MOVLB  4
0336C:  MOVWF  x1A
0336E:  MOVLW  91
03370:  MOVWF  x19
03372:  CLRF   x1C
03374:  MOVLW  1C
03376:  MOVWF  x1B
03378:  MOVLB  0
0337A:  RCALL  30DE
....................  
....................     MACDiscardRx(); 
0337C:  RCALL  3070
....................  
....................     SwapARPPacket(&packet); 
0337E:  MOVLW  03
03380:  MOVLB  3
03382:  MOVWF  xAE
03384:  MOVLW  91
03386:  MOVWF  xAD
03388:  MOVLB  0
0338A:  RCALL  3294
....................  
....................    debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
0338C:  MOVLB  3
0338E:  DECFSZ x91,W
03390:  BRA    33A2
03392:  MOVF   x92,F
03394:  BNZ   33A2
03396:  MOVF   x95,W
03398:  SUBLW  06
0339A:  BNZ   33A2
0339C:  MOVF   x96,W
0339E:  SUBLW  04
033A0:  BZ    33A8
....................          return FALSE; 
033A2:  MOVLW  00
033A4:  MOVWF  01
033A6:  BRA    3444
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
033A8:  MOVF   x97,W
033AA:  SUBLW  02
033AC:  BNZ   33BE
033AE:  MOVF   x98,F
033B0:  BNZ   33BE
....................         *opCode = ARP_REPLY; 
033B2:  MOVFF  38F,FE9
033B6:  MOVFF  390,FEA
033BA:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
033BC:  BRA    33E6
033BE:  DECFSZ x97,W
033C0:  BRA    33D4
033C2:  MOVF   x98,F
033C4:  BNZ   33D4
....................         *opCode = ARP_REQUEST; 
033C6:  MOVFF  38F,FE9
033CA:  MOVFF  390,FEA
033CE:  MOVLW  01
033D0:  MOVWF  FEF
....................     else 
033D2:  BRA    33E6
....................     { 
....................         *opCode = ARP_UNKNOWN; 
033D4:  MOVFF  38F,FE9
033D8:  MOVFF  390,FEA
033DC:  MOVLW  02
033DE:  MOVWF  FEF
....................         return FALSE; 
033E0:  MOVLW  00
033E2:  MOVWF  01
033E4:  BRA    3444
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
033E6:  MOVF   16,W
033E8:  SUBWF  xA9,W
033EA:  BNZ   343E
033EC:  MOVF   17,W
033EE:  SUBWF  xAA,W
033F0:  BNZ   343E
033F2:  MOVF   18,W
033F4:  SUBWF  xAB,W
033F6:  BNZ   343E
033F8:  MOVF   19,W
033FA:  SUBWF  xAC,W
033FC:  BNZ   343E
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
033FE:  MOVFF  38D,FE9
03402:  MOVFF  38E,FEA
03406:  MOVLW  03
03408:  MOVWF  FE2
0340A:  MOVLW  99
0340C:  MOVWF  FE1
0340E:  MOVLW  06
03410:  MOVWF  01
03412:  MOVFF  FE6,FEE
03416:  DECFSZ 01,F
03418:  BRA    3412
....................         remote->IPAddr      = packet.SenderIPAddr; 
0341A:  MOVLW  06
0341C:  ADDWF  x8D,W
0341E:  MOVWF  FE9
03420:  MOVLW  00
03422:  ADDWFC x8E,W
03424:  MOVWF  FEA
03426:  MOVFF  39F,FEF
0342A:  MOVFF  3A0,FEC
0342E:  MOVFF  3A1,FEC
03432:  MOVFF  3A2,FEC
....................         return TRUE; 
03436:  MOVLW  01
03438:  MOVWF  01
0343A:  BRA    3444
....................     } 
....................     else 
0343C:  BRA    3444
....................         return FALSE; 
0343E:  MOVLW  00
03440:  MOVWF  01
03442:  BRA    3444
.................... } 
03444:  MOVLB  0
03446:  GOTO   3A32 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *					FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
*
03880:  MOVLW  01
03882:  MOVLB  4
03884:  MOVWF  x0B
03886:  MOVLB  0
03888:  RCALL  344A
0388A:  MOVFF  01,3AC
.................... 	 
.................... 	// Do not respond if there is no room to generate the ARP reply 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
0388E:  MOVLB  3
03890:  INCFSZ xAC,W
03892:  BRA    389A
.................... 		return FALSE; 
03894:  MOVLW  00
03896:  MOVWF  01
03898:  BRA    3A0A
....................  
.................... 	MACSetTxBuffer(MyTxBuffer, 0); 
0389A:  MOVFF  3AC,424
0389E:  MOVLB  4
038A0:  CLRF   x26
038A2:  CLRF   x25
038A4:  MOVLB  0
038A6:  RCALL  3474
.................... 	 
.................... 	 
....................     packet.HardwareType             = HW_ETHERNET; 
038A8:  MOVLB  3
038AA:  CLRF   x91
038AC:  MOVLW  01
038AE:  MOVWF  x90
....................     packet.Protocol                 = ARP_IP; 
038B0:  MOVLW  08
038B2:  MOVWF  x93
038B4:  CLRF   x92
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
038B6:  MOVLW  06
038B8:  MOVWF  x94
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
038BA:  MOVLW  04
038BC:  MOVWF  x95
....................  
....................     if ( opCode == ARP_REQUEST ) 
038BE:  DECFSZ x8F,W
038C0:  BRA    38D8
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
038C2:  CLRF   x97
038C4:  MOVLW  01
038C6:  MOVWF  x96
....................         packet.TargetMACAddr.v[0]   = 0xff; 
038C8:  MOVLW  FF
038CA:  MOVWF  xA2
....................         packet.TargetMACAddr.v[1]   = 0xff; 
038CC:  MOVWF  xA3
....................         packet.TargetMACAddr.v[2]   = 0xff; 
038CE:  MOVWF  xA4
....................         packet.TargetMACAddr.v[3]   = 0xff; 
038D0:  MOVWF  xA5
....................         packet.TargetMACAddr.v[4]   = 0xff; 
038D2:  MOVWF  xA6
....................         packet.TargetMACAddr.v[5]   = 0xff; 
038D4:  MOVWF  xA7
....................     } 
....................     else 
038D6:  BRA    3906
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
038D8:  CLRF   x97
038DA:  MOVLW  02
038DC:  MOVWF  x96
....................         packet.TargetMACAddr        = remote->MACAddr; 
038DE:  MOVFF  38E,03
038E2:  MOVFF  38D,3AD
038E6:  MOVFF  38E,3AE
038EA:  MOVLW  03
038EC:  MOVWF  FEA
038EE:  MOVLW  A2
038F0:  MOVWF  FE9
038F2:  MOVFF  38E,FE2
038F6:  MOVFF  38D,FE1
038FA:  MOVLW  06
038FC:  MOVWF  01
038FE:  MOVFF  FE6,FEE
03902:  DECFSZ 01,F
03904:  BRA    38FE
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
03906:  MOVLW  03
03908:  MOVWF  FEA
0390A:  MOVLW  98
0390C:  MOVWF  FE9
0390E:  CLRF   FE2
03910:  MOVLW  1A
03912:  MOVWF  FE1
03914:  MOVLW  06
03916:  MOVWF  01
03918:  MOVFF  FE6,FEE
0391C:  DECFSZ 01,F
0391E:  BRA    3918
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
03920:  MOVFF  19,3A1
03924:  MOVFF  18,3A0
03928:  MOVFF  17,39F
0392C:  MOVFF  16,39E
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
03930:  MOVLW  06
03932:  ADDWF  x8D,W
03934:  MOVWF  FE9
03936:  MOVLW  00
03938:  ADDWFC x8E,W
0393A:  MOVWF  FEA
0393C:  MOVFF  FEF,00
03940:  MOVFF  FEC,01
03944:  MOVFF  FEC,02
03948:  MOVFF  FEC,03
0394C:  MOVF   00,W
0394E:  XORWF  x9E,W
03950:  MOVWF  xAD
03952:  MOVF   01,W
03954:  XORWF  x9F,W
03956:  MOVWF  xAE
03958:  MOVF   02,W
0395A:  XORWF  xA0,W
0395C:  MOVWF  xAF
0395E:  MOVF   03,W
03960:  XORWF  xA1,W
03962:  MOVWF  xB0
03964:  MOVF   xAD,W
03966:  ANDWF  20,W
03968:  MOVWF  00
0396A:  MOVF   xAE,W
0396C:  ANDWF  21,W
0396E:  MOVWF  01
03970:  MOVF   xAF,W
03972:  ANDWF  22,W
03974:  MOVWF  02
03976:  MOVF   xB0,W
03978:  ANDWF  23,W
0397A:  MOVWF  03
0397C:  MOVF   00,F
0397E:  BNZ   398C
03980:  MOVF   01,F
03982:  BNZ   398C
03984:  MOVF   02,F
03986:  BNZ   398C
03988:  MOVF   03,F
0398A:  BZ    399E
....................     { 
.................... 		packet.TargetIPAddr = AppConfig.MyGateway; 
0398C:  MOVFF  27,3AB
03990:  MOVFF  26,3AA
03994:  MOVFF  25,3A9
03998:  MOVFF  24,3A8
....................     } 
....................     else 
0399C:  BRA    39CA
....................         packet.TargetIPAddr             = remote->IPAddr; 
0399E:  MOVLW  06
039A0:  ADDWF  x8D,W
039A2:  MOVWF  FE9
039A4:  MOVLW  00
039A6:  ADDWFC x8E,W
039A8:  MOVWF  FEA
039AA:  MOVFF  FEF,00
039AE:  MOVFF  FEC,01
039B2:  MOVFF  FEC,02
039B6:  MOVFF  FEC,03
039BA:  MOVFF  03,3AB
039BE:  MOVFF  02,3AA
039C2:  MOVFF  01,3A9
039C6:  MOVFF  00,3A8
....................  
....................     SwapARPPacket(&packet); 
039CA:  MOVLW  03
039CC:  MOVWF  xAE
039CE:  MOVLW  90
039D0:  MOVWF  xAD
039D2:  MOVLB  0
039D4:  RCALL  3294
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
039D6:  MOVLW  03
039D8:  MOVLB  4
039DA:  MOVWF  x29
039DC:  MOVLW  A2
039DE:  MOVWF  x28
039E0:  MOVLW  06
039E2:  MOVWF  x2A
039E4:  CLRF   x2C
039E6:  MOVLW  1C
039E8:  MOVWF  x2B
039EA:  MOVLB  0
039EC:  RCALL  358A
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
039EE:  MOVLW  03
039F0:  MOVLB  4
039F2:  MOVWF  x30
039F4:  MOVLW  90
039F6:  MOVWF  x2F
039F8:  CLRF   x32
039FA:  MOVLW  1C
039FC:  MOVWF  x31
039FE:  MOVLB  0
03A00:  RCALL  353C
....................  
....................     MACFlush(); 
03A02:  RCALL  3658
.................... 	 
.................... 	return TRUE; 
03A04:  MOVLW  01
03A06:  MOVWF  01
03A08:  MOVLB  3
.................... } 
03A0A:  MOVLB  0
03A0C:  GOTO   3A8A (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
03294:  MOVLB  3
03296:  MOVFF  3AD,01
0329A:  MOVFF  3AE,03
0329E:  MOVFF  3AD,3AF
032A2:  MOVFF  3AE,3B0
032A6:  MOVFF  3AD,FE9
032AA:  MOVFF  3AE,FEA
032AE:  MOVFF  FEC,3B2
032B2:  MOVF   FED,F
032B4:  MOVFF  FEF,3B1
032B8:  MOVFF  3B2,42B
032BC:  MOVFF  3B1,42A
032C0:  MOVLB  0
032C2:  RCALL  3142
032C4:  MOVFF  3B0,FEA
032C8:  MOVFF  3AF,FE9
032CC:  MOVFF  02,FEC
032D0:  MOVF   FED,F
032D2:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
032D6:  MOVLW  02
032D8:  MOVLB  3
032DA:  ADDWF  xAD,W
032DC:  MOVWF  01
032DE:  MOVLW  00
032E0:  ADDWFC xAE,W
032E2:  MOVWF  03
032E4:  MOVFF  01,3AF
032E8:  MOVWF  xB0
032EA:  MOVLW  02
032EC:  ADDWF  xAD,W
032EE:  MOVWF  FE9
032F0:  MOVLW  00
032F2:  ADDWFC xAE,W
032F4:  MOVWF  FEA
032F6:  MOVFF  FEC,3B2
032FA:  MOVF   FED,F
032FC:  MOVFF  FEF,3B1
03300:  MOVFF  3B2,42B
03304:  MOVFF  3B1,42A
03308:  MOVLB  0
0330A:  RCALL  3142
0330C:  MOVFF  3B0,FEA
03310:  MOVFF  3AF,FE9
03314:  MOVFF  02,FEC
03318:  MOVF   FED,F
0331A:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
0331E:  MOVLW  06
03320:  MOVLB  3
03322:  ADDWF  xAD,W
03324:  MOVWF  01
03326:  MOVLW  00
03328:  ADDWFC xAE,W
0332A:  MOVWF  03
0332C:  MOVFF  01,3AF
03330:  MOVWF  xB0
03332:  MOVLW  06
03334:  ADDWF  xAD,W
03336:  MOVWF  FE9
03338:  MOVLW  00
0333A:  ADDWFC xAE,W
0333C:  MOVWF  FEA
0333E:  MOVFF  FEC,3B2
03342:  MOVF   FED,F
03344:  MOVFF  FEF,3B1
03348:  MOVFF  3B2,42B
0334C:  MOVFF  3B1,42A
03350:  MOVLB  0
03352:  RCALL  3142
03354:  MOVFF  3B0,FEA
03358:  MOVFF  3AF,FE9
0335C:  MOVFF  02,FEC
03360:  MOVF   FED,F
03362:  MOVFF  01,FEF
.................... } 
03366:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
07062:  MOVLB  3
07064:  CLRF   xA1
....................  
....................    ostr = str; 
07066:  MOVFF  39C,39E
0706A:  MOVFF  39B,39D
....................  
....................    while((c=*str) != 0) 
....................    { 
0706E:  MOVFF  39C,03
07072:  MOVFF  39B,FE9
07076:  MOVFF  39C,FEA
0707A:  MOVFF  FEF,3A2
0707E:  MOVF   xA2,F
07080:  BZ    7142
....................       if (c=='+') 
07082:  MOVF   xA2,W
07084:  SUBLW  2B
07086:  BNZ   70A0
....................          *str++=' '; 
07088:  MOVFF  39C,03
0708C:  MOVF   x9B,W
0708E:  INCF   x9B,F
07090:  BTFSC  FD8.2
07092:  INCF   x9C,F
07094:  MOVWF  FE9
07096:  MOVFF  03,FEA
0709A:  MOVLW  20
0709C:  MOVWF  FEF
....................       else if (c=='%') 
0709E:  BRA    713E
070A0:  MOVF   xA2,W
070A2:  SUBLW  25
070A4:  BNZ   7138
....................       { 
....................          memcpy(new, str + 1, 2); 
070A6:  MOVLW  01
070A8:  ADDWF  x9B,W
070AA:  MOVWF  xA4
070AC:  MOVLW  00
070AE:  ADDWFC x9C,W
070B0:  MOVWF  xA5
070B2:  MOVLW  03
070B4:  MOVWF  FEA
070B6:  MOVLW  9F
070B8:  MOVWF  FE9
070BA:  MOVFF  3A5,FE2
070BE:  MOVFF  3A4,FE1
070C2:  MOVLW  02
070C4:  MOVWF  01
070C6:  MOVFF  FE6,FEE
070CA:  DECFSZ 01,F
070CC:  BRA    70C6
....................          val = strtoul(new, 0, 16); 
070CE:  MOVLW  03
070D0:  MOVWF  xA5
070D2:  MOVLW  9F
070D4:  MOVWF  xA4
070D6:  CLRF   xA7
070D8:  CLRF   xA6
070DA:  MOVLW  10
070DC:  MOVWF  xA8
070DE:  MOVLB  0
070E0:  BRA    6BF0
070E2:  MOVFF  01,3A3
....................          *str++ = val; 
070E6:  MOVLB  3
070E8:  MOVFF  39C,03
070EC:  MOVF   x9B,W
070EE:  INCF   x9B,F
070F0:  BTFSC  FD8.2
070F2:  INCF   x9C,F
070F4:  MOVWF  FE9
070F6:  MOVFF  03,FEA
070FA:  MOVFF  3A3,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
070FE:  MOVLW  02
07100:  ADDWF  x9B,W
07102:  MOVWF  xA4
07104:  MOVLW  00
07106:  ADDWFC x9C,W
07108:  MOVWF  xA5
0710A:  MOVFF  39C,3BE
0710E:  MOVFF  39B,3BD
07112:  MOVLB  0
07114:  RCALL  6F5E
07116:  MOVLW  01
07118:  SUBWF  01,W
0711A:  MOVLB  3
0711C:  MOVWF  xA6
0711E:  MOVFF  39C,3A8
07122:  MOVFF  39B,3A7
07126:  MOVFF  3A5,3AA
0712A:  MOVFF  3A4,3A9
0712E:  MOVWF  xAB
07130:  MOVLB  0
07132:  BRA    6F98
....................       } 
....................       else 
07134:  BRA    713E
07136:  MOVLB  3
....................          str++; 
07138:  INCF   x9B,F
0713A:  BTFSC  FD8.2
0713C:  INCF   x9C,F
....................    } 
0713E:  MOVLB  3
07140:  BRA    706E
....................  
....................    return(ostr); 
07142:  MOVFF  39D,01
07146:  MOVFF  39E,02
.................... } 
0714A:  MOVLB  0
0714C:  RETLW  00
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
07658:  MOVFF  395,397
0765C:  MOVFF  394,396
....................    pValue=0; 
07660:  MOVLB  3
07662:  CLRF   x99
07664:  CLRF   x98
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
07666:  MOVFF  394,FE9
0766A:  MOVFF  395,FEA
0766E:  MOVFF  FEF,39A
....................       if ((c=='&') || (c==0)) 
07672:  MOVF   x9A,W
07674:  SUBLW  26
07676:  BZ    767C
07678:  MOVF   x9A,F
0767A:  BNZ   76D8
....................       { 
....................          *ptr=0; 
0767C:  MOVFF  394,FE9
07680:  MOVFF  395,FEA
07684:  CLRF   FEF
....................          http_escape_chars(pKey); 
07686:  MOVFF  397,39C
0768A:  MOVFF  396,39B
0768E:  MOVLB  0
07690:  RCALL  7062
....................          http_escape_chars(pValue); 
07692:  MOVFF  399,39C
07696:  MOVFF  398,39B
0769A:  RCALL  7062
....................          http_exec_cgi(file, pKey, pValue); 
0769C:  MOVFF  393,39E
076A0:  MOVFF  392,39D
076A4:  MOVFF  391,39C
076A8:  MOVFF  390,39B
076AC:  MOVFF  397,3A0
076B0:  MOVFF  396,39F
076B4:  MOVFF  399,3A2
076B8:  MOVFF  398,3A1
076BC:  BRA    7578
....................          pKey=ptr+1; 
076BE:  MOVLW  01
076C0:  MOVLB  3
076C2:  ADDWF  x94,W
076C4:  MOVWF  x96
076C6:  MOVLW  00
076C8:  ADDWFC x95,W
076CA:  MOVWF  x97
....................          pValue=0; 
076CC:  CLRF   x99
076CE:  CLRF   x98
....................          if (c==0) 
076D0:  MOVF   x9A,F
076D2:  BNZ   76D6
....................             break; 
076D4:  BRA    76FC
....................       } 
....................       else if (c=='=') 
076D6:  BRA    76F4
076D8:  MOVF   x9A,W
076DA:  SUBLW  3D
076DC:  BNZ   76F4
....................       { 
....................          *ptr=0; 
076DE:  MOVFF  394,FE9
076E2:  MOVFF  395,FEA
076E6:  CLRF   FEF
....................          pValue=ptr+1; 
076E8:  MOVLW  01
076EA:  ADDWF  x94,W
076EC:  MOVWF  x98
076EE:  MOVLW  00
076F0:  ADDWFC x95,W
076F2:  MOVWF  x99
....................       } 
....................       ptr++; 
076F4:  INCF   x94,F
076F6:  BTFSC  FD8.2
076F8:  INCF   x95,F
....................    } 
076FA:  BRA    7666
.................... } 
076FC:  MOVLB  0
076FE:  RETLW  00
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
077EE:  MOVFF  39A,168
.................... } 
077F2:  GOTO   8360 (RETURN)
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
07B0E:  MOVFF  168,3B9
07B12:  MOVFF  3B8,3BA
07B16:  BRA    79C0
07B18:  MOVF   01,W
.................... } 
07B1A:  RETLW  00
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
07D36:  MOVLB  3
07D38:  MOVFF  39C,FE9
07D3C:  MOVFF  39D,FEA
07D40:  MOVFF  FEC,03
07D44:  MOVF   FED,F
07D46:  MOVFF  FEF,3A2
07D4A:  MOVFF  03,3A3
....................  
....................    n=strlen(ptr); 
07D4E:  MOVFF  3A3,3BE
07D52:  MOVFF  3A2,3BD
07D56:  MOVLB  0
07D58:  CALL   6F5E
07D5C:  MOVLB  3
07D5E:  CLRF   xA1
07D60:  MOVFF  01,3A0
....................  
....................    if (!n) 
07D64:  MOVF   xA0,W
07D66:  IORWF  xA1,W
07D68:  BNZ   7D70
....................       return(TCP_PUT_CONST_EC_FINISH); 
07D6A:  MOVLW  00
07D6C:  MOVWF  01
07D6E:  BRA    7DF4
....................  
....................    txLeft = tcp_http_tx_left(); 
07D70:  MOVFF  168,3A8
07D74:  MOVLB  0
07D76:  RCALL  7C3A
07D78:  MOVFF  02,39F
07D7C:  MOVFF  01,39E
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
07D80:  MOVLB  3
07D82:  MOVF   x9E,W
07D84:  IORWF  x9F,W
07D86:  BNZ   7D8E
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
07D88:  MOVLW  01
07D8A:  MOVWF  01
07D8C:  BRA    7DF4
....................   #endif 
....................  
....................    if (n > txLeft) 
07D8E:  MOVF   x9F,W
07D90:  SUBWF  xA1,W
07D92:  BNC   7DA2
07D94:  BNZ   7D9C
07D96:  MOVF   xA0,W
07D98:  SUBWF  x9E,W
07D9A:  BC    7DA2
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
07D9C:  MOVLW  01
07D9E:  MOVWF  xA4
....................    } 
....................    else 
07DA0:  BRA    7DAC
....................    { 
....................       txLeft = n; 
07DA2:  MOVFF  3A1,39F
07DA6:  MOVFF  3A0,39E
....................       ec = TCP_PUT_CONST_EC_FINISH; 
07DAA:  CLRF   xA4
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
....................    { 
07DAC:  MOVFF  39F,03
07DB0:  MOVF   x9E,W
07DB2:  BTFSC  FD8.2
07DB4:  DECF   x9F,F
07DB6:  DECF   x9E,F
07DB8:  IORWF  03,W
07DBA:  BZ    7DDE
....................       tcp_http_putc(*ptr++); 
07DBC:  MOVFF  3A3,03
07DC0:  MOVF   xA2,W
07DC2:  INCF   xA2,F
07DC4:  BTFSC  FD8.2
07DC6:  INCF   xA3,F
07DC8:  MOVWF  FE9
07DCA:  MOVFF  03,FEA
07DCE:  MOVFF  FEF,3A5
07DD2:  MOVFF  3A5,3B8
07DD6:  MOVLB  0
07DD8:  RCALL  7B0E
....................    } 
07DDA:  MOVLB  3
07DDC:  BRA    7DAC
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
07DDE:  MOVFF  39C,FE9
07DE2:  MOVFF  39D,FEA
07DE6:  MOVFF  3A3,FEC
07DEA:  MOVF   FED,F
07DEC:  MOVFF  3A2,FEF
....................  
....................    return(ec); 
07DF0:  MOVFF  3A4,01
.................... } 
07DF4:  MOVLB  0
07DF6:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
.................... { 
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
*
07E16:  MOVLB  3
07E18:  CLRF   xAF
07E1A:  CLRF   xB0
....................    int32 addy; 
....................    int1 premature = TRUE; 
07E1C:  BSF    xB7.0
....................  
....................    max = *n; 
07E1E:  MOVFF  3AA,FE9
07E22:  MOVFF  3AB,FEA
07E26:  MOVFF  FEC,03
07E2A:  MOVF   FED,F
07E2C:  MOVFF  FEF,3B1
07E30:  MOVFF  03,3B2
....................    addy = *retAddy; 
07E34:  MOVFF  3A8,FE9
07E38:  MOVFF  3A9,FEA
07E3C:  MOVFF  FEF,00
07E40:  MOVFF  FEC,01
07E44:  MOVFF  FEC,02
07E48:  MOVFF  FEC,03
07E4C:  MOVFF  03,3B6
07E50:  MOVFF  02,3B5
07E54:  MOVFF  01,3B4
07E58:  MOVFF  00,3B3
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
07E5C:  MOVFF  3B6,03
07E60:  MOVFF  3B5,02
07E64:  MOVFF  3B4,01
07E68:  MOVFF  3B3,00
07E6C:  MOVLW  01
07E6E:  ADDWF  xB3,F
07E70:  BTFSC  FD8.0
07E72:  INCF   xB4,F
07E74:  BTFSC  FD8.2
07E76:  INCF   xB5,F
07E78:  BTFSC  FD8.2
07E7A:  INCF   xB6,F
07E7C:  MOVFF  03,3BB
07E80:  MOVFF  02,3BA
07E84:  MOVFF  01,3B9
07E88:  MOVFF  00,3B8
07E8C:  MOVFF  02,FF8
07E90:  MOVFF  01,FF7
07E94:  MOVFF  00,FF6
07E98:  MOVLW  03
07E9A:  MOVWF  FEA
07E9C:  MOVLW  AD
07E9E:  MOVWF  FE9
07EA0:  CLRF   xBD
07EA2:  MOVLW  01
07EA4:  MOVWF  xBC
07EA6:  MOVLB  0
07EA8:  RCALL  7DF8
....................       if (stopC == '%') 
07EAA:  MOVLB  3
07EAC:  MOVF   xAD,W
07EAE:  SUBLW  25
07EB0:  BNZ   7F34
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
07EB2:  MOVFF  3B6,03
07EB6:  MOVFF  3B5,02
07EBA:  MOVFF  3B4,01
07EBE:  MOVFF  3B3,00
07EC2:  MOVLW  01
07EC4:  ADDWF  xB3,F
07EC6:  BTFSC  FD8.0
07EC8:  INCF   xB4,F
07ECA:  BTFSC  FD8.2
07ECC:  INCF   xB5,F
07ECE:  BTFSC  FD8.2
07ED0:  INCF   xB6,F
07ED2:  MOVFF  03,3BB
07ED6:  MOVFF  02,3BA
07EDA:  MOVFF  01,3B9
07EDE:  MOVFF  00,3B8
07EE2:  MOVFF  02,FF8
07EE6:  MOVFF  01,FF7
07EEA:  MOVFF  00,FF6
07EEE:  MOVLW  03
07EF0:  MOVWF  FEA
07EF2:  MOVLW  AE
07EF4:  MOVWF  FE9
07EF6:  CLRF   xBD
07EF8:  MOVLW  01
07EFA:  MOVWF  xBC
07EFC:  MOVLB  0
07EFE:  RCALL  7DF8
....................          if (checkC == '%') 
07F00:  MOVLB  3
07F02:  MOVF   xAE,W
07F04:  SUBLW  25
07F06:  BNZ   7F30
....................          { 
....................             if (fileSize < max) 
07F08:  MOVF   xB0,W
07F0A:  SUBWF  xB2,W
07F0C:  BNC   7F2C
07F0E:  BNZ   7F16
07F10:  MOVF   xB1,W
07F12:  SUBWF  xAF,W
07F14:  BC    7F2C
....................             { 
....................                if (doSend) 
07F16:  MOVF   xAC,F
07F18:  BZ    7F24
....................                   tcp_http_putc('%'); 
07F1A:  MOVLW  25
07F1C:  MOVWF  xB8
07F1E:  MOVLB  0
07F20:  RCALL  7B0E
07F22:  MOVLB  3
....................                fileSize++; 
07F24:  INCF   xAF,F
07F26:  BTFSC  FD8.2
07F28:  INCF   xB0,F
....................             } 
....................             else 
07F2A:  BRA    7F2E
....................                break; 
07F2C:  BRA    7F66
....................          } 
....................          else 
07F2E:  BRA    7F32
....................             break;   //ESCAPE 
07F30:  BRA    7F66
....................       } 
....................       else if (stopC) 
07F32:  BRA    7F64
07F34:  MOVF   xAD,F
07F36:  BZ    7F60
....................       { 
....................          if (fileSize < max) 
07F38:  MOVF   xB0,W
07F3A:  SUBWF  xB2,W
07F3C:  BNC   7F5C
07F3E:  BNZ   7F46
07F40:  MOVF   xB1,W
07F42:  SUBWF  xAF,W
07F44:  BC    7F5C
....................          { 
....................             if (doSend) 
07F46:  MOVF   xAC,F
07F48:  BZ    7F54
....................                tcp_http_putc(stopC); 
07F4A:  MOVFF  3AD,3B8
07F4E:  MOVLB  0
07F50:  RCALL  7B0E
07F52:  MOVLB  3
....................             fileSize++; 
07F54:  INCF   xAF,F
07F56:  BTFSC  FD8.2
07F58:  INCF   xB0,F
....................          } 
....................          else 
07F5A:  BRA    7F5E
....................             break; 
07F5C:  BRA    7F66
....................       } 
....................       else 
07F5E:  BRA    7F64
....................       { 
....................          premature = FALSE; 
07F60:  BCF    xB7.0
....................          break;   //EOF (stopC == 0) 
07F62:  BRA    7F66
....................       } 
....................    } 
07F64:  BRA    7E5C
....................  
....................    if (premature) 
07F66:  BTFSS  xB7.0
07F68:  BRA    7F7A
....................       addy--; 
07F6A:  MOVLW  FF
07F6C:  ADDWF  xB3,F
07F6E:  BTFSS  FD8.0
07F70:  ADDWF  xB4,F
07F72:  BTFSS  FD8.0
07F74:  ADDWF  xB5,F
07F76:  BTFSS  FD8.0
07F78:  ADDWF  xB6,F
....................  
....................    *n = fileSize; 
07F7A:  MOVFF  3AA,FE9
07F7E:  MOVFF  3AB,FEA
07F82:  MOVFF  3B0,FEC
07F86:  MOVF   FED,F
07F88:  MOVFF  3AF,FEF
....................    *retAddy = addy; 
07F8C:  MOVFF  3A8,FE9
07F90:  MOVFF  3A9,FEA
07F94:  MOVFF  3B3,FEF
07F98:  MOVFF  3B4,FEC
07F9C:  MOVFF  3B5,FEC
07FA0:  MOVFF  3B6,FEC
....................  
....................    return(stopC); 
07FA4:  MOVFF  3AD,01
.................... } 
07FA8:  MOVLB  0
07FAA:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
.................... { 
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
07FAC:  MOVLB  3
07FAE:  CLRF   xA3
07FB0:  CLRF   xA4
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
07FB2:  MOVFF  168,3A8
07FB6:  MOVLB  0
07FB8:  RCALL  7C3A
07FBA:  MOVFF  02,3A6
07FBE:  MOVFF  01,3A5
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
07FC2:  MOVLB  3
07FC4:  MOVF   xA5,W
07FC6:  IORWF  xA6,W
07FC8:  BNZ   7FD0
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
07FCA:  MOVLW  01
07FCC:  MOVWF  01
07FCE:  BRA    807E
....................  #endif 
....................  
....................    addy = *retAddy; 
07FD0:  MOVFF  39C,FE9
07FD4:  MOVFF  39D,FEA
07FD8:  MOVFF  FEF,00
07FDC:  MOVFF  FEC,01
07FE0:  MOVFF  FEC,02
07FE4:  MOVFF  FEC,03
07FE8:  MOVFF  03,3A2
07FEC:  MOVFF  02,3A1
07FF0:  MOVFF  01,3A0
07FF4:  MOVFF  00,39F
....................  
....................    fileSize = 0xFFFF; 
07FF8:  MOVLW  FF
07FFA:  MOVWF  xA4
07FFC:  MOVWF  xA3
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
07FFE:  MOVLW  03
08000:  MOVWF  xA9
08002:  MOVLW  9F
08004:  MOVWF  xA8
08006:  MOVLW  03
08008:  MOVWF  xAB
0800A:  MOVLW  A3
0800C:  MOVWF  xAA
0800E:  CLRF   xAC
08010:  MOVLB  0
08012:  RCALL  7E16
08014:  MOVFF  01,39E
....................  
....................    if (!fileSize && (stopC!='%')) 
08018:  MOVLB  3
0801A:  MOVF   xA3,W
0801C:  IORWF  xA4,W
0801E:  BNZ   802C
08020:  MOVF   x9E,W
08022:  SUBLW  25
08024:  BZ    802C
....................       return(TCP_PUT_CONST_EC_FINISH); 
08026:  MOVLW  00
08028:  MOVWF  01
0802A:  BRA    807E
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
0802C:  MOVF   xA6,W
0802E:  SUBWF  xA4,W
08030:  BNC   8048
08032:  BNZ   803A
08034:  MOVF   xA3,W
08036:  SUBWF  xA5,W
08038:  BC    8048
....................    { 
....................       fileSize = txLeft; 
0803A:  MOVFF  3A6,3A4
0803E:  MOVFF  3A5,3A3
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
08042:  MOVLW  01
08044:  MOVWF  xA7
....................    } 
....................    else 
08046:  BRA    8060
....................    { 
....................       if (stopC == '%') 
08048:  MOVF   x9E,W
0804A:  SUBLW  25
0804C:  BNZ   8054
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
0804E:  MOVLW  02
08050:  MOVWF  xA7
....................       else if (stopC) 
08052:  BRA    8060
08054:  MOVF   x9E,F
08056:  BZ    805E
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
08058:  MOVLW  01
0805A:  MOVWF  xA7
....................       else 
0805C:  BRA    8060
....................          ec = TCP_PUT_CONST_EC_FINISH; 
0805E:  CLRF   xA7
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
08060:  MOVFF  39D,3A9
08064:  MOVFF  39C,3A8
08068:  MOVLW  03
0806A:  MOVWF  xAB
0806C:  MOVLW  A3
0806E:  MOVWF  xAA
08070:  MOVLW  01
08072:  MOVWF  xAC
08074:  MOVLB  0
08076:  RCALL  7E16
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
08078:  MOVLB  3
0807A:  MOVFF  3A7,01
.................... } 
0807E:  MOVLB  0
08080:  GOTO   8534 (RETURN)
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
08084:  MOVFF  3A0,FF8
08088:  MOVFF  39F,FF7
0808C:  MOVFF  39E,FF6
08090:  MOVLW  03
08092:  MOVWF  FEA
08094:  MOVLW  A2
08096:  MOVWF  FE9
08098:  MOVLB  3
0809A:  CLRF   xBD
0809C:  MOVLW  01
0809E:  MOVWF  xBC
080A0:  MOVLB  0
080A2:  RCALL  7DF8
.................... #endif 
....................  
....................    return(ret); 
080A4:  MOVLB  3
080A6:  MOVFF  3A2,01
.................... } 
080AA:  MOVLB  0
080AC:  GOTO   8578 (RETURN)
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
08342:  CLRF   03
08344:  MOVLB  3
08346:  MOVF   x8E,W
08348:  ADDLW  65
0834A:  MOVWF  FE9
0834C:  MOVLW  01
0834E:  ADDWFC 03,W
08350:  MOVWF  FEA
08352:  MOVFF  FEF,397
....................  
....................    set_tcp_http_putc(socket); 
08356:  MOVFF  397,39A
0835A:  MOVLB  0
0835C:  GOTO   77EE
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
08360:  MOVLB  3
08362:  MOVF   x8E,W
08364:  MULLW  04
08366:  MOVF   FF3,W
08368:  CLRF   03
0836A:  ADDLW  69
0836C:  MOVWF  FE9
0836E:  MOVLW  01
08370:  ADDWFC 03,W
08372:  MOVWF  FEA
08374:  MOVFF  FEF,39A
08378:  MOVFF  FEC,39B
0837C:  MOVFF  FEC,39C
08380:  MOVFF  FEC,39D
08384:  MOVF   x9A,F
08386:  BTFSS  FD8.2
08388:  BRA    84C2
0838A:  MOVF   x9B,F
0838C:  BTFSS  FD8.2
0838E:  BRA    84C2
08390:  MOVF   x9C,F
08392:  BTFSS  FD8.2
08394:  BRA    84C2
08396:  MOVF   x9D,F
08398:  BTFSS  FD8.2
0839A:  BRA    84C2
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
0839C:  BCF    FD8.0
0839E:  RLCF   x8E,W
083A0:  CLRF   03
083A2:  ADDLW  6D
083A4:  MOVWF  FE9
083A6:  MOVLW  01
083A8:  ADDWFC 03,W
083AA:  MOVWF  FEA
083AC:  CLRF   FEC
083AE:  MOVF   FED,F
083B0:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
083B2:  MOVF   x8E,W
083B4:  MULLW  04
083B6:  MOVF   FF3,W
083B8:  CLRF   03
083BA:  ADDLW  69
083BC:  MOVWF  FE9
083BE:  MOVLW  01
083C0:  ADDWFC 03,W
083C2:  MOVWF  FEA
083C4:  MOVFF  391,FEF
083C8:  MOVFF  392,FEC
083CC:  MOVFF  393,FEC
083D0:  MOVFF  394,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
083D4:  MOVLW  01
083D6:  MOVLB  1
083D8:  MOVWF  x97
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
083DA:  MOVLW  62
083DC:  MOVWF  FF6
083DE:  MOVLW  01
083E0:  MOVWF  FF7
083E2:  MOVLW  09
083E4:  MOVLB  3
083E6:  MOVWF  x9A
083E8:  MOVLB  0
083EA:  GOTO   7B1C
083EE:  MOVLW  10
083F0:  MOVWF  FE9
083F2:  MOVFF  390,39B
083F6:  MOVFF  38F,39A
083FA:  GOTO   7B46
083FE:  MOVLW  20
08400:  MOVLB  3
08402:  MOVWF  xB8
08404:  MOVLB  0
08406:  CALL   7B0E
....................     #endif 
....................  
....................       switch(errorCode) 
....................       { 
0840A:  MOVLB  3
0840C:  MOVF   x8F,W
0840E:  MOVWF  00
08410:  MOVF   x90,W
08412:  MOVWF  03
08414:  MOVF   03,W
08416:  BNZ   8422
08418:  MOVLW  C8
0841A:  SUBWF  00,W
0841C:  MOVLB  0
0841E:  BZ    8444
08420:  MOVLB  3
08422:  MOVLW  01
08424:  SUBWF  03,W
08426:  BNZ   8432
08428:  MOVLW  94
0842A:  SUBWF  00,W
0842C:  MOVLB  0
0842E:  BZ    845E
08430:  MOVLB  3
08432:  MOVLW  01
08434:  SUBWF  03,W
08436:  BNZ   8442
08438:  MOVLW  F4
0843A:  SUBWF  00,W
0843C:  MOVLB  0
0843E:  BZ    846C
08440:  MOVLB  3
08442:  BRA    847A
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
08444:  MOVLW  4F
08446:  MOVLB  3
08448:  MOVWF  xB8
0844A:  MOVLB  0
0844C:  CALL   7B0E
08450:  MOVLW  4B
08452:  MOVLB  3
08454:  MOVWF  xB8
08456:  MOVLB  0
08458:  CALL   7B0E
....................             break; 
0845C:  BRA    847E
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
0845E:  MOVLW  70
08460:  MOVWF  FF6
08462:  MOVLW  01
08464:  MOVWF  FF7
08466:  CALL   7C04
....................             break; 
0846A:  BRA    847E
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
0846C:  MOVLW  7A
0846E:  MOVWF  FF6
08470:  MOVLW  01
08472:  MOVWF  FF7
08474:  CALL   7C04
....................             break; 
08478:  BRA    847E
....................          default: 
....................             break; 
0847A:  MOVLB  0
0847C:  BRA    847E
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
0847E:  MOVLW  88
08480:  MOVWF  FF6
08482:  MOVLW  01
08484:  MOVWF  FF7
08486:  CALL   7C04
....................       if (contentType) 
0848A:  MOVLB  3
0848C:  MOVF   x95,W
0848E:  IORWF  x96,W
08490:  BZ    84A6
....................          printf(tcp_http_putc, "%s", contentType); 
08492:  MOVFF  396,FEA
08496:  MOVFF  395,FE9
0849A:  MOVLB  0
0849C:  GOTO   7C14
....................       else 
084A0:  MOVLB  0
084A2:  BRA    84B4
084A4:  MOVLB  3
....................          printf(tcp_http_putc,"text/html"); 
084A6:  MOVLW  9A
084A8:  MOVWF  FF6
084AA:  MOVLW  01
084AC:  MOVWF  FF7
084AE:  MOVLB  0
084B0:  CALL   7C04
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
084B4:  MOVLW  A4
084B6:  MOVWF  FF6
084B8:  MOVLW  01
084BA:  MOVWF  FF7
084BC:  CALL   7C04
084C0:  MOVLB  3
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
084C2:  BCF    FD8.0
084C4:  RLCF   x8E,W
084C6:  CLRF   03
084C8:  ADDLW  6D
084CA:  MOVWF  FE9
084CC:  MOVLW  01
084CE:  ADDWFC 03,W
084D0:  MOVWF  FEA
084D2:  MOVF   FEF,F
084D4:  BZ    8508
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
084D6:  BCF    FD8.0
084D8:  RLCF   x8E,W
084DA:  CLRF   03
084DC:  ADDLW  6D
084DE:  MOVWF  x9A
084E0:  MOVLW  01
084E2:  ADDWFC 03,W
084E4:  MOVWF  x9B
084E6:  MOVWF  x9D
084E8:  MOVFF  39A,39C
084EC:  MOVLB  0
084EE:  RCALL  7D36
....................       lastHTTPPutVarPos[which] = 0; 
084F0:  BCF    FD8.0
084F2:  MOVLB  3
084F4:  RLCF   x8E,W
084F6:  CLRF   03
084F8:  ADDLW  6D
084FA:  MOVWF  FE9
084FC:  MOVLW  01
084FE:  ADDWFC 03,W
08500:  MOVWF  FEA
08502:  CLRF   FEC
08504:  MOVF   FED,F
08506:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
08508:  MOVLB  1
0850A:  DECFSZ x97,W
0850C:  BRA    864E
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
0850E:  MOVLB  3
08510:  MOVF   x8E,W
08512:  MULLW  04
08514:  MOVF   FF3,W
08516:  CLRF   03
08518:  ADDLW  69
0851A:  MOVWF  01
0851C:  MOVLW  01
0851E:  ADDWFC 03,F
08520:  MOVFF  01,39A
08524:  MOVFF  03,39B
08528:  MOVFF  03,39D
0852C:  MOVFF  01,39C
08530:  MOVLB  0
08532:  BRA    7FAC
08534:  MOVFF  01,398
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
08538:  MOVLB  3
0853A:  MOVF   x98,W
0853C:  SUBLW  02
0853E:  BTFSS  FD8.2
08540:  BRA    863C
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
08542:  MOVF   x8E,W
08544:  MULLW  04
08546:  MOVF   FF3,W
08548:  CLRF   03
0854A:  ADDLW  69
0854C:  MOVWF  FE9
0854E:  MOVLW  01
08550:  ADDWFC 03,W
08552:  MOVWF  FEA
08554:  MOVFF  FEF,39A
08558:  MOVFF  FEC,39B
0855C:  MOVFF  FEC,39C
08560:  MOVFF  FEC,39D
08564:  MOVFF  39D,3A1
08568:  MOVFF  39C,3A0
0856C:  MOVFF  39B,39F
08570:  MOVFF  39A,39E
08574:  MOVLB  0
08576:  BRA    8084
08578:  MOVFF  01,399
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
0857C:  MOVLB  3
0857E:  MOVF   x8E,W
08580:  MULLW  04
08582:  MOVF   FF3,W
08584:  CLRF   03
08586:  ADDLW  69
08588:  MOVWF  FE9
0858A:  MOVLW  01
0858C:  ADDWFC 03,W
0858E:  MOVWF  FEA
08590:  MOVLW  01
08592:  ADDWF  FEF,W
08594:  MOVWF  00
08596:  MOVLW  00
08598:  ADDWFC FEC,W
0859A:  MOVWF  01
0859C:  MOVLW  00
0859E:  ADDWFC FEC,W
085A0:  MOVWF  02
085A2:  MOVLW  00
085A4:  ADDWFC FEC,W
085A6:  MOVF   FED,F
085A8:  MOVF   FED,F
085AA:  MOVF   FED,F
085AC:  MOVFF  00,FEF
085B0:  MOVFF  01,FEC
085B4:  MOVFF  02,FEC
085B8:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
085BA:  MOVFF  394,39D
085BE:  MOVFF  393,39C
085C2:  MOVFF  392,39B
085C6:  MOVFF  391,39A
085CA:  MOVFF  399,39E
085CE:  MOVLW  01
085D0:  MOVWF  xA0
085D2:  MOVLW  6F
085D4:  MOVWF  x9F
085D6:  MOVLW  27
085D8:  MOVWF  xA1
085DA:  MOVLB  0
085DC:  BRA    8106
....................             lastHTTPPutVarPos[which] = &str[0]; 
085DE:  BCF    FD8.0
085E0:  MOVLB  3
085E2:  RLCF   x8E,W
085E4:  CLRF   03
085E6:  ADDLW  6D
085E8:  MOVWF  FE9
085EA:  MOVLW  01
085EC:  ADDWFC 03,W
085EE:  MOVWF  FEA
085F0:  MOVLW  01
085F2:  MOVWF  FEC
085F4:  MOVF   FED,F
085F6:  MOVLW  6F
085F8:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
085FA:  BCF    FD8.0
085FC:  RLCF   x8E,W
085FE:  CLRF   03
08600:  ADDLW  6D
08602:  MOVWF  x9A
08604:  MOVLW  01
08606:  ADDWFC 03,W
08608:  MOVWF  x9B
0860A:  MOVWF  x9D
0860C:  MOVFF  39A,39C
08610:  MOVLB  0
08612:  CALL   7D36
08616:  MOVFF  01,398
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
0861A:  MOVLB  3
0861C:  MOVF   x98,F
0861E:  BNZ   8638
....................                lastHTTPPutVarPos[which] = 0; 
08620:  BCF    FD8.0
08622:  RLCF   x8E,W
08624:  CLRF   03
08626:  ADDLW  6D
08628:  MOVWF  FE9
0862A:  MOVLW  01
0862C:  ADDWFC 03,W
0862E:  MOVWF  FEA
08630:  CLRF   FEC
08632:  MOVF   FED,F
08634:  CLRF   FEF
....................             else 
08636:  BRA    863A
....................                break; 
08638:  BRA    864C
....................          } 
....................          else 
0863A:  BRA    864A
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
0863C:  MOVF   x98,F
0863E:  BNZ   8648
....................                status = HTTP_PUT_FILE_CHUNK_END; 
08640:  MOVLW  02
08642:  MOVLB  1
08644:  MOVWF  x97
08646:  MOVLB  3
....................             break; 
08648:  BRA    864C
....................          } 
....................       } while (TRUE); 
....................    } 
0864A:  BRA    8510
0864C:  MOVLB  1
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
0864E:  MOVF   x97,W
08650:  SUBLW  02
08652:  BNZ   8658
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
08654:  MOVLW  03
08656:  MOVWF  x97
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
08658:  MOVFF  397,3BF
0865C:  MOVLB  0
0865E:  CALL   77F6
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
08662:  MOVLB  1
08664:  MOVF   x97,W
08666:  SUBLW  03
08668:  BZ    866E
0866A:  MOVLW  00
0866C:  BRA    8670
0866E:  MOVLW  01
08670:  MOVWF  01
.................... } 
08672:  MOVLB  0
08674:  RETLW  00
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
01914:  MOVLB  3
01916:  CLRF   x7C
01918:  MOVF   x7C,F
0191A:  BNZ   1978
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
0191C:  CLRF   03
0191E:  MOVF   x7C,W
01920:  ADDLW  65
01922:  MOVWF  01
01924:  MOVLW  01
01926:  ADDWFC 03,F
01928:  MOVFF  01,37D
0192C:  MOVFF  03,37E
01930:  CLRF   x80
01932:  MOVLW  50
01934:  MOVWF  x7F
01936:  MOVLB  0
01938:  BRA    1818
0193A:  MOVFF  37E,FEA
0193E:  MOVFF  37D,FE9
01942:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
01946:  CLRF   03
01948:  MOVLB  3
0194A:  MOVF   x7C,W
0194C:  ADDLW  65
0194E:  MOVWF  FE9
01950:  MOVLW  01
01952:  ADDWFC 03,W
01954:  MOVWF  FEA
01956:  MOVF   FEF,W
01958:  SUBLW  FE
0195A:  BZ    1974
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
0195C:  BCF    FD8.0
0195E:  RLCF   x7C,W
01960:  CLRF   03
01962:  ADDLW  66
01964:  MOVWF  FE9
01966:  MOVLW  01
01968:  ADDWFC 03,W
0196A:  MOVWF  FEA
0196C:  MOVLW  01
0196E:  MOVWF  FEC
01970:  MOVF   FED,F
01972:  MOVWF  FEF
....................          } 
....................       } 
01974:  INCF   x7C,F
01976:  BRA    1918
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
.................... } 
01978:  MOVLB  0
0197A:  GOTO   1996 (RETURN)
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
087B4:  MOVLB  3
087B6:  CLRF   x88
087B8:  MOVF   x88,F
087BA:  BTFSS  FD8.2
087BC:  GOTO   9430
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
087C0:  BCF    FD8.0
087C2:  RLCF   x88,W
087C4:  CLRF   03
087C6:  ADDLW  66
087C8:  MOVWF  FE9
087CA:  MOVLW  01
087CC:  ADDWFC 03,W
087CE:  MOVWF  FEA
087D0:  MOVFF  FEC,38B
087D4:  MOVF   FED,F
087D6:  MOVFF  FEF,38A
087DA:  INCFSZ x8A,W
087DC:  BRA    87E6
087DE:  MOVF   x8B,F
087E0:  BNZ   87E6
....................          return; 
087E2:  GOTO   9430
....................  
....................       currSocket=http_socket[hs]; 
087E6:  CLRF   03
087E8:  MOVF   x88,W
087EA:  ADDLW  65
087EC:  MOVWF  FE9
087EE:  MOVLW  01
087F0:  ADDWFC 03,W
087F2:  MOVWF  FEA
087F4:  MOVFF  FEF,389
....................  
....................       if (!TCPIsConnected(currSocket)) 
087F8:  MOVFF  389,38A
087FC:  MOVLB  0
087FE:  CALL   6850
08802:  MOVF   01,F
08804:  BNZ   8822
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
08806:  BCF    FD8.0
08808:  MOVLB  3
0880A:  RLCF   x88,W
0880C:  CLRF   03
0880E:  ADDLW  66
08810:  MOVWF  FE9
08812:  MOVLW  01
08814:  ADDWFC 03,W
08816:  MOVWF  FEA
08818:  MOVLW  01
0881A:  MOVWF  FEC
0881C:  MOVF   FED,F
0881E:  MOVWF  FEF
08820:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
....................       { 
08822:  BCF    FD8.0
08824:  MOVLB  3
08826:  RLCF   x88,W
08828:  CLRF   03
0882A:  ADDLW  66
0882C:  MOVWF  FE9
0882E:  MOVLW  01
08830:  ADDWFC 03,W
08832:  MOVWF  FEA
08834:  MOVF   FEF,W
08836:  MOVWF  00
08838:  INCF   FE9,F
0883A:  MOVF   FEF,W
0883C:  DECF   FE9,F
0883E:  MOVWF  03
08840:  MOVLW  01
08842:  SUBWF  03,W
08844:  BNZ   8850
08846:  MOVLW  01
08848:  SUBWF  00,W
0884A:  MOVLB  0
0884C:  BZ    88FE
0884E:  MOVLB  3
08850:  MOVLW  01
08852:  SUBWF  03,W
08854:  BNZ   8860
08856:  MOVLW  02
08858:  SUBWF  00,W
0885A:  MOVLB  0
0885C:  BZ    890E
0885E:  MOVLB  3
08860:  MOVLW  01
08862:  SUBWF  03,W
08864:  BNZ   8872
08866:  MOVLW  03
08868:  SUBWF  00,W
0886A:  MOVLB  0
0886C:  BTFSC  FD8.2
0886E:  BRA    89BE
08870:  MOVLB  3
08872:  MOVLW  01
08874:  SUBWF  03,W
08876:  BNZ   8884
08878:  MOVLW  04
0887A:  SUBWF  00,W
0887C:  MOVLB  0
0887E:  BTFSC  FD8.2
08880:  BRA    8E14
08882:  MOVLB  3
08884:  MOVLW  01
08886:  SUBWF  03,W
08888:  BNZ   8896
0888A:  MOVLW  05
0888C:  SUBWF  00,W
0888E:  MOVLB  0
08890:  BTFSC  FD8.2
08892:  BRA    8E72
08894:  MOVLB  3
08896:  MOVLW  01
08898:  SUBWF  03,W
0889A:  BNZ   88AA
0889C:  MOVLW  06
0889E:  SUBWF  00,W
088A0:  MOVLB  0
088A2:  BTFSC  FD8.2
088A4:  GOTO   912A
088A8:  MOVLB  3
088AA:  MOVLW  01
088AC:  SUBWF  03,W
088AE:  BNZ   88BE
088B0:  MOVLW  07
088B2:  SUBWF  00,W
088B4:  MOVLB  0
088B6:  BTFSC  FD8.2
088B8:  GOTO   916C
088BC:  MOVLB  3
088BE:  MOVLW  01
088C0:  SUBWF  03,W
088C2:  BNZ   88D2
088C4:  MOVLW  08
088C6:  SUBWF  00,W
088C8:  MOVLB  0
088CA:  BTFSC  FD8.2
088CC:  GOTO   92E0
088D0:  MOVLB  3
088D2:  MOVLW  01
088D4:  SUBWF  03,W
088D6:  BNZ   88E6
088D8:  MOVLW  09
088DA:  SUBWF  00,W
088DC:  MOVLB  0
088DE:  BTFSC  FD8.2
088E0:  GOTO   932A
088E4:  MOVLB  3
088E6:  MOVLW  01
088E8:  SUBWF  03,W
088EA:  BNZ   88FA
088EC:  MOVLW  0A
088EE:  SUBWF  00,W
088F0:  MOVLB  0
088F2:  BTFSC  FD8.2
088F4:  GOTO   9424
088F8:  MOVLB  3
088FA:  GOTO   9424
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
088FE:  MOVFF  389,38A
08902:  CALL   6850
08906:  MOVF   01,F
08908:  BNZ   890E
....................                break; 
0890A:  GOTO   9428
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
0890E:  MOVLB  3
08910:  MOVF   x88,W
08912:  MULLW  FE
08914:  MOVF   FF3,W
08916:  CLRF   x8B
08918:  MOVWF  x8A
0891A:  MOVLW  B5
0891C:  ADDWF  x8A,W
0891E:  MOVWF  FE9
08920:  MOVLW  01
08922:  ADDWFC x8B,W
08924:  MOVWF  FEA
08926:  CLRF   FEF
....................             i[hs]=0; 
08928:  CLRF   03
0892A:  MOVF   x88,W
0892C:  ADDLW  B3
0892E:  MOVWF  FE9
08930:  MOVLW  02
08932:  ADDWFC 03,W
08934:  MOVWF  FEA
08936:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
08938:  BCF    FD8.0
0893A:  RLCF   x88,W
0893C:  CLRF   03
0893E:  ADDLW  66
08940:  MOVWF  FE9
08942:  MOVLW  01
08944:  ADDWFC 03,W
08946:  MOVWF  FEA
08948:  MOVLW  01
0894A:  MOVWF  FEC
0894C:  MOVF   FED,F
0894E:  MOVLW  03
08950:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
08952:  BCF    FD8.0
08954:  RLCF   x88,W
08956:  CLRF   03
08958:  ADDLW  BB
0895A:  MOVWF  01
0895C:  MOVLW  02
0895E:  ADDWFC 03,F
08960:  MOVFF  01,38A
08964:  MOVFF  03,38B
08968:  MOVLB  0
0896A:  CALL   485C
0896E:  MOVFF  38B,FEA
08972:  MOVFF  38A,FE9
08976:  MOVFF  02,FEC
0897A:  MOVF   FED,F
0897C:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
08980:  MOVLB  3
08982:  MOVF   x88,W
08984:  MULLW  04
08986:  MOVF   FF3,W
08988:  CLRF   03
0898A:  ADDLW  B5
0898C:  MOVWF  FE9
0898E:  MOVLW  02
08990:  ADDWFC 03,W
08992:  MOVWF  FEA
08994:  MOVF   FEE,F
08996:  MOVF   FEE,F
08998:  CLRF   FEC
0899A:  MOVF   FED,F
0899C:  CLRF   FEF
0899E:  MOVF   FED,F
089A0:  CLRF   FEF
089A2:  MOVF   FED,F
089A4:  CLRF   FEF
....................             http_post_len[hs]=0; 
089A6:  BCF    FD8.0
089A8:  RLCF   x88,W
089AA:  CLRF   03
089AC:  ADDLW  B9
089AE:  MOVWF  FE9
089B0:  MOVLW  02
089B2:  ADDWFC 03,W
089B4:  MOVWF  FEA
089B6:  CLRF   FEC
089B8:  MOVF   FED,F
089BA:  CLRF   FEF
089BC:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
089BE:  MOVLB  3
089C0:  BCF    x82.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
....................             { 
089C2:  MOVFF  389,38A
089C6:  MOVLB  0
089C8:  CALL   687A
089CC:  MOVF   01,F
089CE:  BTFSC  FD8.2
089D0:  BRA    8D18
089D2:  MOVFF  389,38A
089D6:  MOVLW  03
089D8:  MOVLB  3
089DA:  MOVWF  x8C
089DC:  MOVLW  83
089DE:  MOVWF  x8B
089E0:  MOVLB  0
089E2:  CALL   68A6
089E6:  MOVF   01,F
089E8:  BTFSC  FD8.2
089EA:  BRA    8D18
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
089EC:  MOVLB  3
089EE:  MOVF   x83,W
089F0:  SUBLW  1F
089F2:  BC    8A3E
089F4:  CLRF   03
089F6:  MOVF   x88,W
089F8:  ADDLW  B3
089FA:  MOVWF  FE9
089FC:  MOVLW  02
089FE:  ADDWFC 03,W
08A00:  MOVWF  FEA
08A02:  MOVF   FEF,W
08A04:  SUBLW  FB
08A06:  BNC   8A3E
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
08A08:  MOVF   x88,W
08A0A:  MULLW  FE
08A0C:  MOVF   FF3,W
08A0E:  CLRF   x8B
08A10:  MOVWF  x8A
08A12:  CLRF   03
08A14:  MOVF   x88,W
08A16:  ADDLW  B3
08A18:  MOVWF  FE9
08A1A:  MOVLW  02
08A1C:  ADDWFC 03,W
08A1E:  MOVWF  FEA
08A20:  MOVF   FEF,W
08A22:  INCF   FEF,F
08A24:  CLRF   03
08A26:  ADDWF  x8A,W
08A28:  MOVWF  01
08A2A:  MOVF   x8B,W
08A2C:  ADDWFC 03,F
08A2E:  MOVF   01,W
08A30:  ADDLW  B5
08A32:  MOVWF  FE9
08A34:  MOVLW  01
08A36:  ADDWFC 03,W
08A38:  MOVWF  FEA
08A3A:  MOVFF  383,FEF
....................                } 
....................                if (c=='\n') 
08A3E:  MOVF   x83,W
08A40:  SUBLW  0A
08A42:  BTFSS  FD8.2
08A44:  BRA    8D14
....................                { 
....................                   buffer[hs][i[hs]]=0; 
08A46:  MOVF   x88,W
08A48:  MULLW  FE
08A4A:  MOVF   FF3,W
08A4C:  CLRF   x8B
08A4E:  MOVWF  x8A
08A50:  CLRF   03
08A52:  MOVF   x88,W
08A54:  ADDLW  B3
08A56:  MOVWF  FE9
08A58:  MOVLW  02
08A5A:  ADDWFC 03,W
08A5C:  MOVWF  FEA
08A5E:  CLRF   03
08A60:  MOVF   FEF,W
08A62:  ADDWF  x8A,W
08A64:  MOVWF  01
08A66:  MOVF   x8B,W
08A68:  ADDWFC 03,F
08A6A:  MOVF   01,W
08A6C:  ADDLW  B5
08A6E:  MOVWF  FE9
08A70:  MOVLW  01
08A72:  ADDWFC 03,W
08A74:  MOVWF  FEA
08A76:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
....................                      ) 
08A78:  MOVF   x88,W
08A7A:  MULLW  FE
08A7C:  MOVF   FF3,W
08A7E:  CLRF   x8B
08A80:  MOVWF  x8A
08A82:  MOVLW  B5
08A84:  ADDWF  x8A,F
08A86:  MOVLW  01
08A88:  ADDWFC x8B,F
08A8A:  MOVFF  38B,38D
08A8E:  MOVFF  38A,38C
08A92:  MOVWF  x8F
08A94:  MOVLW  98
08A96:  MOVWF  x8E
08A98:  MOVLB  0
08A9A:  CALL   6A84
08A9E:  MOVFF  02,385
08AA2:  MOVFF  01,384
08AA6:  MOVLB  3
08AA8:  MOVF   x84,F
08AAA:  BNZ   8AB2
08AAC:  MOVF   x85,F
08AAE:  BTFSC  FD8.2
08AB0:  BRA    8C96
08AB2:  CLRF   x8D
08AB4:  CLRF   x8C
08AB6:  MOVLW  01
08AB8:  MOVWF  x8F
08ABA:  MOVLW  98
08ABC:  MOVWF  x8E
08ABE:  MOVLB  0
08AC0:  CALL   6A84
08AC4:  MOVFF  02,387
08AC8:  MOVFF  01,386
08ACC:  MOVLB  3
08ACE:  MOVF   x86,F
08AD0:  BNZ   8AD8
08AD2:  MOVF   x87,F
08AD4:  BTFSC  FD8.2
08AD6:  BRA    8C96
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
08AD8:  MOVFF  385,38B
08ADC:  MOVFF  384,38A
08AE0:  MOVLW  01
08AE2:  MOVWF  x8D
08AE4:  MOVLW  9C
08AE6:  MOVWF  x8C
08AE8:  MOVLB  0
08AEA:  CALL   6B34
08AEE:  MOVF   01,F
08AF0:  BZ    8B10
08AF2:  MOVFF  385,38B
08AF6:  MOVFF  384,38A
08AFA:  MOVLW  01
08AFC:  MOVLB  3
08AFE:  MOVWF  x8D
08B00:  MOVLW  A0
08B02:  MOVWF  x8C
08B04:  MOVLB  0
08B06:  CALL   6B34
08B0A:  MOVF   01,F
08B0C:  BTFSS  FD8.2
08B0E:  BRA    8C2C
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
08B10:  MOVFF  387,38D
08B14:  MOVFF  386,38C
08B18:  MOVLW  01
08B1A:  MOVLB  3
08B1C:  MOVWF  x8F
08B1E:  MOVLW  9A
08B20:  MOVWF  x8E
08B22:  MOVLB  0
08B24:  CALL   6A84
08B28:  MOVFF  02,387
08B2C:  MOVFF  01,386
....................                         http_escape_chars(pValue); 
08B30:  MOVFF  387,39C
08B34:  MOVFF  386,39B
08B38:  CALL   7062
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
08B3C:  MOVLB  3
08B3E:  MOVF   x88,W
08B40:  MULLW  04
08B42:  MOVF   FF3,W
08B44:  CLRF   03
08B46:  ADDLW  B5
08B48:  MOVWF  01
08B4A:  MOVLW  02
08B4C:  ADDWFC 03,F
08B4E:  MOVFF  01,38A
08B52:  MOVFF  03,38B
08B56:  MOVFF  387,38D
08B5A:  MOVFF  386,38C
08B5E:  MOVLB  0
08B60:  GOTO   7256
08B64:  MOVFF  38B,FEA
08B68:  MOVFF  38A,FE9
08B6C:  MOVFF  00,FEF
08B70:  MOVFF  01,FEC
08B74:  MOVFF  02,FEC
08B78:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
08B7C:  MOVLB  3
08B7E:  CLRF   x8D
08B80:  CLRF   x8C
08B82:  MOVLW  01
08B84:  MOVWF  x8F
08B86:  MOVLW  9A
08B88:  MOVWF  x8E
08B8A:  MOVLB  0
08B8C:  CALL   6A84
08B90:  MOVFF  02,387
08B94:  MOVFF  01,386
....................                         if (pValue) 
08B98:  MOVLB  3
08B9A:  MOVF   x86,W
08B9C:  IORWF  x87,W
08B9E:  BZ    8BE2
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
08BA0:  MOVF   x88,W
08BA2:  MULLW  04
08BA4:  MOVF   FF3,W
08BA6:  CLRF   03
08BA8:  ADDLW  B5
08BAA:  MOVWF  FE9
08BAC:  MOVLW  02
08BAE:  ADDWFC 03,W
08BB0:  MOVWF  FEA
08BB2:  MOVFF  FEF,38A
08BB6:  MOVFF  FEC,38B
08BBA:  MOVFF  FEC,38C
08BBE:  MOVFF  FEC,38D
08BC2:  MOVFF  38D,393
08BC6:  MOVFF  38C,392
08BCA:  MOVFF  38B,391
08BCE:  MOVFF  38A,390
08BD2:  MOVFF  387,395
08BD6:  MOVFF  386,394
08BDA:  MOVLB  0
08BDC:  CALL   7658
08BE0:  MOVLB  3
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
08BE2:  MOVFF  385,38B
08BE6:  MOVFF  384,38A
08BEA:  MOVLW  01
08BEC:  MOVWF  x8D
08BEE:  MOVLW  9C
08BF0:  MOVWF  x8C
08BF2:  MOVLB  0
08BF4:  CALL   6B34
08BF8:  MOVF   01,F
08BFA:  BNZ   8C14
....................                            http_cmd[hs]=HTTP_REQ_GET; 
08BFC:  CLRF   03
08BFE:  MOVLB  3
08C00:  MOVF   x88,W
08C02:  ADDLW  B4
08C04:  MOVWF  FE9
08C06:  MOVLW  02
08C08:  ADDWFC 03,W
08C0A:  MOVWF  FEA
08C0C:  MOVLW  01
08C0E:  MOVWF  FEF
....................                         else 
08C10:  BRA    8C28
08C12:  MOVLB  0
....................                            http_cmd[hs]=HTTP_REQ_POST; 
08C14:  CLRF   03
08C16:  MOVLB  3
08C18:  MOVF   x88,W
08C1A:  ADDLW  B4
08C1C:  MOVWF  FE9
08C1E:  MOVLW  02
08C20:  ADDWFC 03,W
08C22:  MOVWF  FEA
08C24:  MOVLW  02
08C26:  MOVWF  FEF
....................                      } 
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
08C28:  BRA    8C94
08C2A:  MOVLB  0
08C2C:  CLRF   03
08C2E:  MOVLB  3
08C30:  MOVF   x88,W
08C32:  ADDLW  B4
08C34:  MOVWF  FE9
08C36:  MOVLW  02
08C38:  ADDWFC 03,W
08C3A:  MOVWF  FEA
08C3C:  MOVF   FEF,F
08C3E:  BZ    8C94
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
08C40:  MOVFF  385,38B
08C44:  MOVFF  384,38A
08C48:  MOVLW  01
08C4A:  MOVWF  x8D
08C4C:  MOVLW  A5
08C4E:  MOVWF  x8C
08C50:  MOVLB  0
08C52:  CALL   6B34
08C56:  MOVF   01,F
08C58:  BNZ   8C92
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
08C5A:  BCF    FD8.0
08C5C:  MOVLB  3
08C5E:  RLCF   x88,W
08C60:  CLRF   03
08C62:  ADDLW  B9
08C64:  MOVWF  01
08C66:  MOVLW  02
08C68:  ADDWFC 03,F
08C6A:  MOVFF  01,38A
08C6E:  MOVFF  03,38B
08C72:  MOVFF  387,392
08C76:  MOVFF  386,391
08C7A:  MOVLB  0
08C7C:  CALL   28DA
08C80:  MOVFF  38B,FEA
08C84:  MOVFF  38A,FE9
08C88:  MOVFF  02,FEC
08C8C:  MOVF   FED,F
08C8E:  MOVFF  01,FEF
08C92:  MOVLB  3
....................                         } 
....................                      } 
....................                   } 
....................                   else if (i[hs] == 0) 
08C94:  BRA    8D04
08C96:  CLRF   03
08C98:  MOVF   x88,W
08C9A:  ADDLW  B3
08C9C:  MOVWF  FE9
08C9E:  MOVLW  02
08CA0:  ADDWFC 03,W
08CA2:  MOVWF  FEA
08CA4:  MOVF   FEF,F
08CA6:  BNZ   8D04
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
08CA8:  CLRF   03
08CAA:  MOVF   x88,W
08CAC:  ADDLW  B4
08CAE:  MOVWF  FE9
08CB0:  MOVLW  02
08CB2:  ADDWFC 03,W
08CB4:  MOVWF  FEA
08CB6:  MOVF   FEF,W
08CB8:  SUBLW  02
08CBA:  BNZ   8CDA
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
08CBC:  BCF    FD8.0
08CBE:  RLCF   x88,W
08CC0:  CLRF   03
08CC2:  ADDLW  66
08CC4:  MOVWF  FE9
08CC6:  MOVLW  01
08CC8:  ADDWFC 03,W
08CCA:  MOVWF  FEA
08CCC:  MOVLW  01
08CCE:  MOVWF  FEC
08CD0:  MOVF   FED,F
08CD2:  MOVLW  04
08CD4:  MOVWF  FEF
....................                         postContinue=TRUE; 
08CD6:  BSF    x82.1
....................                      } 
....................                      else 
08CD8:  BRA    8CFE
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
08CDA:  BCF    FD8.0
08CDC:  RLCF   x88,W
08CDE:  CLRF   03
08CE0:  ADDLW  66
08CE2:  MOVWF  FE9
08CE4:  MOVLW  01
08CE6:  ADDWFC 03,W
08CE8:  MOVWF  FEA
08CEA:  MOVLW  01
08CEC:  MOVWF  FEC
08CEE:  MOVF   FED,F
08CF0:  MOVLW  06
08CF2:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
08CF4:  MOVFF  389,38D
08CF8:  MOVLB  0
08CFA:  CALL   7700
....................                      } 
....................                      break;   //break out of read from ethernet loop 
08CFE:  MOVLB  0
08D00:  BRA    8D18
08D02:  MOVLB  3
....................                   } 
....................                   i[hs]=0; 
08D04:  CLRF   03
08D06:  MOVF   x88,W
08D08:  ADDLW  B3
08D0A:  MOVWF  FE9
08D0C:  MOVLW  02
08D0E:  ADDWFC 03,W
08D10:  MOVWF  FEA
08D12:  CLRF   FEF
....................                } 
....................             } 
08D14:  BRA    89C2
08D16:  MOVLB  0
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
08D18:  CALL   485C
08D1C:  MOVFF  02,38B
08D20:  MOVFF  01,38A
08D24:  BCF    FD8.0
08D26:  MOVLB  3
08D28:  RLCF   x88,W
08D2A:  CLRF   03
08D2C:  ADDLW  BB
08D2E:  MOVWF  FE9
08D30:  MOVLW  02
08D32:  ADDWFC 03,W
08D34:  MOVWF  FEA
08D36:  MOVFF  FEC,03
08D3A:  MOVF   FED,F
08D3C:  MOVFF  FEF,01
08D40:  MOVF   02,W
08D42:  SUBWF  03,W
08D44:  BNC   8D4E
08D46:  BNZ   8D52
08D48:  MOVF   01,W
08D4A:  SUBWF  x8A,W
08D4C:  BNC   8D52
08D4E:  MOVLW  00
08D50:  BRA    8D54
08D52:  MOVLW  01
08D54:  CLRF   03
08D56:  IORWF  03,W
08D58:  BZ    8D9C
08D5A:  BCF    FD8.0
08D5C:  RLCF   x88,W
08D5E:  CLRF   03
08D60:  ADDLW  BB
08D62:  MOVWF  FE9
08D64:  MOVLW  02
08D66:  ADDWFC 03,W
08D68:  MOVWF  FEA
08D6A:  MOVFF  FEC,03
08D6E:  MOVF   FED,F
08D70:  MOVF   FEF,W
08D72:  SUBLW  FF
08D74:  MOVWF  x8A
08D76:  MOVLW  FF
08D78:  SUBFWB 03,W
08D7A:  MOVWF  x8B
08D7C:  MOVLB  0
08D7E:  CALL   485C
08D82:  MOVF   01,W
08D84:  MOVLB  3
08D86:  ADDWF  x8A,F
08D88:  MOVF   02,W
08D8A:  ADDWFC x8B,F
08D8C:  MOVLW  01
08D8E:  ADDWF  x8A,W
08D90:  MOVWF  01
08D92:  MOVLW  00
08D94:  ADDWFC x8B,W
08D96:  MOVWF  03
08D98:  MOVF   01,W
08D9A:  BRA    8DD0
08D9C:  MOVLB  0
08D9E:  CALL   485C
08DA2:  MOVFF  02,38B
08DA6:  MOVFF  01,38A
08DAA:  BCF    FD8.0
08DAC:  MOVLB  3
08DAE:  RLCF   x88,W
08DB0:  CLRF   03
08DB2:  ADDLW  BB
08DB4:  MOVWF  FE9
08DB6:  MOVLW  02
08DB8:  ADDWFC 03,W
08DBA:  MOVWF  FEA
08DBC:  MOVFF  FEC,03
08DC0:  MOVF   FED,F
08DC2:  MOVF   FEF,W
08DC4:  SUBWF  01,W
08DC6:  MOVWF  00
08DC8:  MOVF   03,W
08DCA:  SUBWFB 02,W
08DCC:  MOVWF  03
08DCE:  MOVF   00,W
08DD0:  SUBLW  C8
08DD2:  BC    8E0A
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
08DD4:  MOVF   x88,W
08DD6:  MULLW  04
08DD8:  MOVF   FF3,W
08DDA:  CLRF   03
08DDC:  ADDLW  B5
08DDE:  MOVWF  FE9
08DE0:  MOVLW  02
08DE2:  ADDWFC 03,W
08DE4:  MOVWF  FEA
08DE6:  MOVLW  FF
08DE8:  MOVWF  FEF
08DEA:  MOVWF  FEC
08DEC:  MOVWF  FEC
08DEE:  MOVWF  FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
08DF0:  BCF    FD8.0
08DF2:  RLCF   x88,W
08DF4:  CLRF   03
08DF6:  ADDLW  66
08DF8:  MOVWF  FE9
08DFA:  MOVLW  01
08DFC:  ADDWFC 03,W
08DFE:  MOVWF  FEA
08E00:  MOVLW  01
08E02:  MOVWF  FEC
08E04:  MOVF   FED,F
08E06:  MOVLW  06
08E08:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
08E0A:  BTFSC  x82.1
08E0C:  BRA    8E12
....................                break; 
08E0E:  MOVLB  0
08E10:  BRA    9428
08E12:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
08E14:  BCF    FD8.0
08E16:  MOVLB  3
08E18:  RLCF   x88,W
08E1A:  CLRF   03
08E1C:  ADDLW  66
08E1E:  MOVWF  FE9
08E20:  MOVLW  01
08E22:  ADDWFC 03,W
08E24:  MOVWF  FEA
08E26:  MOVLW  01
08E28:  MOVWF  FEC
08E2A:  MOVF   FED,F
08E2C:  MOVLW  05
08E2E:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
08E30:  BCF    FD8.0
08E32:  RLCF   x88,W
08E34:  CLRF   03
08E36:  ADDLW  BB
08E38:  MOVWF  01
08E3A:  MOVLW  02
08E3C:  ADDWFC 03,F
08E3E:  MOVFF  01,38A
08E42:  MOVFF  03,38B
08E46:  MOVLB  0
08E48:  CALL   485C
08E4C:  MOVFF  38B,FEA
08E50:  MOVFF  38A,FE9
08E54:  MOVFF  02,FEC
08E58:  MOVF   FED,F
08E5A:  MOVFF  01,FEF
....................             i[hs]=0; 
08E5E:  CLRF   03
08E60:  MOVLB  3
08E62:  MOVF   x88,W
08E64:  ADDLW  B3
08E66:  MOVWF  FE9
08E68:  MOVLW  02
08E6A:  ADDWFC 03,W
08E6C:  MOVWF  FEA
08E6E:  CLRF   FEF
08E70:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
....................             { 
08E72:  MOVFF  389,38A
08E76:  CALL   687A
08E7A:  MOVF   01,F
08E7C:  BTFSC  FD8.2
08E7E:  BRA    9034
08E80:  MOVFF  389,38A
08E84:  MOVLW  03
08E86:  MOVLB  3
08E88:  MOVWF  x8C
08E8A:  MOVLW  83
08E8C:  MOVWF  x8B
08E8E:  MOVLB  0
08E90:  CALL   68A6
08E94:  MOVF   01,F
08E96:  BTFSC  FD8.2
08E98:  BRA    9034
08E9A:  BCF    FD8.0
08E9C:  MOVLB  3
08E9E:  RLCF   x88,W
08EA0:  CLRF   03
08EA2:  ADDLW  B9
08EA4:  MOVWF  FE9
08EA6:  MOVLW  02
08EA8:  ADDWFC 03,W
08EAA:  MOVWF  FEA
08EAC:  MOVFF  FEC,38B
08EB0:  MOVF   FED,F
08EB2:  MOVFF  FEF,38A
08EB6:  MOVF   x8A,F
08EB8:  BNZ   8EC4
08EBA:  MOVF   x8B,F
08EBC:  BTFSS  FD8.2
08EBE:  BRA    8EC4
08EC0:  MOVLB  0
08EC2:  BRA    9034
....................                http_post_len[hs] -= 1; 
08EC4:  BCF    FD8.0
08EC6:  RLCF   x88,W
08EC8:  CLRF   03
08ECA:  ADDLW  B9
08ECC:  MOVWF  FE9
08ECE:  MOVLW  02
08ED0:  ADDWFC 03,W
08ED2:  MOVWF  FEA
08ED4:  MOVLW  01
08ED6:  SUBWF  FEF,W
08ED8:  MOVWF  00
08EDA:  MOVLW  00
08EDC:  SUBWFB FEC,W
08EDE:  MOVWF  03
08EE0:  MOVF   00,W
08EE2:  MOVF   FED,F
08EE4:  MOVWF  FEF
08EE6:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
08EEA:  MOVF   x83,W
08EEC:  SUBLW  26
08EEE:  BZ    8F26
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
08EF0:  MOVF   x88,W
08EF2:  MULLW  FE
08EF4:  MOVF   FF3,W
08EF6:  CLRF   x8B
08EF8:  MOVWF  x8A
08EFA:  CLRF   03
08EFC:  MOVF   x88,W
08EFE:  ADDLW  B3
08F00:  MOVWF  FE9
08F02:  MOVLW  02
08F04:  ADDWFC 03,W
08F06:  MOVWF  FEA
08F08:  MOVF   FEF,W
08F0A:  INCF   FEF,F
08F0C:  CLRF   03
08F0E:  ADDWF  x8A,W
08F10:  MOVWF  01
08F12:  MOVF   x8B,W
08F14:  ADDWFC 03,F
08F16:  MOVF   01,W
08F18:  ADDLW  B5
08F1A:  MOVWF  FE9
08F1C:  MOVLW  01
08F1E:  ADDWFC 03,W
08F20:  MOVWF  FEA
08F22:  MOVFF  383,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
08F26:  MOVF   x83,W
08F28:  SUBLW  26
08F2A:  BZ    8F4E
08F2C:  BCF    FD8.0
08F2E:  RLCF   x88,W
08F30:  CLRF   03
08F32:  ADDLW  B9
08F34:  MOVWF  FE9
08F36:  MOVLW  02
08F38:  ADDWFC 03,W
08F3A:  MOVWF  FEA
08F3C:  MOVFF  FEC,38B
08F40:  MOVF   FED,F
08F42:  MOVFF  FEF,38A
08F46:  MOVF   x8A,F
08F48:  BNZ   9030
08F4A:  MOVF   x8B,F
08F4C:  BNZ   9030
....................                { 
....................                   buffer[hs][i[hs]]=0; 
08F4E:  MOVF   x88,W
08F50:  MULLW  FE
08F52:  MOVF   FF3,W
08F54:  CLRF   x8B
08F56:  MOVWF  x8A
08F58:  CLRF   03
08F5A:  MOVF   x88,W
08F5C:  ADDLW  B3
08F5E:  MOVWF  FE9
08F60:  MOVLW  02
08F62:  ADDWFC 03,W
08F64:  MOVWF  FEA
08F66:  CLRF   03
08F68:  MOVF   FEF,W
08F6A:  ADDWF  x8A,W
08F6C:  MOVWF  01
08F6E:  MOVF   x8B,W
08F70:  ADDWFC 03,F
08F72:  MOVF   01,W
08F74:  ADDLW  B5
08F76:  MOVWF  FE9
08F78:  MOVLW  01
08F7A:  ADDWFC 03,W
08F7C:  MOVWF  FEA
08F7E:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
08F80:  MOVF   x88,W
08F82:  MULLW  04
08F84:  MOVF   FF3,W
08F86:  CLRF   03
08F88:  ADDLW  B5
08F8A:  MOVWF  FE9
08F8C:  MOVLW  02
08F8E:  ADDWFC 03,W
08F90:  MOVWF  FEA
08F92:  MOVFF  FEF,38A
08F96:  MOVFF  FEC,38B
08F9A:  MOVFF  FEC,38C
08F9E:  MOVFF  FEC,38D
08FA2:  MOVF   x88,W
08FA4:  MULLW  FE
08FA6:  MOVF   FF3,W
08FA8:  CLRF   x8F
08FAA:  MOVWF  x8E
08FAC:  MOVLW  B5
08FAE:  ADDWF  x8E,F
08FB0:  MOVLW  01
08FB2:  ADDWFC x8F,F
08FB4:  MOVFF  38D,393
08FB8:  MOVFF  38C,392
08FBC:  MOVFF  38B,391
08FC0:  MOVFF  38A,390
08FC4:  MOVFF  38F,395
08FC8:  MOVFF  38E,394
08FCC:  MOVLB  0
08FCE:  CALL   7658
....................                   if (http_post_len[hs] == 0) 
08FD2:  BCF    FD8.0
08FD4:  MOVLB  3
08FD6:  RLCF   x88,W
08FD8:  CLRF   03
08FDA:  ADDLW  B9
08FDC:  MOVWF  FE9
08FDE:  MOVLW  02
08FE0:  ADDWFC 03,W
08FE2:  MOVWF  FEA
08FE4:  MOVFF  FEC,38B
08FE8:  MOVF   FED,F
08FEA:  MOVFF  FEF,38A
08FEE:  MOVF   x8A,F
08FF0:  BNZ   9020
08FF2:  MOVF   x8B,F
08FF4:  BNZ   9020
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
08FF6:  BCF    FD8.0
08FF8:  RLCF   x88,W
08FFA:  CLRF   03
08FFC:  ADDLW  66
08FFE:  MOVWF  FE9
09000:  MOVLW  01
09002:  ADDWFC 03,W
09004:  MOVWF  FEA
09006:  MOVLW  01
09008:  MOVWF  FEC
0900A:  MOVF   FED,F
0900C:  MOVLW  06
0900E:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
09010:  MOVFF  389,38D
09014:  MOVLB  0
09016:  CALL   7700
....................                      break; 
0901A:  BRA    9034
....................                   } 
....................                   else 
0901C:  BRA    9032
0901E:  MOVLB  3
....................                      i[hs]=0; 
09020:  CLRF   03
09022:  MOVF   x88,W
09024:  ADDLW  B3
09026:  MOVWF  FE9
09028:  MOVLW  02
0902A:  ADDWFC 03,W
0902C:  MOVWF  FEA
0902E:  CLRF   FEF
09030:  MOVLB  0
....................                } 
....................             } 
09032:  BRA    8E72
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
09034:  CALL   485C
09038:  MOVFF  02,38B
0903C:  MOVFF  01,38A
09040:  BCF    FD8.0
09042:  MOVLB  3
09044:  RLCF   x88,W
09046:  CLRF   03
09048:  ADDLW  BB
0904A:  MOVWF  FE9
0904C:  MOVLW  02
0904E:  ADDWFC 03,W
09050:  MOVWF  FEA
09052:  MOVFF  FEC,03
09056:  MOVF   FED,F
09058:  MOVFF  FEF,01
0905C:  MOVF   02,W
0905E:  SUBWF  03,W
09060:  BNC   906A
09062:  BNZ   906E
09064:  MOVF   01,W
09066:  SUBWF  x8A,W
09068:  BNC   906E
0906A:  MOVLW  00
0906C:  BRA    9070
0906E:  MOVLW  01
09070:  CLRF   03
09072:  IORWF  03,W
09074:  BZ    90B8
09076:  BCF    FD8.0
09078:  RLCF   x88,W
0907A:  CLRF   03
0907C:  ADDLW  BB
0907E:  MOVWF  FE9
09080:  MOVLW  02
09082:  ADDWFC 03,W
09084:  MOVWF  FEA
09086:  MOVFF  FEC,03
0908A:  MOVF   FED,F
0908C:  MOVF   FEF,W
0908E:  SUBLW  FF
09090:  MOVWF  x8A
09092:  MOVLW  FF
09094:  SUBFWB 03,W
09096:  MOVWF  x8B
09098:  MOVLB  0
0909A:  CALL   485C
0909E:  MOVF   01,W
090A0:  MOVLB  3
090A2:  ADDWF  x8A,F
090A4:  MOVF   02,W
090A6:  ADDWFC x8B,F
090A8:  MOVLW  01
090AA:  ADDWF  x8A,W
090AC:  MOVWF  01
090AE:  MOVLW  00
090B0:  ADDWFC x8B,W
090B2:  MOVWF  03
090B4:  MOVF   01,W
090B6:  BRA    90EC
090B8:  MOVLB  0
090BA:  CALL   485C
090BE:  MOVFF  02,38B
090C2:  MOVFF  01,38A
090C6:  BCF    FD8.0
090C8:  MOVLB  3
090CA:  RLCF   x88,W
090CC:  CLRF   03
090CE:  ADDLW  BB
090D0:  MOVWF  FE9
090D2:  MOVLW  02
090D4:  ADDWFC 03,W
090D6:  MOVWF  FEA
090D8:  MOVFF  FEC,03
090DC:  MOVF   FED,F
090DE:  MOVF   FEF,W
090E0:  SUBWF  01,W
090E2:  MOVWF  00
090E4:  MOVF   03,W
090E6:  SUBWFB 02,W
090E8:  MOVWF  03
090EA:  MOVF   00,W
090EC:  SUBLW  C8
090EE:  BC    9126
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
090F0:  MOVF   x88,W
090F2:  MULLW  04
090F4:  MOVF   FF3,W
090F6:  CLRF   03
090F8:  ADDLW  B5
090FA:  MOVWF  FE9
090FC:  MOVLW  02
090FE:  ADDWFC 03,W
09100:  MOVWF  FEA
09102:  MOVLW  FF
09104:  MOVWF  FEF
09106:  MOVWF  FEC
09108:  MOVWF  FEC
0910A:  MOVWF  FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
0910C:  BCF    FD8.0
0910E:  RLCF   x88,W
09110:  CLRF   03
09112:  ADDLW  66
09114:  MOVWF  FE9
09116:  MOVLW  01
09118:  ADDWFC 03,W
0911A:  MOVWF  FEA
0911C:  MOVLW  01
0911E:  MOVWF  FEC
09120:  MOVF   FED,F
09122:  MOVLW  06
09124:  MOVWF  FEF
....................             } 
....................             break; 
09126:  MOVLB  0
09128:  BRA    9428
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
0912A:  MOVLB  3
0912C:  MOVF   x88,W
0912E:  MULLW  04
09130:  MOVF   FF3,W
09132:  CLRF   03
09134:  ADDLW  69
09136:  MOVWF  FE9
09138:  MOVLW  01
0913A:  ADDWFC 03,W
0913C:  MOVWF  FEA
0913E:  MOVF   FEE,F
09140:  MOVF   FEE,F
09142:  CLRF   FEC
09144:  MOVF   FED,F
09146:  CLRF   FEF
09148:  MOVF   FED,F
0914A:  CLRF   FEF
0914C:  MOVF   FED,F
0914E:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
09150:  BCF    FD8.0
09152:  RLCF   x88,W
09154:  CLRF   03
09156:  ADDLW  66
09158:  MOVWF  FE9
0915A:  MOVLW  01
0915C:  ADDWFC 03,W
0915E:  MOVWF  FEA
09160:  MOVLW  01
09162:  MOVWF  FEC
09164:  MOVF   FED,F
09166:  MOVLW  07
09168:  MOVWF  FEF
0916A:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
0916C:  MOVFF  389,38D
09170:  CALL   7700
....................             if (TCPIsPutReady(currSocket)) 
09174:  MOVFF  389,3AD
09178:  CALL   774E
0917C:  MOVF   01,F
0917E:  BTFSC  FD8.2
09180:  BRA    92DE
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
09182:  MOVLB  3
09184:  MOVF   x88,W
09186:  MULLW  04
09188:  MOVF   FF3,W
0918A:  CLRF   03
0918C:  ADDLW  B5
0918E:  MOVWF  FE9
09190:  MOVLW  02
09192:  ADDWFC 03,W
09194:  MOVWF  FEA
09196:  MOVFF  FEF,38A
0919A:  MOVFF  FEC,38B
0919E:  MOVFF  FEC,38C
091A2:  MOVFF  FEC,38D
091A6:  INCFSZ x8A,W
091A8:  BRA    9202
091AA:  INCFSZ x8B,W
091AC:  BRA    9202
091AE:  INCFSZ x8C,W
091B0:  BRA    9202
091B2:  INCFSZ x8D,W
091B4:  BRA    9202
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
091B6:  MOVLW  00
091B8:  MOVWF  02
091BA:  MOVLW  01
091BC:  MOVWF  01
091BE:  MOVLW  18
091C0:  MOVWF  00
091C2:  CLRF   03
091C4:  MOVFF  03,38D
091C8:  MOVFF  02,38C
091CC:  MOVFF  01,38B
091D0:  MOVWF  x8A
091D2:  MOVFF  388,38E
091D6:  MOVLW  01
091D8:  MOVWF  x90
091DA:  MOVLW  F4
091DC:  MOVWF  x8F
091DE:  MOVFF  03,394
091E2:  MOVFF  02,393
091E6:  MOVFF  01,392
091EA:  MOVFF  00,391
091EE:  CLRF   x96
091F0:  CLRF   x95
091F2:  MOVLB  0
091F4:  CALL   8342
091F8:  MOVLB  3
091FA:  BCF    x82.0
091FC:  BTFSC  01.0
091FE:  BSF    x82.0
....................                else if (http_page_req[hs]) 
09200:  BRA    92BE
....................                 #if HTTP_USE_CONTENT_TYPE 
09202:  MOVF   x88,W
09204:  MULLW  04
09206:  MOVF   FF3,W
09208:  CLRF   03
0920A:  ADDLW  B5
0920C:  MOVWF  FE9
0920E:  MOVLW  02
09210:  ADDWFC 03,W
09212:  MOVWF  FEA
09214:  MOVF   FEF,F
09216:  BNZ   9224
09218:  MOVF   FEC,F
0921A:  BNZ   9224
0921C:  MOVF   FEC,F
0921E:  BNZ   9224
09220:  MOVF   FEC,F
09222:  BZ    9274
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
09224:  MOVF   x88,W
09226:  MULLW  04
09228:  MOVF   FF3,W
0922A:  CLRF   03
0922C:  ADDLW  B5
0922E:  MOVWF  FE9
09230:  MOVLW  02
09232:  ADDWFC 03,W
09234:  MOVWF  FEA
09236:  MOVFF  FEF,38A
0923A:  MOVFF  FEC,38B
0923E:  MOVFF  FEC,38C
09242:  MOVFF  FEC,38D
09246:  MOVFF  388,38E
0924A:  CLRF   x90
0924C:  MOVLW  C8
0924E:  MOVWF  x8F
09250:  MOVFF  38D,394
09254:  MOVFF  38C,393
09258:  MOVFF  38B,392
0925C:  MOVFF  38A,391
09260:  CLRF   x96
09262:  CLRF   x95
09264:  MOVLB  0
09266:  CALL   8342
0926A:  MOVLB  3
0926C:  BCF    x82.0
0926E:  BTFSC  01.0
09270:  BSF    x82.0
....................                 #endif 
....................                else 
09272:  BRA    92BE
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
09274:  MOVLW  00
09276:  MOVWF  02
09278:  MOVLW  00
0927A:  MOVWF  01
0927C:  MOVLW  D4
0927E:  MOVWF  00
09280:  CLRF   03
09282:  MOVFF  03,38D
09286:  MOVFF  02,38C
0928A:  MOVFF  01,38B
0928E:  MOVWF  x8A
09290:  MOVFF  388,38E
09294:  MOVLW  01
09296:  MOVWF  x90
09298:  MOVLW  94
0929A:  MOVWF  x8F
0929C:  MOVFF  03,394
092A0:  MOVFF  02,393
092A4:  MOVFF  01,392
092A8:  MOVFF  00,391
092AC:  CLRF   x96
092AE:  CLRF   x95
092B0:  MOVLB  0
092B2:  CALL   8342
092B6:  MOVLB  3
092B8:  BCF    x82.0
092BA:  BTFSC  01.0
092BC:  BSF    x82.0
....................  
....................                if (doneSend) 
092BE:  BTFSS  x82.0
092C0:  BRA    92DC
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
092C2:  BCF    FD8.0
092C4:  RLCF   x88,W
092C6:  CLRF   03
092C8:  ADDLW  66
092CA:  MOVWF  FE9
092CC:  MOVLW  01
092CE:  ADDWFC 03,W
092D0:  MOVWF  FEA
092D2:  MOVLW  01
092D4:  MOVWF  FEC
092D6:  MOVF   FED,F
092D8:  MOVLW  08
092DA:  MOVWF  FEF
092DC:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
092DE:  BRA    9428
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
092E0:  BCF    FD8.0
092E2:  MOVLB  3
092E4:  RLCF   x88,W
092E6:  CLRF   03
092E8:  ADDLW  66
092EA:  MOVWF  FE9
092EC:  MOVLW  01
092EE:  ADDWFC 03,W
092F0:  MOVWF  FEA
092F2:  MOVLW  01
092F4:  MOVWF  FEC
092F6:  MOVF   FED,F
092F8:  MOVLW  09
092FA:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
092FC:  BCF    FD8.0
092FE:  RLCF   x88,W
09300:  CLRF   03
09302:  ADDLW  BB
09304:  MOVWF  01
09306:  MOVLW  02
09308:  ADDWFC 03,F
0930A:  MOVFF  01,38A
0930E:  MOVFF  03,38B
09312:  MOVLB  0
09314:  CALL   485C
09318:  MOVFF  38B,FEA
0931C:  MOVFF  38A,FE9
09320:  MOVFF  02,FEC
09324:  MOVF   FED,F
09326:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
0932A:  MOVFF  389,38D
0932E:  CALL   7700
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
....................                ) 
09332:  MOVFF  389,3AD
09336:  CALL   774E
0933A:  MOVF   01,F
0933C:  BNZ   93FC
0933E:  CALL   485C
09342:  MOVFF  02,38B
09346:  MOVFF  01,38A
0934A:  BCF    FD8.0
0934C:  MOVLB  3
0934E:  RLCF   x88,W
09350:  CLRF   03
09352:  ADDLW  BB
09354:  MOVWF  FE9
09356:  MOVLW  02
09358:  ADDWFC 03,W
0935A:  MOVWF  FEA
0935C:  MOVFF  FEC,03
09360:  MOVF   FED,F
09362:  MOVFF  FEF,01
09366:  MOVF   02,W
09368:  SUBWF  03,W
0936A:  BNC   9374
0936C:  BNZ   9378
0936E:  MOVF   01,W
09370:  SUBWF  x8A,W
09372:  BNC   9378
09374:  MOVLW  00
09376:  BRA    937A
09378:  MOVLW  01
0937A:  CLRF   03
0937C:  IORWF  03,W
0937E:  BZ    93C2
09380:  BCF    FD8.0
09382:  RLCF   x88,W
09384:  CLRF   03
09386:  ADDLW  BB
09388:  MOVWF  FE9
0938A:  MOVLW  02
0938C:  ADDWFC 03,W
0938E:  MOVWF  FEA
09390:  MOVFF  FEC,03
09394:  MOVF   FED,F
09396:  MOVF   FEF,W
09398:  SUBLW  FF
0939A:  MOVWF  x8A
0939C:  MOVLW  FF
0939E:  SUBFWB 03,W
093A0:  MOVWF  x8B
093A2:  MOVLB  0
093A4:  CALL   485C
093A8:  MOVF   01,W
093AA:  MOVLB  3
093AC:  ADDWF  x8A,F
093AE:  MOVF   02,W
093B0:  ADDWFC x8B,F
093B2:  MOVLW  01
093B4:  ADDWF  x8A,W
093B6:  MOVWF  01
093B8:  MOVLW  00
093BA:  ADDWFC x8B,W
093BC:  MOVWF  03
093BE:  MOVF   01,W
093C0:  BRA    93F6
093C2:  MOVLB  0
093C4:  CALL   485C
093C8:  MOVFF  02,38B
093CC:  MOVFF  01,38A
093D0:  BCF    FD8.0
093D2:  MOVLB  3
093D4:  RLCF   x88,W
093D6:  CLRF   03
093D8:  ADDLW  BB
093DA:  MOVWF  FE9
093DC:  MOVLW  02
093DE:  ADDWFC 03,W
093E0:  MOVWF  FEA
093E2:  MOVFF  FEC,03
093E6:  MOVF   FED,F
093E8:  MOVF   FEF,W
093EA:  SUBWF  01,W
093EC:  MOVWF  00
093EE:  MOVF   03,W
093F0:  SUBWFB 02,W
093F2:  MOVWF  03
093F4:  MOVF   00,W
093F6:  SUBLW  32
093F8:  BC    9420
093FA:  MOVLB  0
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
093FC:  MOVFF  389,38A
09400:  GOTO   8676
....................                http_state[hs]=HTTP_CLOSED; 
09404:  BCF    FD8.0
09406:  MOVLB  3
09408:  RLCF   x88,W
0940A:  CLRF   03
0940C:  ADDLW  66
0940E:  MOVWF  FE9
09410:  MOVLW  01
09412:  ADDWFC 03,W
09414:  MOVWF  FEA
09416:  MOVLW  01
09418:  MOVWF  FEC
0941A:  MOVF   FED,F
0941C:  MOVLW  0A
0941E:  MOVWF  FEF
....................             } 
....................             break; 
09420:  MOVLB  0
09422:  BRA    9428
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
09424:  MOVLB  0
09426:  BRA    9428
....................       } 
....................    } 
09428:  MOVLB  3
0942A:  INCF   x88,F
0942C:  GOTO   87B8
.................... } 
09430:  MOVLB  0
09432:  GOTO   A33A (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
.................... //NOTE: CCS MADE SOME API CHANGES TO THIS ANNOUNCE 
....................  
.................... /********************************************************************* 
....................  * 
....................  *                  Announce Module Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        announce.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     10/7/04  Original 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  ********************************************************************/ 
.................... #ifndef ANNONCE_H 
.................... #define ANNONCE_H 
....................  
.................... /* 
.................... There are many configuration options at the top of Announce.c 
.................... */ 
....................  
.................... /* 
....................  InitAnnounce(c) 
....................   
....................  Adds char c to the announce message.  Will reset position of string if c is 
....................  '\r'.  Ideal usage of this function will be with a printf.  For example: 
....................       printf(InitAnnounce, "\rUNIT-%LU-%LU", SerialNumber, HTTPPort) 
.................... */ 
.................... void  InitAnnounce(char c); 
....................  
.................... /* 
....................  AnnounceEnable() 
....................   
....................  Start announce messages.  From this point on the TCP/IP stack will send an 
....................  announce message on the configured port at the configured interval. 
.................... */ 
.................... void AnnounceEnable(void); 
....................  
.................... /* 
....................  AnnounceDisable() 
....................   
....................  Stop announce messages. 
.................... */ 
.................... void AnnounceDisable(void); 
.................... #endif 
....................  
....................    #include "tcpip/announce.c" 
.................... //NOTE: CCS MADE SOME API CHANGES TO THIS ANNOUNCE 
....................  
.................... /********************************************************************* 
....................  * 
....................  *                  Announce Module for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        announce.c 
....................  * Dependencies:    UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     10/7/04   Original 
....................  * Howard Schlunder      2/9/05   Simplified MAC address to text 
....................  *                        conversion logic 
....................  * Howard Schlunder      2/14/05   Fixed subnet broadcast calculation 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_ANNOUNCE_REPEAT 
.................... #define STACK_USE_ANNOUNCE_REPEAT   TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_ANNOUNCE_RATE 
.................... #define STACK_ANNOUNCE_RATE   5  //every 5 seconds 
.................... #endif 
....................  
.................... #ifndef ANNOUNCE_STR_MAX_SIZE 
.................... #define ANNOUNCE_STR_MAX_SIZE 30 
.................... #endif 
....................  
.................... #ifndef STACK_ANNOUNCE_PORT 
.................... #define STACK_ANNOUNCE_PORT   6123 
.................... #endif 
....................  
.................... char g_AnnounceMessage[ANNOUNCE_STR_MAX_SIZE]={0}; 
.................... int1 g_AnnounceEnabled=FALSE; 
.................... TICKTYPE g_AnnounceTick; 
....................  
.................... #if !STACK_USE_ANNOUNCE_REPEAT 
....................  static int g_AnnounceNum; 
.................... #endif 
....................  
.................... void AnnounceEnable(void) 
.................... { 
....................    g_AnnounceEnabled = TRUE; 
....................    g_AnnounceTick = TickGet() - ((TICKTYPE)STACK_ANNOUNCE_RATE*TICKS_PER_SECOND);  
....................  #if !STACK_USE_ANNOUNCE_REPEAT 
....................    g_AnnounceNum = 3; 
....................  #endif 
.................... } 
....................  
.................... void AnnounceDisable(void) 
.................... { 
....................    g_AnnounceEnabled = FALSE; 
.................... } 
....................  
.................... void InitAnnounce(char c) 
.................... { 
....................    static int i; 
....................     
....................    if (c=='\r') 
*
00FA2:  MOVLB  3
00FA4:  MOVF   x7C,W
00FA6:  SUBLW  0D
00FA8:  BNZ   0FB0
....................       i = 0; 
00FAA:  MOVLB  2
00FAC:  CLRF   xDD
....................    else if ( i < (ANNOUNCE_STR_MAX_SIZE-1) ) 
00FAE:  BRA    0FDC
00FB0:  MOVLB  2
00FB2:  MOVF   xDD,W
00FB4:  SUBLW  1C
00FB6:  BNC   0FDC
....................    { 
....................       g_AnnounceMessage[i++] = c; 
00FB8:  MOVF   xDD,W
00FBA:  INCF   xDD,F
00FBC:  CLRF   03
00FBE:  ADDLW  BD
00FC0:  MOVWF  FE9
00FC2:  MOVLW  02
00FC4:  ADDWFC 03,W
00FC6:  MOVWF  FEA
00FC8:  MOVFF  37C,FEF
....................       g_AnnounceMessage[i] = 0; 
00FCC:  CLRF   03
00FCE:  MOVF   xDD,W
00FD0:  ADDLW  BD
00FD2:  MOVWF  FE9
00FD4:  MOVLW  02
00FD6:  ADDWFC 03,W
00FD8:  MOVWF  FEA
00FDA:  CLRF   FEF
....................    } 
.................... } 
00FDC:  MOVLB  0
00FDE:  GOTO   0FEE (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        int AnnounceIP(void) 
....................  * 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if success 
....................  *                  FALSE because the MAC isn't ready to TX -OR- no UDP sockets 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        AnnounceIP opens a UDP socket and transmits a 
....................  *               broadcast packet to port 30303.  If a computer is 
....................  *               on the same subnet and a utility is looking for 
....................  *               packets on the UDP port, it will receive the 
....................  *               broadcast.  For this application, it is used to 
....................  *               announce the change of this board's IP address. 
....................  *               The messages can be viewed with the MCHPDetect.exe 
....................  *               program. 
....................  * 
....................  * Note:            A UDP socket must be available before this 
....................  *               function is called.  It is freed at the end of 
....................  *               the function.  MAX_UDP_SOCKETS may need to be 
....................  *               increased if other modules use UDP sockets. 
....................  ********************************************************************/ 
.................... int AnnounceIP(void) 
.................... { 
....................    UDP_SOCKET   MySocket; 
....................    NODE_INFO   Remote; 
....................  
....................    if (!g_AnnounceEnabled) 
*
06212:  BTFSC  56.2
06214:  BRA    621C
....................       return(TRUE); 
06216:  MOVLW  01
06218:  MOVWF  01
0621A:  BRA    62D6
....................  
....................    // Make certain the MAC can be written to 
....................    if (!MACIsTxReady(FALSE)) 
0621C:  MOVLB  4
0621E:  CLRF   x0B
06220:  MOVLB  0
06222:  CALL   497A
06226:  MOVF   01,F
06228:  BNZ   6230
....................       return(FALSE); 
0622A:  MOVLW  00
0622C:  MOVWF  01
0622E:  BRA    62D6
....................  
....................    // Set the socket's destination to be a broadcast over our IP 
....................    // subnet 
....................    // Set the MAC destination to be a broadcast 
....................    Remote.MACAddr.v[0] = 0xFF; 
06230:  MOVLW  FF
06232:  MOVLB  3
06234:  MOVWF  x85
....................    Remote.MACAddr.v[1] = 0xFF; 
06236:  MOVWF  x86
....................    Remote.MACAddr.v[2] = 0xFF; 
06238:  MOVWF  x87
....................    Remote.MACAddr.v[3] = 0xFF; 
0623A:  MOVWF  x88
....................    Remote.MACAddr.v[4] = 0xFF; 
0623C:  MOVWF  x89
....................    Remote.MACAddr.v[5] = 0xFF; 
0623E:  MOVWF  x8A
....................  
....................    // Set the IP subnet's broadcast address 
....................    Remote.IPAddr.Val = (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | 
....................                    ~AppConfig.MyMask.Val; 
06240:  MOVF   16,W
06242:  ANDWF  20,W
06244:  MOVWF  x8F
06246:  MOVF   17,W
06248:  ANDWF  21,W
0624A:  MOVWF  x90
0624C:  MOVF   18,W
0624E:  ANDWF  22,W
06250:  MOVWF  x91
06252:  MOVF   19,W
06254:  ANDWF  23,W
06256:  MOVWF  x92
06258:  MOVFF  20,00
0625C:  COMF   00,F
0625E:  MOVFF  21,01
06262:  COMF   01,F
06264:  MOVFF  22,02
06268:  COMF   02,F
0626A:  MOVFF  23,03
0626E:  COMF   03,F
06270:  MOVF   00,W
06272:  IORWF  x8F,W
06274:  MOVWF  x8B
06276:  MOVF   01,W
06278:  IORWF  x90,W
0627A:  MOVWF  x8C
0627C:  MOVF   02,W
0627E:  IORWF  x91,W
06280:  MOVWF  x8D
06282:  MOVF   03,W
06284:  IORWF  x92,W
06286:  MOVWF  x8E
....................  
....................    // Open a UDP socket for outbound transmission 
....................    MySocket = UDPOpen(STACK_ANNOUNCE_PORT, &Remote, STACK_ANNOUNCE_PORT); 
06288:  MOVLW  17
0628A:  MOVWF  x90
0628C:  MOVLW  EB
0628E:  MOVWF  x8F
06290:  MOVLW  03
06292:  MOVWF  x92
06294:  MOVLW  85
06296:  MOVWF  x91
06298:  MOVLW  17
0629A:  MOVWF  x94
0629C:  MOVLW  EB
0629E:  MOVWF  x93
062A0:  MOVLB  0
062A2:  RCALL  5E7C
062A4:  MOVFF  01,384
....................  
....................    // Abort operation if no UDP sockets are available 
....................    // If this ever happens, incrementing MAX_UDP_SOCKETS in 
....................    // StackTsk.h may help (at the expense of more global memory 
....................    // resources). 
....................    if( MySocket == INVALID_UDP_SOCKET ) 
062A8:  MOVLB  3
062AA:  INCFSZ x84,W
062AC:  BRA    62B6
....................       return(FALSE); 
062AE:  MOVLW  00
062B0:  MOVWF  01
062B2:  MOVLB  0
062B4:  BRA    62D6
....................  
....................    UDPIsPutReady(MySocket); 
062B6:  MOVFF  384,38F
062BA:  MOVLB  0
062BC:  RCALL  5F42
....................  
....................    printf(UDPPut, "%s", g_AnnounceMessage); 
062BE:  MOVLW  02
062C0:  MOVWF  FEA
062C2:  MOVLW  BD
062C4:  MOVWF  FE9
062C6:  BRA    61EC
....................  
....................    // Send the packet 
....................    UDPFlush(); 
062C8:  RCALL  5F56
....................  
....................    // Close the socket so it can be used by other modules 
....................    UDPClose(MySocket); 
062CA:  MOVFF  384,38F
062CE:  CALL   14DC
....................  
....................    return(TRUE); 
062D2:  MOVLW  01
062D4:  MOVWF  01
.................... } 
062D6:  GOTO   6364 (RETURN)
....................  
.................... /* 
....................  AnnounceTask() 
....................   
....................  This is called periodically by StackTask(), and will repeat the announce 
....................  message upon it's configured period.  If STACK_USE_ANNOUNCE_REPEAT is set 
....................  to FALSE then it will only send a message 3 times. 
.................... */ 
.................... void AnnounceTask(void) 
.................... { 
....................    TICKTYPE currTick; 
....................     
....................    currTick = TickGet(); 
062DA:  CALL   485C
062DE:  MOVFF  02,383
062E2:  MOVFF  01,382
....................     
....................  #if !STACK_USE_ANNOUNCE_REPEAT 
....................    if (g_AnnounceNum) 
....................  #endif 
....................    { 
....................       if (TickGetDiff(currTick, g_AnnounceTick) >= ((TICKTYPE)STACK_ANNOUNCE_RATE*TICKS_PER_SECOND)) 
062E6:  MOVLB  3
062E8:  MOVF   x83,W
062EA:  MOVLB  2
062EC:  SUBWF  xDC,W
062EE:  BNC   6302
062F0:  BNZ   6306
062F2:  MOVF   xDB,W
062F4:  MOVLB  3
062F6:  SUBWF  x82,W
062F8:  BTFSC  FD8.0
062FA:  BRA    6300
062FC:  MOVLB  2
062FE:  BRA    6306
06300:  MOVLB  2
06302:  MOVLW  00
06304:  BRA    6308
06306:  MOVLW  01
06308:  CLRF   03
0630A:  IORWF  03,W
0630C:  BZ    633C
0630E:  MOVLW  FF
06310:  BSF    FD8.0
06312:  SUBFWB xDB,W
06314:  MOVLB  3
06316:  MOVWF  x84
06318:  MOVLW  FF
0631A:  MOVLB  2
0631C:  SUBFWB xDC,W
0631E:  MOVLB  3
06320:  MOVWF  x85
06322:  MOVF   x82,W
06324:  ADDWF  x84,F
06326:  MOVF   x83,W
06328:  ADDWFC x85,F
0632A:  MOVLW  01
0632C:  ADDWF  x84,W
0632E:  MOVWF  01
06330:  MOVLW  00
06332:  ADDWFC x85,W
06334:  MOVWF  03
06336:  MOVF   01,W
06338:  BRA    6350
0633A:  MOVLB  2
0633C:  MOVF   xDB,W
0633E:  MOVLB  3
06340:  SUBWF  x82,W
06342:  MOVWF  00
06344:  MOVLB  2
06346:  MOVF   xDC,W
06348:  MOVLB  3
0634A:  SUBWFB x83,W
0634C:  MOVWF  03
0634E:  MOVF   00,W
06350:  MOVWF  x84
06352:  MOVFF  03,385
06356:  MOVF   x85,F
06358:  BNZ   6360
0635A:  MOVF   x84,W
0635C:  SUBLW  31
0635E:  BC    6372
....................       { 
....................          if (AnnounceIP()) 
06360:  MOVLB  0
06362:  BRA    6212
06364:  MOVF   01,F
06366:  BZ    6370
....................          { 
....................           #if !STACK_USE_ANNOUNCE_REPEAT 
....................             g_AnnounceNum--; 
....................           #endif 
....................             g_AnnounceTick = currTick; 
06368:  MOVFF  383,2DC
0636C:  MOVFF  382,2DB
06370:  MOVLB  3
....................          } 
....................       } 
....................    } 
.................... } 
06372:  MOVLB  0
06374:  GOTO   A332 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
0197E:  MOVLB  2
01980:  CLRF   xDE
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
01982:  BSF    2C.1
.................... #endif 
....................  
....................    TickInit(); 
01984:  MOVLB  0
01986:  GOTO   0FF2
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
0198A:  BRA    12EC
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
0198C:  BRA    14BC
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
0198E:  BRA    155A
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
01990:  BRA    16A6
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
01992:  RCALL  17EC
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
01994:  BRA    1914
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPInit(); 
.................... #endif 
.................... } 
01996:  GOTO   1AD4 (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
0A118:  MOVLB  3
0A11A:  BCF    x81.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
0A11C:  BCF    x81.0
....................         switch(smStack) 
....................         { 
0A11E:  MOVLB  2
0A120:  MOVF   xDE,W
0A122:  ADDLW  F8
0A124:  BTFSC  FD8.0
0A126:  BRA    A326
0A128:  ADDLW  08
0A12A:  MOVLB  0
0A12C:  GOTO   A346
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
0A130:  MOVLW  02
0A132:  MOVLB  3
0A134:  MOVWF  x83
0A136:  MOVLW  DF
0A138:  MOVWF  x82
0A13A:  MOVLW  03
0A13C:  MOVWF  x85
0A13E:  MOVLW  80
0A140:  MOVWF  x84
0A142:  MOVLB  0
0A144:  GOTO   3158
0A148:  MOVF   01,F
0A14A:  BNZ   A16E
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
0A14C:  MOVF   x85,W
0A14E:  SUBLW  08
0A150:  BZ    A168
....................                     { 
....................                         if ( !MACIsLinked() ) 
0A152:  CALL   2F04
0A156:  MOVF   01,F
0A158:  BNZ   A168
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
0A15A:  CLRF   19
0A15C:  CLRF   18
0A15E:  CLRF   17
0A160:  CLRF   16
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
0A162:  BSF    2C.1
....................                             DHCPReset(); 
0A164:  CALL   17EC
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
0A168:  MOVLB  2
0A16A:  BRA    A326
0A16C:  MOVLB  0
....................             } 
....................  
....................             debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
0A16E:  MOVLB  3
0A170:  BSF    x81.0
....................             if ( type.MACFrameType == MAC_IP ) { 
0A172:  MOVF   x80,F
0A174:  BNZ   A180
....................                 smStack = SM_STACK_IP; 
0A176:  MOVLW  02
0A178:  MOVLB  2
0A17A:  MOVWF  xDE
....................                 debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
0A17C:  BRA    A198
0A17E:  MOVLB  3
0A180:  MOVF   x80,W
0A182:  SUBLW  06
0A184:  BNZ   A190
....................                 smStack = SM_STACK_ARP; 
0A186:  MOVLW  05
0A188:  MOVLB  2
0A18A:  MOVWF  xDE
....................                 debug_stack("ARP "); 
....................             } 
....................             else { 
0A18C:  BRA    A198
0A18E:  MOVLB  3
....................                 MACDiscardRx(); 
0A190:  MOVLB  0
0A192:  CALL   3070
0A196:  MOVLB  2
....................                 debug_stack("DISCARD"); 
....................             } 
....................             break; 
0A198:  BRA    A326
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
0A19A:  GOTO   3A10
0A19E:  MOVF   01,F
0A1A0:  BZ    A1A6
....................                 smStack = SM_STACK_IDLE; 
0A1A2:  MOVLB  2
0A1A4:  CLRF   xDE
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
0A1A6:  MOVLB  2
0A1A8:  BRA    A326
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
0A1AA:  MOVLW  03
0A1AC:  MOVLB  3
0A1AE:  MOVWF  x83
0A1B0:  MOVLW  7C
0A1B2:  MOVWF  x82
0A1B4:  MOVLW  02
0A1B6:  MOVWF  x85
0A1B8:  MOVLW  DF
0A1BA:  MOVWF  x84
0A1BC:  MOVLW  03
0A1BE:  MOVWF  x87
0A1C0:  MOVLW  80
0A1C2:  MOVWF  x86
0A1C4:  MOVLW  02
0A1C6:  MOVWF  x89
0A1C8:  MOVLW  E9
0A1CA:  MOVWF  x88
0A1CC:  MOVLB  0
0A1CE:  GOTO   3D0E
0A1D2:  MOVF   01,F
0A1D4:  BZ    A218
....................             { 
....................                 lbContinue = TRUE; 
0A1D6:  MOVLB  3
0A1D8:  BSF    x81.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
0A1DA:  DECFSZ x80,W
0A1DC:  BRA    A1E8
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
0A1DE:  MOVLW  03
0A1E0:  MOVLB  2
0A1E2:  MOVWF  xDE
....................                     debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
0A1E4:  BRA    A214
0A1E6:  MOVLB  3
0A1E8:  MOVF   x80,W
0A1EA:  SUBLW  06
0A1EC:  BNZ   A1F8
....................                     smStack = SM_STACK_TCP; 
0A1EE:  MOVLW  06
0A1F0:  MOVLB  2
0A1F2:  MOVWF  xDE
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
0A1F4:  BRA    A214
0A1F6:  MOVLB  3
0A1F8:  MOVF   x80,W
0A1FA:  SUBLW  11
0A1FC:  BNZ   A208
....................                     smStack = SM_STACK_UDP; 
0A1FE:  MOVLW  07
0A200:  MOVLB  2
0A202:  MOVWF  xDE
....................                     debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
0A204:  BRA    A214
0A206:  MOVLB  3
....................                 { 
....................                     lbContinue = FALSE; 
0A208:  BCF    x81.0
....................                     MACDiscardRx(); 
0A20A:  MOVLB  0
0A20C:  CALL   3070
....................  
....................                     smStack = SM_STACK_IDLE; 
0A210:  MOVLB  2
0A212:  CLRF   xDE
....................                     debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
....................             else 
0A214:  BRA    A220
0A216:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
0A218:  CALL   3070
....................                 smStack = SM_STACK_IDLE; 
0A21C:  MOVLB  2
0A21E:  CLRF   xDE
....................                 debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
0A220:  BRA    A326
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0A222:  MOVLW  02
0A224:  MOVLB  3
0A226:  MOVWF  x83
0A228:  MOVLW  DF
0A22A:  MOVWF  x82
0A22C:  MOVLW  03
0A22E:  MOVWF  x85
0A230:  MOVLW  7C
0A232:  MOVWF  x84
0A234:  MOVFF  2EA,387
0A238:  MOVFF  2E9,386
0A23C:  MOVLB  0
0A23E:  GOTO   422C
0A242:  MOVF   01,F
0A244:  BZ    A24A
....................             { 
....................                 debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0A246:  MOVLB  2
0A248:  CLRF   xDE
....................             } 
....................             break; 
0A24A:  MOVLB  2
0A24C:  BRA    A326
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0A24E:  MOVLW  02
0A250:  MOVLB  3
0A252:  MOVWF  x83
0A254:  MOVLW  DF
0A256:  MOVWF  x82
0A258:  MOVLW  03
0A25A:  MOVWF  x85
0A25C:  MOVLW  7C
0A25E:  MOVWF  x84
0A260:  MOVFF  2EA,387
0A264:  MOVFF  2E9,386
0A268:  MOVLB  0
0A26A:  GOTO   59DE
0A26E:  MOVF   01,F
0A270:  BZ    A276
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0A272:  MOVLB  2
0A274:  CLRF   xDE
....................             } 
....................             break; 
0A276:  MOVLB  2
0A278:  BRA    A326
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
0A27A:  MOVLB  2
0A27C:  CLRF   xDE
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
0A27E:  MOVF   xEA,F
0A280:  BNZ   A2D4
0A282:  MOVF   xE9,W
0A284:  SUBLW  48
0A286:  BNC   A2D4
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
0A288:  MOVLW  02
0A28A:  MOVLB  3
0A28C:  MOVWF  x83
0A28E:  MOVLW  E9
0A290:  MOVWF  x82
0A292:  MOVLW  03
0A294:  MOVWF  x85
0A296:  MOVLW  80
0A298:  MOVWF  x84
0A29A:  MOVLW  02
0A29C:  MOVWF  x87
0A29E:  MOVLW  EB
0A2A0:  MOVWF  x86
0A2A2:  MOVFF  383,389
0A2A6:  MOVFF  382,388
0A2AA:  MOVLW  03
0A2AC:  MOVWF  x8B
0A2AE:  MOVLW  2B
0A2B0:  MOVWF  x8A
0A2B2:  MOVLW  03
0A2B4:  MOVWF  x8D
0A2B6:  MOVLW  2D
0A2B8:  MOVWF  x8C
0A2BA:  MOVLB  0
0A2BC:  GOTO   5C72
0A2C0:  MOVF   01,F
0A2C2:  BZ    A2D8
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
0A2C4:  MOVLB  3
0A2C6:  MOVF   x80,W
0A2C8:  SUBLW  08
0A2CA:  BNZ   A2D6
....................                     { 
....................                         debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
0A2CC:  BSF    x81.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
0A2CE:  MOVLW  04
0A2D0:  MOVLB  2
0A2D2:  MOVWF  xDE
0A2D4:  MOVLB  3
0A2D6:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
0A2D8:  CALL   3070
....................             break; 
0A2DC:  MOVLB  2
0A2DE:  BRA    A326
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
0A2E0:  MOVLW  01
0A2E2:  MOVLB  4
0A2E4:  MOVWF  x0B
0A2E6:  MOVLB  0
0A2E8:  CALL   497A
0A2EC:  MOVF   01,F
0A2EE:  BZ    A322
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
0A2F0:  MOVLW  02
0A2F2:  MOVLB  3
0A2F4:  MOVWF  x83
0A2F6:  MOVLW  DF
0A2F8:  MOVWF  x82
0A2FA:  CLRF   x84
0A2FC:  MOVLW  02
0A2FE:  MOVWF  x86
0A300:  MOVLW  EB
0A302:  MOVWF  x85
0A304:  MOVFF  2E9,387
0A308:  MOVFF  32C,389
0A30C:  MOVFF  32B,388
0A310:  MOVFF  32E,38B
0A314:  MOVFF  32D,38A
0A318:  MOVLB  0
0A31A:  GOTO   5D60
....................  
....................                 debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0A31E:  MOVLB  2
0A320:  CLRF   xDE
....................             } 
....................             break; 
0A322:  MOVLB  2
0A324:  BRA    A326
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
0A326:  MOVLB  3
0A328:  BTFSC  x81.0
0A32A:  BRA    A11C
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
0A32C:  MOVLB  0
0A32E:  GOTO   62DA
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
0A332:  GOTO   6378
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
0A336:  GOTO   87B4
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
0A33A:  BRA    9C8C
....................  
....................     if ( DHCPIsBound() ) 
0A33C:  BTFSS  x86.0
0A33E:  BRA    A342
....................         AppConfig.Flags.bInConfigMode = FALSE; 
0A340:  BCF    2C.1
....................  
.................... #endif 
.................... } 
0A342:  GOTO   A8BA (RETURN)
....................  
....................  
.................... #include "ccshelper.c"   //include CCS's PICDEM.net/PICNET helper functions 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         CCSHELPER.C                               //// 
.................... ////                                                                   //// 
.................... //// Helper functions and definitions for using CCS's example programs //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            //// 
.................... ////                                                                   //// 
.................... ////    May 26, 2004: Fixed a bug in read_ext_eeprom_string() to       //// 
.................... ////                  prevent infinite loops when EEPROM is all 0xFF.  //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Settings saved to external EEPROM                //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
....................   #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
....................   #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICNET+STACK_USE_CCS_PICENS+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL3V+STACK_USE_CCS_EWL5V)==0 
....................    #error You must define one of the prototype boards 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET 
....................    #define ANALOG_PORT_CONFIG    ANALOG_AN0_TO_AN1 
....................    #define ADC_CHAN_0   0 
....................    #define ADC_CHAN_1   1 
....................    #define USER_BUTTON1 PIN_B0 
....................    #define USER_BUTTON2 PIN_B1 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
.................... #elif STACK_USE_CCS_PICENS 
....................    #define ANALOG_PORT_CONFIG    AN0 
....................    #define ADC_CHAN_0   0 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #elif STACK_USE_CCS_PICEEC 
....................    #define ANALOG_PORT_CONFIG    AN0_TO_AN2 
....................    #define ADC_CHAN_0   2 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #elif STACK_USE_CCS_EWL3V 
....................    #if !STACK_USE_PICDEM_LCD 
....................       #define ANALOG_PORT_CONFIG    AN0_TO_AN7 
....................       #define ADC_CHAN_0   6 
....................       #define ADC_CHAN_1   7 
....................       #define USER_LED1 DIGITAL3 
....................       #define USER_LED2 DIGITAL4 
....................    #else 
....................       #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #endif 
....................    #define BUTTON_PRESSED(p)  (input(p)) 
.................... #elif STACK_USE_CCS_EWL5V 
....................    #if !STACK_USE_PICDEM_LCD 
....................       #define ANALOG_PORT_CONFIG    AN0_TO_AN1 
....................       #define ADC_CHAN_0   0 
....................       #define ADC_CHAN_1   1 
....................       #define USER_LED1 DIGITAL3 
....................       #define USER_LED2 DIGITAL4 
....................    #else 
....................       #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #endif 
....................    #define BUTTON_PRESSED(p)  (input(p)) 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_EWL3V || STACK_USE_CCS_EWL5V) && CCS_EMAIL_EXAMPLE 
....................    #undef ANALOG_PORT_CONFIG 
....................    #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #define USER_BUTTON1 DIGITAL1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_EWL5V 
....................    #define DIGITAL1   PIN_A0    
....................    #define DIGITAL2   PIN_A1 
....................    #define DIGITAL3   PIN_A2 
....................    #define DIGITAL4   PIN_A3 
....................    #define DIGITAL5   PIN_A5 
....................    #define DIGITAL6   PIN_B0 
....................    #define DIGITAL7   PIN_B1 
....................    #define DIGITAL8   PIN_C6 
....................    #define DIGITAL9   PIN_C7 
....................    #define DIGITAL10  PIN_B6 
....................    #define DIGITAL11  PIN_B7 
.................... #elif STACK_USE_CCS_EWL3V 
....................    #define DIGITAL1   PIN_F1 
....................    #define DIGITAL2   PIN_F2 
....................    #define DIGITAL3   PIN_F3 
....................    #define DIGITAL4   PIN_F4 
....................    #define DIGITAL5   PIN_F5 
....................    #define DIGITAL6   PIN_F6 
....................    #define DIGITAL7   PIN_A3 
....................    #define DIGITAL8   PIN_C6 
....................    #define DIGITAL9   PIN_C7 
....................    #define DIGITAL10  PIN_B6 
....................    #define DIGITAL11  PIN_B7 
....................    #define DIGITAL12  PIN_B0 
....................    #define DIGITAL13  PIN_B1 
....................    #define DIGITAL14  PIN_B2 
....................    #define DIGITAL15  PIN_B3 
....................    #define DIGITAL16  PIN_B4 
....................    #define DIGITAL17  PIN_B5 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PICDEM_LCD 
....................    #define STACK_USE_PICDEM_LCD TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SERIAL 
....................    #define STACK_USE_SERIAL TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_EEPROM 
....................    #define STACK_USE_EEPROM   TRUE 
.................... #endif 
....................  
.................... #if STACK_USE_SERIAL 
....................  #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, STREAM=USER) 
*
027DA:  BTFSS  F9E.4
027DC:  BRA    27DA
027DE:  MOVWF  FAD
027E0:  RETLW  00
.................... #endif 
....................  
.................... #if STACK_USE_PICDEM_LCD 
....................    #if STACK_USE_CCS_PICNET 
....................       #include "tcpip/dlcd.c" 
....................    #elif STACK_USE_CCS_PICENS 
....................       #include "tcpip/mlcd.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             MLCD.C                                //// 
.................... ////                Driver for LCD Module on CCS PICENS                //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     E2  enable 
.................... //     E0  rs 
.................... //     E1  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int     empty: 4;         // on PORT D 
....................            int     data : 4; 
....................         } lcd_io,lcd_lat,lcd_tris; 
....................  
.................... #bit lcd_enable=0xF8D.2 
.................... #bit lcd_rs=0xF8D.0 
.................... #bit lcd_rw=0xF8D.1 
....................  
.................... #byte lcd_io = 0xF83                   // This puts the entire structure on PORT D 
.................... #byte lcd_lat = 0xF8C 
.................... #byte lcd_tris = 0xF95 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       lcd_tris.data=0xF;  //set_tris_lcd(LCD_READ); 
*
00A58:  MOVLW  0F
00A5A:  ANDWF  F95,W
00A5C:  IORLW  F0
00A5E:  MOVWF  F95
....................       lcd_rw = 1; 
00A60:  BSF    F8D.1
....................       delay_us(1); 
00A62:  MOVLW  03
00A64:  MOVWF  00
00A66:  DECFSZ 00,F
00A68:  BRA    0A66
....................       lcd_enable = 1; 
00A6A:  BSF    F8D.2
....................       delay_us(1); 
00A6C:  MOVLW  03
00A6E:  MOVWF  00
00A70:  DECFSZ 00,F
00A72:  BRA    0A70
....................       high = lcd_io.data; 
00A74:  SWAPF  F83,W
00A76:  ANDLW  0F
00A78:  MOVLB  3
00A7A:  MOVWF  xAE
....................       lcd_enable = 0; 
00A7C:  BCF    F8D.2
....................       delay_us(1); 
00A7E:  MOVLW  03
00A80:  MOVWF  00
00A82:  DECFSZ 00,F
00A84:  BRA    0A82
....................       lcd_enable = 1; 
00A86:  BSF    F8D.2
....................       delay_us(1); 
00A88:  MOVLW  03
00A8A:  MOVWF  00
00A8C:  DECFSZ 00,F
00A8E:  BRA    0A8C
....................       low = lcd_io.data; 
00A90:  SWAPF  F83,W
00A92:  ANDLW  0F
00A94:  MOVWF  xAD
....................       lcd_enable = 0; 
00A96:  BCF    F8D.2
....................       lcd_tris.data=0;  //set_tris_lcd(LCD_WRITE); 
00A98:  MOVLW  0F
00A9A:  ANDWF  F95,W
00A9C:  MOVWF  F95
....................       return( (high<<4) | low); 
00A9E:  SWAPF  xAE,W
00AA0:  MOVWF  00
00AA2:  MOVLW  F0
00AA4:  ANDWF  00,F
00AA6:  MOVF   00,W
00AA8:  IORWF  xAD,W
00AAA:  MOVWF  01
.................... } 
00AAC:  MOVLB  0
00AAE:  GOTO   0ABE (RETURN)
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd_lat.data = n; 
*
00A2E:  MOVLB  3
00A30:  SWAPF  xAE,W
00A32:  ANDLW  F0
00A34:  MOVWF  00
00A36:  MOVLW  0F
00A38:  ANDWF  F8C,W
00A3A:  IORWF  00,W
00A3C:  MOVWF  F8C
....................       delay_us(1); 
00A3E:  MOVLW  03
00A40:  MOVWF  00
00A42:  DECFSZ 00,F
00A44:  BRA    0A42
....................       lcd_enable = 1; 
00A46:  BSF    F8D.2
....................       delay_us(2); 
00A48:  MOVLW  06
00A4A:  MOVWF  00
00A4C:  DECFSZ 00,F
00A4E:  BRA    0A4C
00A50:  NOP   
....................       lcd_enable = 0; 
00A52:  BCF    F8D.2
.................... } 
00A54:  MOVLB  0
00A56:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd_rs = 0; 
*
00AB2:  BCF    F8D.0
....................       delay_us(1); 
00AB4:  MOVLW  03
00AB6:  MOVWF  00
00AB8:  DECFSZ 00,F
00ABA:  BRA    0AB8
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
00ABC:  BRA    0A58
00ABE:  MOVFF  01,3AD
00AC2:  MOVLB  3
00AC4:  BTFSS  01.7
00AC6:  BRA    0ACC
00AC8:  MOVLB  0
00ACA:  BRA    0ABC
....................       lcd_rs = address; 
00ACC:  BCF    F8D.0
00ACE:  BTFSC  xAB.0
00AD0:  BSF    F8D.0
....................       delay_us(1); 
00AD2:  MOVLW  03
00AD4:  MOVWF  00
00AD6:  DECFSZ 00,F
00AD8:  BRA    0AD6
....................       lcd_rw = 0; 
00ADA:  BCF    F8D.1
....................       delay_us(1); 
00ADC:  MOVLW  03
00ADE:  MOVWF  00
00AE0:  DECFSZ 00,F
00AE2:  BRA    0AE0
....................       lcd_enable = 0; 
00AE4:  BCF    F8D.2
....................       lcd_send_nibble(n >> 4); 
00AE6:  SWAPF  xAC,W
00AE8:  MOVWF  xAD
00AEA:  MOVLW  0F
00AEC:  ANDWF  xAD,F
00AEE:  MOVFF  3AD,3AE
00AF2:  MOVLB  0
00AF4:  RCALL  0A2E
....................       lcd_send_nibble(n & 0xf); 
00AF6:  MOVLB  3
00AF8:  MOVF   xAC,W
00AFA:  ANDLW  0F
00AFC:  MOVWF  xAD
00AFE:  MOVWF  xAE
00B00:  MOVLB  0
00B02:  RCALL  0A2E
.................... } 
00B04:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     lcd_tris.data=0;    //set_tris_lcd(LCD_WRITE); 
00B06:  MOVLW  0F
00B08:  ANDWF  F95,W
00B0A:  MOVWF  F95
....................     lcd_rs = 0; 
00B0C:  BCF    F8D.0
....................     lcd_rw = 0; 
00B0E:  BCF    F8D.1
....................     lcd_enable = 0; 
00B10:  BCF    F8D.2
....................     *0xF96=*0xF96 & 0xF8; 
00B12:  MOVLW  F8
00B14:  ANDWF  F96,F
....................     delay_ms(15); 
00B16:  MOVLW  0F
00B18:  MOVLB  3
00B1A:  MOVWF  xA7
00B1C:  MOVLB  0
00B1E:  RCALL  0A04
....................     for(i=1;i<=3;++i) { 
00B20:  MOVLW  01
00B22:  MOVLB  3
00B24:  MOVWF  x7C
00B26:  MOVF   x7C,W
00B28:  SUBLW  03
00B2A:  BNC   0B44
....................        lcd_send_nibble(3); 
00B2C:  MOVLW  03
00B2E:  MOVWF  xAE
00B30:  MOVLB  0
00B32:  RCALL  0A2E
....................        delay_ms(5); 
00B34:  MOVLW  05
00B36:  MOVLB  3
00B38:  MOVWF  xA7
00B3A:  MOVLB  0
00B3C:  RCALL  0A04
....................     } 
00B3E:  MOVLB  3
00B40:  INCF   x7C,F
00B42:  BRA    0B26
....................     lcd_send_nibble(2); 
00B44:  MOVLW  02
00B46:  MOVWF  xAE
00B48:  MOVLB  0
00B4A:  RCALL  0A2E
....................     delay_ms(5); 
00B4C:  MOVLW  05
00B4E:  MOVLB  3
00B50:  MOVWF  xA7
00B52:  MOVLB  0
00B54:  RCALL  0A04
....................     for(i=0;i<=3;++i) 
00B56:  MOVLB  3
00B58:  CLRF   x7C
00B5A:  MOVF   x7C,W
00B5C:  SUBLW  03
00B5E:  BNC   0B86
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
00B60:  CLRF   03
00B62:  MOVF   x7C,W
00B64:  MOVFF  FF2,37D
00B68:  BCF    FF2.7
00B6A:  MOVLB  0
00B6C:  CALL   0096
00B70:  MOVLB  3
00B72:  BTFSC  x7D.7
00B74:  BSF    FF2.7
00B76:  MOVWF  x7D
00B78:  CLRF   xAB
00B7A:  MOVWF  xAC
00B7C:  MOVLB  0
00B7E:  RCALL  0AB2
00B80:  MOVLB  3
00B82:  INCF   x7C,F
00B84:  BRA    0B5A
.................... } 
00B86:  MOVLB  0
00B88:  GOTO   19FC (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
00C7C:  MOVLB  3
00C7E:  DECFSZ xA8,W
00C80:  BRA    0C84
00C82:  BRA    0C8A
....................      address=lcd_line_two; 
00C84:  MOVLW  40
00C86:  MOVWF  xA9
....................    else 
00C88:  BRA    0C8C
....................      address=0; 
00C8A:  CLRF   xA9
....................    address+=x-1; 
00C8C:  MOVLW  01
00C8E:  SUBWF  xA7,W
00C90:  ADDWF  xA9,F
....................    lcd_send_byte(0,0x80|address); 
00C92:  MOVF   xA9,W
00C94:  IORLW  80
00C96:  MOVWF  xAA
00C98:  CLRF   xAB
00C9A:  MOVWF  xAC
00C9C:  MOVLB  0
00C9E:  RCALL  0AB2
.................... } 
00CA0:  GOTO   0CFE (RETURN)
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
00CA4:  MOVLB  3
00CA6:  MOVF   xA6,W
00CA8:  XORLW  0C
00CAA:  MOVLB  0
00CAC:  BZ    0CB8
00CAE:  XORLW  06
00CB0:  BZ    0CD0
00CB2:  XORLW  02
00CB4:  BZ    0CE0
00CB6:  BRA    0CEE
....................      case '\f'   : lcd_send_byte(0,1); 
00CB8:  MOVLB  3
00CBA:  CLRF   xAB
00CBC:  MOVLW  01
00CBE:  MOVWF  xAC
00CC0:  MOVLB  0
00CC2:  RCALL  0AB2
....................                    delay_ms(2); 
00CC4:  MOVLW  02
00CC6:  MOVLB  3
00CC8:  MOVWF  xA7
00CCA:  MOVLB  0
00CCC:  RCALL  0A04
....................                                            break; 
00CCE:  BRA    0CFE
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
00CD0:  MOVLW  01
00CD2:  MOVLB  3
00CD4:  MOVWF  xA7
00CD6:  MOVLW  02
00CD8:  MOVWF  xA8
00CDA:  MOVLB  0
00CDC:  BRA    0C7C
00CDE:  BRA    0CFE
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
00CE0:  MOVLB  3
00CE2:  CLRF   xAB
00CE4:  MOVLW  10
00CE6:  MOVWF  xAC
00CE8:  MOVLB  0
00CEA:  RCALL  0AB2
00CEC:  BRA    0CFE
....................      default     : lcd_send_byte(1,c);     break; 
00CEE:  MOVLW  01
00CF0:  MOVLB  3
00CF2:  MOVWF  xAB
00CF4:  MOVFF  3A6,3AC
00CF8:  MOVLB  0
00CFA:  RCALL  0AB2
00CFC:  BRA    0CFE
....................    } 
.................... } 
00CFE:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd_rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd_rs=0; 
....................     return(value); 
.................... } 
....................  
....................    #elif STACK_USE_CCS_PICEEC 
....................       #include "tcpip/elcd.c" 
....................    #elif STACK_USE_CCS_EWL 
....................       #include "tcpip/alcd.c" 
....................    #else 
....................       #error Can't use LCD without specifying which hardware. Or write your own LCD driver. 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET 
....................  #ifndef EEPROM_SDA 
....................     #define EEPROM_SDA  PIN_C4 
....................     #define EEPROM_SCL  PIN_C3 
....................     #include "24256.c"   //included with compiler 
....................  #endif 
.................... #elif STACK_USE_CCS_PICENS 
....................  #ifndef EEPROM_SELECT 
....................     #define EEPROM_SELECT PIN_B3 
....................     #define EEPROM_DI     PIN_C5 
....................     #define EEPROM_DO     PIN_C4 
....................     #define EEPROM_CLK    PIN_C3 
....................     #define EEPROM_USE_SPI    ENC_MAC_USE_SPI 
....................     #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
*
00BB0:  BCF    F8B.5
....................    output_low(EEPROM_CLK); 
00BB2:  BCF    F8B.3
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
00BB4:  BSF    F8A.3
....................    i=input(EEPROM_DO); 
00BB6:  MOVLB  3
00BB8:  BCF    x7C.0
00BBA:  BTFSC  F82.4
00BBC:  BSF    x7C.0
.................... } 
00BBE:  MOVLB  0
00BC0:  GOTO   1A04 (RETURN)
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    BYTE cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
00BC4:  MOVLW  05
00BC6:  MOVLB  3
00BC8:  MOVWF  x9A
....................  
....................    output_low(EEPROM_SELECT); 
00BCA:  BCF    F8A.3
....................  
....................    for(i=1;i<=8;++i) { 
00BCC:  MOVLW  01
00BCE:  MOVWF  x9B
00BD0:  MOVF   x9B,W
00BD2:  SUBLW  08
00BD4:  BNC   0BEA
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
00BD6:  BCF    FD8.0
00BD8:  RLCF   x9A,F
00BDA:  BC    0BE0
00BDC:  BCF    F8B.5
00BDE:  BRA    0BE2
00BE0:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
00BE2:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
00BE4:  BCF    F8B.3
....................    } 
00BE6:  INCF   x9B,F
00BE8:  BRA    0BD0
....................  
....................    for(i=1;i<=8;++i) { 
00BEA:  MOVLW  01
00BEC:  MOVWF  x9B
00BEE:  MOVF   x9B,W
00BF0:  SUBLW  08
00BF2:  BNC   0C08
....................         output_high(EEPROM_CLK);      //data latches 
00BF4:  BSF    F8B.3
....................         shift_left(&data,1,input(EEPROM_DO)); 
00BF6:  BTFSC  F82.4
00BF8:  BRA    0BFE
00BFA:  BCF    FD8.0
00BFC:  BRA    0C00
00BFE:  BSF    FD8.0
00C00:  RLCF   x9C,F
....................         output_low(EEPROM_CLK);              //back to idle 
00C02:  BCF    F8B.3
....................    } 
00C04:  INCF   x9B,F
00C06:  BRA    0BEE
....................    output_high(EEPROM_SELECT); 
00C08:  BSF    F8A.3
....................    return (!(bit_test(data, 0))); 
00C0A:  MOVLW  00
00C0C:  BTFSS  x9C.0
00C0E:  MOVLW  01
00C10:  MOVWF  01
.................... } 
00C12:  MOVLB  0
00C14:  RETLW  00
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data) { 
....................  
....................    BYTE cmd[4]; 
....................    BYTE i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
*
00D22:  MOVLB  3
00D24:  MOVFF  393,397
....................    cmd[1]=address-cmd[2];      //address lsb 
00D28:  MOVF   x97,W
00D2A:  SUBWF  x92,W
00D2C:  MOVWF  x96
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
00D2E:  MOVLB  0
00D30:  RCALL  0BC4
00D32:  MOVF   01,F
00D34:  BZ    0D30
....................  
....................    cmd[0]=0x06; 
00D36:  MOVLW  06
00D38:  MOVLB  3
00D3A:  MOVWF  x95
....................    output_low(EEPROM_SELECT); //cs is active low 
00D3C:  BCF    F8A.3
....................    for(i=1;i<=8;++i) { 
00D3E:  MOVLW  01
00D40:  MOVWF  x99
00D42:  MOVF   x99,W
00D44:  SUBLW  08
00D46:  BNC   0D5C
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
00D48:  BCF    FD8.0
00D4A:  RLCF   x95,F
00D4C:  BC    0D52
00D4E:  BCF    F8B.5
00D50:  BRA    0D54
00D52:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
00D54:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
00D56:  BCF    F8B.3
....................    } 
00D58:  INCF   x99,F
00D5A:  BRA    0D42
....................    output_high(EEPROM_SELECT); 
00D5C:  BSF    F8A.3
....................  
....................    cmd[0]=data; 
00D5E:  MOVFF  394,395
....................    cmd[3]=0x02;      //write opcode 
00D62:  MOVLW  02
00D64:  MOVWF  x98
....................    output_low(EEPROM_SELECT); 
00D66:  BCF    F8A.3
....................    for(i=1;i<=32;++i) { 
00D68:  MOVLW  01
00D6A:  MOVWF  x99
00D6C:  MOVF   x99,W
00D6E:  SUBLW  20
00D70:  BNC   0D8C
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
00D72:  BCF    FD8.0
00D74:  RLCF   x95,F
00D76:  RLCF   x96,F
00D78:  RLCF   x97,F
00D7A:  RLCF   x98,F
00D7C:  BC    0D82
00D7E:  BCF    F8B.5
00D80:  BRA    0D84
00D82:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
00D84:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
00D86:  BCF    F8B.3
....................    } 
00D88:  INCF   x99,F
00D8A:  BRA    0D6C
....................  
....................    output_high(EEPROM_SELECT); 
00D8C:  BSF    F8A.3
.................... } 
00D8E:  MOVLB  0
00D90:  RETLW  00
....................  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    BYTE i,data; 
....................    BYTE cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
*
00C16:  MOVLW  03
00C18:  MOVLB  3
00C1A:  MOVWF  x98
....................    cmd[1]=((address>>8)&(0xFF)); 
00C1C:  MOVFF  393,397
....................    cmd[0]=address-cmd[1]; 
00C20:  MOVF   x97,W
00C22:  SUBWF  x92,W
00C24:  MOVWF  x96
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
00C26:  MOVLB  0
00C28:  RCALL  0BC4
00C2A:  MOVF   01,F
00C2C:  BZ    0C28
....................    output_low(EEPROM_SELECT); 
00C2E:  BCF    F8A.3
....................    for(i=1;i<=24;++i) { 
00C30:  MOVLW  01
00C32:  MOVLB  3
00C34:  MOVWF  x94
00C36:  MOVF   x94,W
00C38:  SUBLW  18
00C3A:  BNC   0C54
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
00C3C:  BCF    FD8.0
00C3E:  RLCF   x96,F
00C40:  RLCF   x97,F
00C42:  RLCF   x98,F
00C44:  BC    0C4A
00C46:  BCF    F8B.5
00C48:  BRA    0C4C
00C4A:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
00C4C:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
00C4E:  BCF    F8B.3
....................    } 
00C50:  INCF   x94,F
00C52:  BRA    0C36
....................  
....................    for(i=1;i<=8;++i) { 
00C54:  MOVLW  01
00C56:  MOVWF  x94
00C58:  MOVF   x94,W
00C5A:  SUBLW  08
00C5C:  BNC   0C72
....................         output_high(EEPROM_CLK);      //data latches 
00C5E:  BSF    F8B.3
....................         shift_left(&data,1,input(EEPROM_DO)); 
00C60:  BTFSC  F82.4
00C62:  BRA    0C68
00C64:  BCF    FD8.0
00C66:  BRA    0C6A
00C68:  BSF    FD8.0
00C6A:  RLCF   x95,F
....................         output_low(EEPROM_CLK);              //back to idle 
00C6C:  BCF    F8B.3
....................    } 
00C6E:  INCF   x94,F
00C70:  BRA    0C58
....................  
....................    output_high(EEPROM_SELECT); 
00C72:  BSF    F8A.3
....................  
....................    return(data); 
00C74:  MOVFF  395,01
.................... } 
00C78:  MOVLB  0
00C7A:  RETLW  00
....................  
....................  #endif     
.................... #elif STACK_USE_CCS_PICEEC 
....................  #ifndef EEPROM_SELECT 
....................     #define EEPROM_SELECT PIN_C1  //o 
....................     #define EEPROM_DI     PIN_C5  //o 
....................     #define EEPROM_DO     PIN_C4  //i 
....................     #define EEPROM_CLK    PIN_C3  //o 
....................     #define EEPROM_USE_SPI   TRUE 
....................     #include "AT25256.C" 
....................  #endif 
.................... #elif STACK_USE_CCS_EWL5V 
....................  #ifndef FLASH_SELECT 
....................     #define FLASH_SELECT PIN_C1 
....................     #define FLASH_CLOCK  PIN_C2 
....................     #define FLASH_DI     PIN_C0 
....................     #define FLASH_DO     PIN_B4 
....................     #define FLASH_BUFFER_SIZE    264     //bytes per page on the flash memory 
....................     #define FLASH_BUFFER_COUNT   4096   //page count 
....................     #include "at45db041.c"   
....................  #endif 
....................  #if STACK_USE_TEMP 
....................     #define DAL_SCL PIN_B6 
....................     #define DAL_SDA PIN_B7 
....................     #include "ds1631.c"   //ds1631 temperature sensor on the d'ment kit 
....................  #endif 
.................... #elif STACK_USE_CCS_EWL3V 
....................  #ifndef FLASH_SELECT 
....................     #define FLASH_SELECT PIN_C2 
....................     #define FLASH_CLOCK  PIN_C3 
....................     #define FLASH_DI     PIN_C5 
....................     #define FLASH_DO     PIN_C4 
....................     #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................     #define FLASH_BUFFER_COUNT   4096   //page count 
....................     #include "at45db041.c" 
....................  #endif 
....................  #if STACK_USE_TEMP 
....................     #define DAL_SCL PIN_B6 
....................     #define DAL_SDA PIN_B7 
....................     #include "ds1631.c"   //ds1631 temperature sensor on the d'ment kit 
....................  #endif 
.................... #endif 
....................  
....................  
....................  
....................  
.................... //if using PPP 
.................... #define EE_ISP_PHONENUMBER 0      //size=64 
.................... #define EE_ISP_USERNAME    64      //size=64 
.................... #define EE_ISP_PASSWORD    128      //size=64 
.................... //if using ETHERNET 
.................... #define EE_NIC_DHCP        192   //size=1 
.................... #define EE_NIC_GATEWAY     193   //size=4 
.................... #define EE_NIC_IP          197   //size=4 
.................... #define EE_NIC_NETMASK     201   //size=4 
.................... #define EE_NIC_MAC         205   //size=6 
.................... #define EE_DNS             211   //size=4 
.................... //if using CCS E-Mail Example 
.................... #define EE_SMTP_PORT       215   //size=2   [TCP Port] 
.................... #define EE_SMTP_HOSTNAME   217   //size=64  [E-mail SMTP server hostname] 
.................... #define EE_SMTP_TO         281   //size=64  [E-mail To address] 
.................... #define EE_SMTP_FROM       345   //size=64  [E-mail From address] 
.................... #define EE_SMTP_SUBJECT    409   //size=64  [E-mail Subject] 
.................... #define EE_SMTP_BODY       473   //size=64  [E-mail Body] 
.................... //if using CCS UDP Example 
.................... #define EE_UDP_DEST_IP     537   //size=4   [destination IP address for UDP example] 
.................... #define EE_UDP_DEST_PORT   541   //size=2   [destination port for UDP example] 
.................... #define EE_UDP_SRC_PORT    543   //size=2    [source port for UDP example] 
....................  
.................... #define EE_MAGIC           545 
.................... #define EE_LAST            546 
.................... #define EE_MAX             0x7FFF 
....................  
.................... #define MPFS_START_POSITION EE_LAST+2 
....................  
.................... //global variables holding PPP information 
.................... //PPP stack requires these to be global 
.................... #if STACK_USE_PPP 
.................... char ppp_phonenumber[64]; 
.................... char ppp_username[64]; 
.................... char ppp_password[64]; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP && STACK_USE_SERIAL 
.................... //Displays modem AT command result to LCD and RS232 serial output 
.................... void display_modem_result(MODEM_RESP err) { 
....................    char str[15]; 
....................    str[0]=0; 
....................  
....................    switch (err) { 
....................       case MODEM_OK:          sprintf(str,"OK");          break; 
....................       case MODEM_CONNECTED:   sprintf(str,"CONNECTED");   break; 
....................       case MODEM_BUSY:        sprintf(str,"BUSY");        break; 
....................       case MODEM_NO_RESPONSE: sprintf(str,"NO RESPONSE"); break; 
....................       case MODEM_NO_CARRIER:  sprintf(str,"NO CARRIER");  break; 
....................       case MODEM_NO_DIALTONE: sprintf(str,"NO DIALTONE"); break; 
....................       default:                sprintf(str,"ERR %U", err); break; 
....................    } 
....................  #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\n                "); 
....................    printf(lcd_putc,"\n%s",str); 
....................    delay_ms(3000); 
....................  #endif 
....................  fprintf(USER,"\r\nMODEM RESP: %s",str); 
.................... } 
.................... #endif 
....................  
.................... //Display's current IP address on the LCD and/or RS232 serial output 
.................... void display_ip_lcd(void) { 
.................... #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\n                    "); 
*
02FA8:  MOVLW  AA
02FAA:  MOVWF  FF6
02FAC:  MOVLW  01
02FAE:  MOVWF  FF7
02FB0:  CALL   0D00
....................        #if STACK_USE_DHCP 
....................         #if STACK_USE_EEPROM 
....................           if (MACIsLinked() && ((DHCPIsBound() && read_ext_eeprom(EE_NIC_DHCP))||(!read_ext_eeprom(EE_NIC_DHCP)))) 
02FB4:  RCALL  2F04
02FB6:  MOVF   01,F
02FB8:  BZ    304C
02FBA:  BTFSS  x86.0
02FBC:  BRA    2FD0
02FBE:  MOVLB  3
02FC0:  CLRF   x93
02FC2:  MOVLW  C0
02FC4:  MOVWF  x92
02FC6:  MOVLB  0
02FC8:  CALL   0C16
02FCC:  MOVF   01,F
02FCE:  BNZ   2FE2
02FD0:  MOVLB  3
02FD2:  CLRF   x93
02FD4:  MOVLW  C0
02FD6:  MOVWF  x92
02FD8:  MOVLB  0
02FDA:  CALL   0C16
02FDE:  MOVF   01,F
02FE0:  BNZ   304C
....................         #else 
....................           if (MACIsLinked() && (DHCPIsBound())) 
....................         #endif 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
02FE2:  MOVLW  0A
02FE4:  MOVLB  3
02FE6:  MOVWF  xA6
02FE8:  MOVLB  0
02FEA:  CALL   0CA4
02FEE:  MOVFF  16,37C
02FF2:  MOVLW  1B
02FF4:  MOVLB  3
02FF6:  MOVWF  x7D
02FF8:  MOVLB  0
02FFA:  RCALL  2F22
02FFC:  MOVLW  2E
02FFE:  MOVLB  3
03000:  MOVWF  xA6
03002:  MOVLB  0
03004:  CALL   0CA4
03008:  MOVFF  17,37C
0300C:  MOVLW  1B
0300E:  MOVLB  3
03010:  MOVWF  x7D
03012:  MOVLB  0
03014:  RCALL  2F22
03016:  MOVLW  2E
03018:  MOVLB  3
0301A:  MOVWF  xA6
0301C:  MOVLB  0
0301E:  CALL   0CA4
03022:  MOVFF  18,37C
03026:  MOVLW  1B
03028:  MOVLB  3
0302A:  MOVWF  x7D
0302C:  MOVLB  0
0302E:  RCALL  2F22
03030:  MOVLW  2E
03032:  MOVLB  3
03034:  MOVWF  xA6
03036:  MOVLB  0
03038:  CALL   0CA4
0303C:  MOVFF  19,37C
03040:  MOVLW  1B
03042:  MOVLB  3
03044:  MOVWF  x7D
03046:  MOVLB  0
03048:  RCALL  2F22
....................           else if (MACIsLinked()) 
0304A:  BRA    306C
0304C:  RCALL  2F04
0304E:  MOVF   01,F
03050:  BZ    3060
....................              printf(lcd_putc,"\nDHCP NOT BOUND"); 
03052:  MOVLW  C0
03054:  MOVWF  FF6
03056:  MOVLW  01
03058:  MOVWF  FF7
0305A:  CALL   0D00
....................           else 
0305E:  BRA    306C
....................             printf(lcd_putc,"\nNO ETHERNET LINK"); 
03060:  MOVLW  D0
03062:  MOVWF  FF6
03064:  MOVLW  01
03066:  MOVWF  FF7
03068:  CALL   0D00
....................  
....................        #elif STACK_USE_PPP 
....................          if (ppp_is_connected()) { 
....................             printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................          } 
....................          else { 
....................             printf(lcd_putc,"\nNOT CONNECTED"); 
....................          } 
....................        #else 
....................         if (MACIsLinked()) { 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................         } 
....................         else { 
....................            printf(lcd_putc,"\nNO ETHERNET LINK"); 
....................         } 
....................        #endif 
.................... #endif 
.................... } 
0306C:  GOTO   A898 (RETURN)
....................  
.................... //a simple routine to make a PPP connection 
.................... #if STACK_USE_PPP 
.................... void picdem_ppp_connect(void) { 
....................    MODEM_RESP ec; 
....................    int8 retries=5; 
....................  
....................    while (!ppp_is_connected() && retries--) { 
....................      #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\nDialing ISP     "); 
....................      #endif 
....................      fprintf(USER,"\r\n\nDialing ISP"); 
....................  
....................       ec=ppp_connect(ppp_username, ppp_password, ppp_phonenumber); 
....................       display_modem_result(ec); 
....................  
....................       if (connected_baudrate) { 
....................         #if STACK_USE_PICDEM_LCD 
....................          printf(lcd_putc,"\fConnect %LUbps    ", connected_baudrate); 
....................          printf(lcd_putc,"\nNegotiating PPP "); 
....................         #endif 
....................          fprintf(USER,"\r\nConnected %LU\r\nNegotiating PPP...", connected_baudrate); 
....................  
....................          while (connected_baudrate && !MY_IP.Val) { 
....................             restart_wdt(); 
....................             ppp_handle();    //keep calling the ppp task until we get assigned an IP address 
....................             //BUG: if it gets stuck, it should hang-up and redial. 
....................             //     (Many ISPs will do this for you though) 
....................          } 
....................          if (MY_IP.Val) { 
....................             display_ip_lcd();     //we got a connection, show the IP address on the LCD screen 
....................             fprintf(USER,"\r\nConnected to ISP, IP Address is %U.%U.%U.%U\r\n",MY_IP.v[0],MY_IP.v[1],MY_IP.v[2],MY_IP.v[3]); 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... #if STACK_USE_EEPROM 
....................  
.................... //null terminated 
.................... void write_ext_eeprom_string(int16 address, char *str) { 
....................    while(*str) { 
....................       write_ext_eeprom(address,*str); 
....................       address++; 
....................       str++; 
....................    } 
....................    write_ext_eeprom(address,0); 
.................... } 
....................  
.................... void write_ext_eeprom16(int16 address, int16 data) 
.................... { 
....................    write_ext_eeprom(address++, make8(data,0)); 
*
00D92:  MOVLB  3
00D94:  MOVFF  380,03
00D98:  MOVF   x7F,W
00D9A:  INCF   x7F,F
00D9C:  BTFSC  FD8.2
00D9E:  INCF   x80,F
00DA0:  MOVWF  x83
00DA2:  MOVFF  03,384
00DA6:  MOVFF  381,385
00DAA:  MOVFF  03,393
00DAE:  MOVWF  x92
00DB0:  MOVFF  381,394
00DB4:  MOVLB  0
00DB6:  RCALL  0D22
....................    write_ext_eeprom(address, make8(data,1)); 
00DB8:  MOVFF  382,383
00DBC:  MOVFF  380,393
00DC0:  MOVFF  37F,392
00DC4:  MOVFF  382,394
00DC8:  RCALL  0D22
.................... } 
00DCA:  RETLW  00
....................  
.................... int16 read_ext_eeprom16(int16 address) 
.................... { 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 val; 
....................    } result; 
....................  
....................    result.b[0]=read_ext_eeprom(address++); 
....................    result.b[1]=read_ext_eeprom(address); 
....................  
....................    return(result.val); 
.................... } 
....................  
.................... void read_ext_eeprom_string(int16 address, char *str, int8 max) { 
....................    char c; 
....................    do { 
....................       c=read_ext_eeprom(address++); 
....................       *str=c; 
....................       str++; 
....................    } while ((c)&&(max--)); 
....................    *str=0; 
.................... } 
....................  
.................... void read_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.v[0]=read_ext_eeprom(address++); 
*
00F10:  MOVLB  3
00F12:  MOVFF  389,03
00F16:  MOVF   x88,W
00F18:  INCF   x88,F
00F1A:  BTFSC  FD8.2
00F1C:  INCF   x89,F
00F1E:  MOVWF  x90
00F20:  MOVFF  03,391
00F24:  MOVFF  03,393
00F28:  MOVWF  x92
00F2A:  MOVLB  0
00F2C:  RCALL  0C16
00F2E:  MOVFF  01,38C
....................    temp.v[1]=read_ext_eeprom(address++); 
00F32:  MOVLB  3
00F34:  MOVFF  389,03
00F38:  MOVF   x88,W
00F3A:  INCF   x88,F
00F3C:  BTFSC  FD8.2
00F3E:  INCF   x89,F
00F40:  MOVWF  x90
00F42:  MOVFF  03,391
00F46:  MOVFF  03,393
00F4A:  MOVWF  x92
00F4C:  MOVLB  0
00F4E:  RCALL  0C16
00F50:  MOVFF  01,38D
....................    temp.v[2]=read_ext_eeprom(address++); 
00F54:  MOVLB  3
00F56:  MOVFF  389,03
00F5A:  MOVF   x88,W
00F5C:  INCF   x88,F
00F5E:  BTFSC  FD8.2
00F60:  INCF   x89,F
00F62:  MOVWF  x90
00F64:  MOVFF  03,391
00F68:  MOVFF  03,393
00F6C:  MOVWF  x92
00F6E:  MOVLB  0
00F70:  RCALL  0C16
00F72:  MOVFF  01,38E
....................    temp.v[3]=read_ext_eeprom(address); 
00F76:  MOVFF  389,393
00F7A:  MOVFF  388,392
00F7E:  RCALL  0C16
00F80:  MOVFF  01,38F
....................    ip->Val=temp.Val; 
00F84:  MOVLB  3
00F86:  MOVFF  38A,FE9
00F8A:  MOVFF  38B,FEA
00F8E:  MOVFF  38C,FEF
00F92:  MOVFF  38D,FEC
00F96:  MOVFF  38E,FEC
00F9A:  MOVFF  38F,FEC
.................... } 
00F9E:  MOVLB  0
00FA0:  RETLW  00
....................  
.................... void write_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.Val=ip->Val; 
*
02BE4:  MOVLB  3
02BE6:  MOVFF  38A,FE9
02BEA:  MOVFF  38B,FEA
02BEE:  MOVFF  FEF,00
02BF2:  MOVFF  FEC,01
02BF6:  MOVFF  FEC,02
02BFA:  MOVFF  FEC,03
02BFE:  MOVFF  03,38F
02C02:  MOVFF  02,38E
02C06:  MOVFF  01,38D
02C0A:  MOVFF  00,38C
....................    write_ext_eeprom(address++,temp.v[0]); 
02C0E:  MOVFF  389,03
02C12:  MOVF   x88,W
02C14:  INCF   x88,F
02C16:  BTFSC  FD8.2
02C18:  INCF   x89,F
02C1A:  MOVWF  x90
02C1C:  MOVFF  03,391
02C20:  MOVFF  03,393
02C24:  MOVWF  x92
02C26:  MOVFF  38C,394
02C2A:  MOVLB  0
02C2C:  CALL   0D22
....................    write_ext_eeprom(address++,temp.v[1]); 
02C30:  MOVLB  3
02C32:  MOVFF  389,03
02C36:  MOVF   x88,W
02C38:  INCF   x88,F
02C3A:  BTFSC  FD8.2
02C3C:  INCF   x89,F
02C3E:  MOVWF  x90
02C40:  MOVFF  03,391
02C44:  MOVFF  03,393
02C48:  MOVWF  x92
02C4A:  MOVFF  38D,394
02C4E:  MOVLB  0
02C50:  CALL   0D22
....................    write_ext_eeprom(address++,temp.v[2]); 
02C54:  MOVLB  3
02C56:  MOVFF  389,03
02C5A:  MOVF   x88,W
02C5C:  INCF   x88,F
02C5E:  BTFSC  FD8.2
02C60:  INCF   x89,F
02C62:  MOVWF  x90
02C64:  MOVFF  03,391
02C68:  MOVFF  03,393
02C6C:  MOVWF  x92
02C6E:  MOVFF  38E,394
02C72:  MOVLB  0
02C74:  CALL   0D22
....................    write_ext_eeprom(address,temp.v[3]); 
02C78:  MOVFF  389,393
02C7C:  MOVFF  388,392
02C80:  MOVFF  38F,394
02C84:  CALL   0D22
.................... } 
02C88:  GOTO   2D46 (RETURN)
....................  
.................... //clears the EEPROM where ISP settings are saved to prevent others from getting your ISP configuration 
.................... void clear_ee(void) { 
....................    int16 i; 
....................   #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\fResetting EEPROM"); 
*
00DCC:  MOVLW  E2
00DCE:  MOVWF  FF6
00DD0:  MOVLW  01
00DD2:  MOVWF  FF7
00DD4:  RCALL  0D00
....................   #endif 
....................   #if STACK_USE_SERIAL 
....................    fprintf(USER,"\r\n\n\nResetting EEPROM..."); 
00DD6:  MOVLW  F4
00DD8:  MOVWF  FF6
00DDA:  MOVLW  01
00DDC:  MOVWF  FF7
00DDE:  RCALL  0D10
....................   #endif 
....................    for (i=0;i<MPFS_RESERVE_BLOCK;i++) { 
00DE0:  MOVLB  3
00DE2:  CLRF   x7E
00DE4:  CLRF   x7D
00DE6:  MOVF   x7E,W
00DE8:  SUBLW  02
00DEA:  BNC   0E0C
00DEC:  BNZ   0DF4
00DEE:  MOVF   x7D,W
00DF0:  SUBLW  27
00DF2:  BNC   0E0C
....................       write_ext_eeprom(i,0); 
00DF4:  MOVFF  37E,393
00DF8:  MOVFF  37D,392
00DFC:  CLRF   x94
00DFE:  MOVLB  0
00E00:  RCALL  0D22
....................    } 
00E02:  MOVLB  3
00E04:  INCF   x7D,F
00E06:  BTFSC  FD8.2
00E08:  INCF   x7E,F
00E0A:  BRA    0DE6
....................    write_ext_eeprom(EE_NIC_DHCP, 1); 
00E0C:  CLRF   x93
00E0E:  MOVLW  C0
00E10:  MOVWF  x92
00E12:  MOVLW  01
00E14:  MOVWF  x94
00E16:  MOVLB  0
00E18:  RCALL  0D22
....................  
....................    write_ext_eeprom(EE_NIC_MAC + 0, 0x00); 
00E1A:  MOVLB  3
00E1C:  CLRF   x93
00E1E:  MOVLW  CD
00E20:  MOVWF  x92
00E22:  CLRF   x94
00E24:  MOVLB  0
00E26:  RCALL  0D22
....................    write_ext_eeprom(EE_NIC_MAC + 1, 0x03); 
00E28:  MOVLB  3
00E2A:  CLRF   x93
00E2C:  MOVLW  CE
00E2E:  MOVWF  x92
00E30:  MOVLW  03
00E32:  MOVWF  x94
00E34:  MOVLB  0
00E36:  RCALL  0D22
....................    write_ext_eeprom(EE_NIC_MAC + 2, 0x04); 
00E38:  MOVLB  3
00E3A:  CLRF   x93
00E3C:  MOVLW  CF
00E3E:  MOVWF  x92
00E40:  MOVLW  04
00E42:  MOVWF  x94
00E44:  MOVLB  0
00E46:  RCALL  0D22
....................    write_ext_eeprom(EE_NIC_MAC + 3, 0x05); 
00E48:  MOVLB  3
00E4A:  CLRF   x93
00E4C:  MOVLW  D0
00E4E:  MOVWF  x92
00E50:  MOVLW  05
00E52:  MOVWF  x94
00E54:  MOVLB  0
00E56:  RCALL  0D22
....................    write_ext_eeprom(EE_NIC_MAC + 4, 0x06); 
00E58:  MOVLB  3
00E5A:  CLRF   x93
00E5C:  MOVLW  D1
00E5E:  MOVWF  x92
00E60:  MOVLW  06
00E62:  MOVWF  x94
00E64:  MOVLB  0
00E66:  RCALL  0D22
....................    write_ext_eeprom(EE_NIC_MAC + 5, 0x07); 
00E68:  MOVLB  3
00E6A:  CLRF   x93
00E6C:  MOVLW  D2
00E6E:  MOVWF  x92
00E70:  MOVLW  07
00E72:  MOVWF  x94
00E74:  MOVLB  0
00E76:  RCALL  0D22
....................  
....................    write_ext_eeprom16(EE_SMTP_PORT, 25); 
00E78:  MOVLB  3
00E7A:  CLRF   x80
00E7C:  MOVLW  D7
00E7E:  MOVWF  x7F
00E80:  CLRF   x82
00E82:  MOVLW  19
00E84:  MOVWF  x81
00E86:  MOVLB  0
00E88:  RCALL  0D92
....................  
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, 5000); 
00E8A:  MOVLW  02
00E8C:  MOVLB  3
00E8E:  MOVWF  x80
00E90:  MOVLW  1D
00E92:  MOVWF  x7F
00E94:  MOVLW  13
00E96:  MOVWF  x82
00E98:  MOVLW  88
00E9A:  MOVWF  x81
00E9C:  MOVLB  0
00E9E:  RCALL  0D92
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, 5000); 
00EA0:  MOVLW  02
00EA2:  MOVLB  3
00EA4:  MOVWF  x80
00EA6:  MOVLW  1F
00EA8:  MOVWF  x7F
00EAA:  MOVLW  13
00EAC:  MOVWF  x82
00EAE:  MOVLW  88
00EB0:  MOVWF  x81
00EB2:  MOVLB  0
00EB4:  RCALL  0D92
....................  
....................    write_ext_eeprom(EE_MAGIC, 0x55); 
00EB6:  MOVLW  02
00EB8:  MOVLB  3
00EBA:  MOVWF  x93
00EBC:  MOVLW  21
00EBE:  MOVWF  x92
00EC0:  MOVLW  55
00EC2:  MOVWF  x94
00EC4:  MOVLB  0
00EC6:  RCALL  0D22
....................  
....................   #if STACK_USE_SERIAL 
....................    fprintf(USER,"\r\nEEPROM Cleared. Resetting.\r\n"); 
00EC8:  MOVLW  0C
00ECA:  MOVWF  FF6
00ECC:  MOVLW  02
00ECE:  MOVWF  FF7
00ED0:  RCALL  0D10
....................   #endif 
....................  
....................   #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\fEEPROM Cleared"); 
00ED2:  MOVLW  2C
00ED4:  MOVWF  FF6
00ED6:  MOVLW  02
00ED8:  MOVWF  FF7
00EDA:  RCALL  0D00
....................    delay_ms(5000); 
00EDC:  MOVLW  14
00EDE:  MOVLB  3
00EE0:  MOVWF  x7F
00EE2:  MOVLW  FA
00EE4:  MOVWF  xA7
00EE6:  MOVLB  0
00EE8:  RCALL  0A04
00EEA:  MOVLB  3
00EEC:  DECFSZ x7F,F
00EEE:  BRA    0EE2
....................   #endif 
....................  
....................    reset_cpu(); 
00EF0:  RESET
.................... } 
00EF2:  MOVLB  0
00EF4:  RETLW  00
....................  
.................... void init_eeprom_defaults(void) 
.................... { 
....................    if (read_ext_eeprom(EE_MAGIC) != 0x55) 
00EF6:  MOVLW  02
00EF8:  MOVLB  3
00EFA:  MOVWF  x93
00EFC:  MOVLW  21
00EFE:  MOVWF  x92
00F00:  MOVLB  0
00F02:  RCALL  0C16
00F04:  MOVF   01,W
00F06:  SUBLW  55
00F08:  BZ    0F0C
....................       clear_ee(); 
00F0A:  RCALL  0DCC
.................... } 
00F0C:  GOTO   1A08 (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... int16 SMTP_PORT; 
.................... char SMTP_HOST_NAME[64]; 
.................... char SMTP_TO_ADDR[64];     //To address of your e-mail 
.................... char SMTP_FROM_ADDR[64];       //From address of your e-mail 
.................... char SMTP_SUBJECT[64];                 //Subject of your e-mail 
.................... char SMTP_BODY[64];      //Body of your e-mail 
....................  
.................... void init_smtp_settings(void) { 
....................  read_ext_eeprom_string(EE_SMTP_HOSTNAME,SMTP_HOST_NAME,64); 
....................  SMTP_PORT=read_ext_eeprom16(EE_SMTP_PORT); 
....................  read_ext_eeprom_string(EE_SMTP_TO,SMTP_TO_ADDR,64); 
....................  read_ext_eeprom_string(EE_SMTP_FROM,SMTP_FROM_ADDR,64); 
....................  read_ext_eeprom_string(EE_SMTP_SUBJECT,SMTP_SUBJECT,64); 
....................  read_ext_eeprom_string(EE_SMTP_BODY,SMTP_BODY,64); 
.................... } 
.................... #endif 
....................  
.................... //Initializes hardware, stack, default IP address and MAC address. 
.................... void init(void) { 
....................    setup_wdt(WDT_OFF); 
*
0199A:  BCF    FD1.0
....................    set_tris_a(0xFF); 
0199C:  MOVLW  FF
0199E:  MOVWF  F92
....................    set_tris_b(0xFF); 
019A0:  MOVWF  F93
....................    set_tris_c(0xFF); 
019A2:  MOVWF  F94
.................... #if !STACK_USE_CCS_EWL5V 
....................    set_tris_d(0xFF); 
019A4:  MOVWF  F95
....................    set_tris_e(0xFF); 
019A6:  BSF    F96.0
019A8:  BSF    F96.1
019AA:  BSF    F96.2
....................  #if STACK_USE_CCS_PICNET 
....................    set_tris_f(0xFF); 
....................  #endif 
.................... #endif 
....................  
....................    #if !STACK_USE_CCS_EWL5V 
....................    setup_comparator(NC_NC_NC_NC); 
019AC:  MOVLW  07
019AE:  MOVWF  FB4
019B0:  MOVF   F92,W
019B2:  MOVWF  F92
019B4:  MOVLW  21
019B6:  MOVWF  00
019B8:  DECFSZ 00,F
019BA:  BRA    19B8
019BC:  MOVF   FB4,W
019BE:  BCF    FA1.6
....................    #endif 
....................  
....................    setup_adc_ports(ANALOG_PORT_CONFIG); 
019C0:  MOVF   FC1,W
019C2:  ANDLW  C0
019C4:  IORLW  0E
019C6:  MOVWF  FC1
....................   
....................    setup_adc(ADC_CLOCK_INTERNAL); 
019C8:  MOVF   FC0,W
019CA:  ANDLW  C0
019CC:  IORLW  07
019CE:  MOVWF  FC0
019D0:  BCF    FC0.7
019D2:  BSF    FC2.0
....................  #if STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V 
....................    bit_clear(*0xFC2,7); //temporary fix to a CCS bug 
....................  #endif 
....................   
....................  #if defined(ADC_CHAN_0) 
....................    set_adc_channel(ADC_CHAN_0); 
019D4:  MOVLW  00
019D6:  MOVWF  01
019D8:  MOVF   FC2,W
019DA:  ANDLW  C3
019DC:  IORWF  01,W
019DE:  MOVWF  FC2
....................  #endif 
....................  
....................    OUTPUT_DRIVE_MACRO(PIN_C6); 
019E0:  BCF    F94.6
....................    //OUTPUT_FLOAT_MACRO(PIN_C7); 
....................  
....................  #if defined(USER_LED1) 
....................    OUTPUT_DRIVE_MACRO(USER_LED1); 
019E2:  BCF    F92.5
....................    output_high(USER_LED1); 
019E4:  BSF    F89.5
....................  #endif 
....................  
....................  #if defined(USER_LED2) 
....................    OUTPUT_DRIVE_MACRO(USER_LED2); 
019E6:  BCF    F93.4
....................    output_high(USER_LED2); 
019E8:  BSF    F8A.4
....................  #endif 
....................  
....................   #if defined(USER_LED3) 
....................    OUTPUT_DRIVE_MACRO(USER_LED3); 
019EA:  BCF    F93.5
....................    output_high(USER_LED3); 
019EC:  BSF    F8A.5
....................   #endif 
....................  
....................   #if defined(USER_BUTTON1) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON1); 
019EE:  BSF    F92.4
....................   #endif 
....................  
....................   #if defined(USER_BUTTON2) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON2); 
....................   #endif 
....................  
....................  #if defined(EEPROM_SELECT) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_SELECT); 
019F0:  BCF    F93.3
....................  #endif 
....................  
....................  #if defined(EEPROM_DI) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_DI); 
019F2:  BCF    F94.5
....................  #endif 
....................  
....................  #if defined(EEPROM_DO) 
....................   OUTPUT_FLOAT_MACRO(EEPROM_DO); 
019F4:  BSF    F94.4
....................  #endif 
....................  
....................  #if defined(EEPROM_CLK) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_CLK); 
019F6:  BCF    F94.3
....................  #endif 
....................  
....................  #if defined(MMC_SELECT) 
....................   OUTPUT_DRIVE_MACRO(MMC_SELECT); 
....................  #endif 
....................   
....................  #if defined(FLASH_SELECT) 
....................   OUTPUT_DRIVE_MACRO(FLASH_SELECT); 
....................  #endif 
....................   
....................  #if defined(FLASH_CLOCK) 
....................   OUTPUT_DRIVE_MACRO(FLASH_CLOCK); 
....................  #endif 
....................   
....................  #if defined(FLASH_DI) 
....................   OUTPUT_DRIVE_MACRO(FLASH_DI); 
....................  #endif 
....................   
....................  #if defined(FLASH_DO) 
....................   OUTPUT_FLOAT_MACRO(FLASH_DO); 
....................  #endif 
....................   
....................  #if defined(DAL_SCL) 
....................   OUTPUT_DRIVE_MACRO(DAL_SCL); 
....................   output_high(DAL_SCL); 
....................  #endif 
....................   
....................  #if defined(DAL_SDA) 
....................   OUTPUT_DRIVE_MACRO(DAL_SDA); 
....................   output_high(DAL_SCL); 
....................  #endif 
....................   
....................  #if defined(DIGITAL1) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL1); 
....................  #endif 
....................  #if defined(DIGITAL2) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL2); 
....................  #endif 
....................  #if defined(DIGITAL3) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL3); 
....................  #endif 
....................  #if defined(DIGITAL4) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL4); 
....................  #endif 
....................  #if defined(DIGITAL5) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL5); 
....................  #endif 
....................  #if defined(DIGITAL6) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL6); 
....................  #endif 
....................  #if defined(DIGITAL7) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL7); 
....................  #endif 
....................  #if defined(DIGITAL8) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL8); 
....................  #endif 
....................  #if defined(DIGITAL9) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL9); 
....................  #endif 
....................  #if defined(DIGITAL10) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL10); 
....................  #endif 
....................  #if defined(DIGITAL11) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL11); 
....................  #endif 
....................  #if defined(DIGITAL12) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL12); 
....................  #endif 
....................  #if defined(DIGITAL13) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL13); 
....................  #endif 
....................  #if defined(DIGITAL14) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL14); 
....................  #endif 
....................  #if defined(DIGITAL15) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL15); 
....................  #endif 
....................  #if defined(DIGITAL16) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL16); 
....................  #endif 
....................  #if defined(DIGITAL17) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL17); 
....................  #endif 
....................   
.................... #if STACK_USE_PICDEM_LCD 
....................    lcd_init(); 
019F8:  GOTO   0B06
.................... #endif 
....................  
.................... #if STACK_USE_TEMP 
....................    init_temp(); 
.................... #endif 
....................   #if STACK_USE_MCPENC 
....................    //Normally StackInit() will call this, but since we are sharing the same 
....................    //SPI pins for the ENC and EEPROM, we need to call it now so we can use 
....................    //the EEPROM before we do a StackInit(). 
....................    ENCSPIInit(); 
019FC:  CALL   0B8C
....................   #endif 
....................    
....................  #if STACK_USE_EEPROM 
....................    init_ext_eeprom(); 
01A00:  GOTO   0BB0
....................    init_eeprom_defaults(); 
01A04:  GOTO   0EF6
....................    // 
....................    // Load default configuration into RAM. 
....................    // 
....................  
....................  #if STACK_USE_PPP 
....................  read_ext_eeprom_string(EE_ISP_PHONENUMBER,ppp_phonenumber,64); 
....................  read_ext_eeprom_string(EE_ISP_USERNAME,ppp_username,64); 
....................  read_ext_eeprom_string(EE_ISP_PASSWORD,ppp_password,64); 
....................  #elif STACK_USE_MAC 
....................    read_ext_eeprom_ip(EE_NIC_IP, &AppConfig.MyIPAddr); 
01A08:  MOVLB  3
01A0A:  CLRF   x89
01A0C:  MOVLW  C5
01A0E:  MOVWF  x88
01A10:  CLRF   x8B
01A12:  MOVLW  16
01A14:  MOVWF  x8A
01A16:  MOVLB  0
01A18:  CALL   0F10
....................    read_ext_eeprom_ip(EE_NIC_NETMASK, &AppConfig.MyMask); 
01A1C:  MOVLB  3
01A1E:  CLRF   x89
01A20:  MOVLW  C9
01A22:  MOVWF  x88
01A24:  CLRF   x8B
01A26:  MOVLW  20
01A28:  MOVWF  x8A
01A2A:  MOVLB  0
01A2C:  CALL   0F10
....................    read_ext_eeprom_ip(EE_NIC_GATEWAY, &AppConfig.MyGateway); 
01A30:  MOVLB  3
01A32:  CLRF   x89
01A34:  MOVLW  C1
01A36:  MOVWF  x88
01A38:  CLRF   x8B
01A3A:  MOVLW  24
01A3C:  MOVWF  x8A
01A3E:  MOVLB  0
01A40:  CALL   0F10
....................   #if STACK_USE_DNS 
....................    read_ext_eeprom_ip(EE_DNS, &AppConfig.PrimaryDNSServer); 
....................   #endif 
....................  
....................    AppConfig.MyMACAddr.v[0]    = read_ext_eeprom(EE_NIC_MAC + 0); 
01A44:  MOVLB  3
01A46:  CLRF   x93
01A48:  MOVLW  CD
01A4A:  MOVWF  x92
01A4C:  MOVLB  0
01A4E:  CALL   0C16
01A52:  MOVFF  01,1A
....................    AppConfig.MyMACAddr.v[1]    = read_ext_eeprom(EE_NIC_MAC + 1); 
01A56:  MOVLB  3
01A58:  CLRF   x93
01A5A:  MOVLW  CE
01A5C:  MOVWF  x92
01A5E:  MOVLB  0
01A60:  CALL   0C16
01A64:  MOVFF  01,1B
....................    AppConfig.MyMACAddr.v[2]    = read_ext_eeprom(EE_NIC_MAC + 2); 
01A68:  MOVLB  3
01A6A:  CLRF   x93
01A6C:  MOVLW  CF
01A6E:  MOVWF  x92
01A70:  MOVLB  0
01A72:  CALL   0C16
01A76:  MOVFF  01,1C
....................    AppConfig.MyMACAddr.v[3]    = read_ext_eeprom(EE_NIC_MAC + 3); 
01A7A:  MOVLB  3
01A7C:  CLRF   x93
01A7E:  MOVLW  D0
01A80:  MOVWF  x92
01A82:  MOVLB  0
01A84:  CALL   0C16
01A88:  MOVFF  01,1D
....................    AppConfig.MyMACAddr.v[4]    = read_ext_eeprom(EE_NIC_MAC + 4); 
01A8C:  MOVLB  3
01A8E:  CLRF   x93
01A90:  MOVLW  D1
01A92:  MOVWF  x92
01A94:  MOVLB  0
01A96:  CALL   0C16
01A9A:  MOVFF  01,1E
....................    AppConfig.MyMACAddr.v[5]    = read_ext_eeprom(EE_NIC_MAC + 5); 
01A9E:  MOVLB  3
01AA0:  CLRF   x93
01AA2:  MOVLW  D2
01AA4:  MOVWF  x92
01AA6:  MOVLB  0
01AA8:  CALL   0C16
01AAC:  MOVFF  01,1F
....................  
....................    #if STACK_USE_DHCP 
....................    if (!read_ext_eeprom(EE_NIC_DHCP)) 
01AB0:  MOVLB  3
01AB2:  CLRF   x93
01AB4:  MOVLW  C0
01AB6:  MOVWF  x92
01AB8:  MOVLB  0
01ABA:  CALL   0C16
01ABE:  MOVF   01,F
01AC0:  BNZ   1AC6
....................       DHCPDisable(); 
01AC2:  MOVLW  08
01AC4:  MOVWF  x85
....................    #endif 
....................  #endif 
.................... #else //no eeprom 
....................    AppConfig.MyMACAddr.v[0] = 2; 
....................    AppConfig.MyMACAddr.v[1] = 2; 
....................    AppConfig.MyMACAddr.v[2] = 2; 
....................    AppConfig.MyMACAddr.v[3] = 2; 
....................    AppConfig.MyMACAddr.v[4] = 2; 
....................    AppConfig.MyMACAddr.v[5] = 2; 
.................... #endif 
....................  
....................  #if STACK_USE_ANNOUNCE 
....................   #if STACK_USE_CCS_PICNET 
....................    InitAnnounce("PICNET"); 
....................   #elif STACK_USE_CCS_PICENS 
....................    InitAnnounce("PICENS"); 
01AC6:  MOVLW  3C
01AC8:  MOVWF  FF6
01ACA:  MOVLW  02
01ACC:  MOVWF  FF7
01ACE:  CALL   0FE2
....................   #elif STACK_USE_CCS_PICEEC 
....................    InitAnnounce("PICEEC"); 
....................   #elif STACK_USE_CCS_EWL 
....................    InitAnnounce("EZ WEB LYNX"); 
....................   #endif 
....................  #endif 
....................  
....................  #if STACK_USE_MPFS 
....................    MPFSInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    fat_init(); 
.................... #endif 
....................   
....................    StackInit(); 
01AD2:  BRA    197E
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................    init_smtp_settings(); 
.................... #endif 
.................... } 
01AD4:  GOTO   A880 (RETURN)
....................  
.................... int1 set_port_bit(int8 *ptr, int16 fullPin, int1 new) 
.................... { 
....................    int port, pin; 
....................    int1 old; 
....................  
....................    fullPin -=  (int16)PIN_A0; 
*
01E10:  MOVLW  00
01E12:  MOVLB  3
01E14:  SUBWF  x90,F
01E16:  MOVLW  7C
01E18:  SUBWFB x91,F
....................    port = fullPin / 8; 
01E1A:  RRCF   x91,W
01E1C:  MOVWF  03
01E1E:  RRCF   x90,W
01E20:  MOVWF  02
01E22:  RRCF   03,F
01E24:  RRCF   02,F
01E26:  RRCF   03,F
01E28:  RRCF   02,F
01E2A:  MOVFF  02,393
....................    pin = fullPin % 8; 
01E2E:  MOVF   x90,W
01E30:  ANDLW  07
01E32:  MOVWF  x94
....................  
....................    ptr += port; 
01E34:  MOVF   x93,W
01E36:  ADDWF  x8E,F
01E38:  MOVLW  00
01E3A:  ADDWFC x8F,F
....................  
....................    port = *ptr; 
01E3C:  MOVFF  38E,FE9
01E40:  MOVFF  38F,FEA
01E44:  MOVFF  FEF,393
....................    old = bit_test(port, pin); 
01E48:  MOVFF  393,00
01E4C:  MOVF   x94,W
01E4E:  MOVWF  01
01E50:  BZ    1E5A
01E52:  BCF    FD8.0
01E54:  RRCF   00,F
01E56:  DECFSZ 01,F
01E58:  BRA    1E52
01E5A:  BCF    x95.0
01E5C:  BTFSC  00.0
01E5E:  BSF    x95.0
....................    if (new) 
01E60:  MOVF   x92,F
01E62:  BZ    1E7C
....................       bit_set(port, pin); 
01E64:  MOVLW  01
01E66:  MOVWF  00
01E68:  MOVF   x94,W
01E6A:  MOVWF  01
01E6C:  BZ    1E76
01E6E:  BCF    FD8.0
01E70:  RLCF   00,F
01E72:  DECFSZ 01,F
01E74:  BRA    1E6E
01E76:  MOVF   00,W
01E78:  IORWF  x93,F
....................    else 
01E7A:  BRA    1E94
....................       bit_clear(port, pin); 
01E7C:  MOVLW  01
01E7E:  MOVWF  00
01E80:  MOVF   x94,W
01E82:  MOVWF  01
01E84:  BZ    1E8E
01E86:  BCF    FD8.0
01E88:  RLCF   00,F
01E8A:  DECFSZ 01,F
01E8C:  BRA    1E86
01E8E:  MOVF   00,W
01E90:  XORLW  FF
01E92:  ANDWF  x93,F
....................  
....................    *ptr = port; 
01E94:  MOVFF  38E,FE9
01E98:  MOVFF  38F,FEA
01E9C:  MOVFF  393,FEF
....................  
....................    return(old); 
01EA0:  MOVLW  00
01EA2:  BTFSC  x95.0
01EA4:  MOVLW  01
01EA6:  MOVWF  01
.................... } 
01EA8:  MOVLB  0
01EAA:  RETLW  00
....................  
.................... int1 get_port_bit(int8 *ptr, int16 fullPin) 
.................... { 
....................    int port, pin; 
....................  
....................    fullPin -=  (int16)PIN_A0; 
*
01ED0:  MOVLW  00
01ED2:  MOVLB  3
01ED4:  SUBWF  x8F,F
01ED6:  MOVLW  7C
01ED8:  SUBWFB x90,F
....................    port = fullPin / 8; 
01EDA:  RRCF   x90,W
01EDC:  MOVWF  03
01EDE:  RRCF   x8F,W
01EE0:  MOVWF  02
01EE2:  RRCF   03,F
01EE4:  RRCF   02,F
01EE6:  RRCF   03,F
01EE8:  RRCF   02,F
01EEA:  MOVFF  02,391
....................    pin = fullPin % 8; 
01EEE:  MOVF   x8F,W
01EF0:  ANDLW  07
01EF2:  MOVWF  x92
....................  
....................    ptr += port; 
01EF4:  MOVF   x91,W
01EF6:  ADDWF  x8D,F
01EF8:  MOVLW  00
01EFA:  ADDWFC x8E,F
....................  
....................    port = *ptr; 
01EFC:  MOVFF  38D,FE9
01F00:  MOVFF  38E,FEA
01F04:  MOVFF  FEF,391
....................  
....................    return(bit_test(port, pin)); 
01F08:  MOVFF  391,00
01F0C:  MOVF   x92,W
01F0E:  MOVWF  01
01F10:  BZ    1F1A
01F12:  BCF    FD8.0
01F14:  RRCF   00,F
01F16:  DECFSZ 01,F
01F18:  BRA    1F12
01F1A:  MOVLW  00
01F1C:  BTFSC  00.0
01F1E:  MOVLW  01
01F20:  MOVWF  01
.................... } 
01F22:  MOVLB  0
01F24:  RETLW  00
....................  
.................... #if defined(__PCH__) 
....................  #define set_tris_variable(fullPin, new) set_port_bit(0xF92, fullPin, new) 
....................  #define set_lat_variable(fullPin, new) set_port_bit(0xF89, fullPin, new) 
....................  #define input_variable(fullPin) get_port_bit(0xF80, fullPin) 
.................... #else 
....................  #define set_tris_variable(fullPin, new) set_port_bit(0x85, fullPin, new) 
....................  #define set_lat_variable(fullPin, new) set_port_bit(0x05, fullPin, new) 
....................  #define input_variable(fullPin) get_port_bit(0x05, fullPin) 
.................... #endif 
....................  
.................... #define output_float_variable(x) set_tris_variable(x,1) 
.................... #define output_drive_variable(x) set_tris_variable(x,0) 
....................  
.................... #define output_low_variable(x) set_lat_variable(x,0) 
.................... #define output_high_variable(x) set_lat_variable(x,1) 
....................  
.................... void get_pin_string(int16 fullPin, char *str) 
.................... { 
....................    int port,pin; 
....................    fullPin -=  (int16)PIN_A0; 
*
01F56:  MOVLW  00
01F58:  MOVLB  3
01F5A:  SUBWF  x8D,F
01F5C:  MOVLW  7C
01F5E:  SUBWFB x8E,F
....................    port = fullPin / 8; 
01F60:  RRCF   x8E,W
01F62:  MOVWF  03
01F64:  RRCF   x8D,W
01F66:  MOVWF  02
01F68:  RRCF   03,F
01F6A:  RRCF   02,F
01F6C:  RRCF   03,F
01F6E:  RRCF   02,F
01F70:  MOVFF  02,391
....................    pin = fullPin % 8; 
01F74:  MOVF   x8D,W
01F76:  ANDLW  07
01F78:  MOVWF  x92
....................    sprintf(str, "PIN_"); 
01F7A:  MOVFF  390,330
01F7E:  MOVFF  38F,32F
01F82:  MOVLW  44
01F84:  MOVWF  FF6
01F86:  MOVLW  02
01F88:  MOVWF  FF7
01F8A:  MOVLB  0
01F8C:  RCALL  1F46
....................    port += 'A'; 
01F8E:  MOVLW  41
01F90:  MOVLB  3
01F92:  ADDWF  x91,F
....................    pin += '0'; 
01F94:  MOVLW  30
01F96:  ADDWF  x92,F
....................    str[4]=port; 
01F98:  MOVLW  04
01F9A:  ADDWF  x8F,W
01F9C:  MOVWF  FE9
01F9E:  MOVLW  00
01FA0:  ADDWFC x90,W
01FA2:  MOVWF  FEA
01FA4:  MOVFF  391,FEF
....................    str[5]=pin; 
01FA8:  MOVLW  05
01FAA:  ADDWF  x8F,W
01FAC:  MOVWF  FE9
01FAE:  MOVLW  00
01FB0:  ADDWFC x90,W
01FB2:  MOVWF  FEA
01FB4:  MOVFF  392,FEF
....................    str[6]=0; 
01FB8:  MOVLW  06
01FBA:  ADDWF  x8F,W
01FBC:  MOVWF  FE9
01FBE:  MOVLW  00
01FC0:  ADDWFC x90,W
01FC2:  MOVWF  FEA
01FC4:  CLRF   FEF
.................... } 
01FC6:  MOVLB  0
01FC8:  RETLW  00
....................  
.................... int1 hardware_io_test_pin(int16 pin1, int16 pin2) 
.................... { 
....................    int fail=0; 
*
01FE0:  MOVLB  3
01FE2:  CLRF   x83
....................    char str[8]; 
....................    int1 oldTRIS1, oldTRIS2, oldLAT1, oldLAT2; 
....................    oldLAT1=output_low_variable(pin1); 
01FE4:  MOVLW  0F
01FE6:  MOVWF  x8F
01FE8:  MOVLW  89
01FEA:  MOVWF  x8E
01FEC:  MOVFF  380,391
01FF0:  MOVFF  37F,390
01FF4:  CLRF   x92
01FF6:  MOVLB  0
01FF8:  RCALL  1E10
01FFA:  MOVLB  3
01FFC:  BCF    x8C.2
01FFE:  BTFSC  01.0
02000:  BSF    x8C.2
....................    oldLAT2=output_low_variable(pin2); 
02002:  MOVLW  0F
02004:  MOVWF  x8F
02006:  MOVLW  89
02008:  MOVWF  x8E
0200A:  MOVFF  382,391
0200E:  MOVFF  381,390
02012:  CLRF   x92
02014:  MOVLB  0
02016:  RCALL  1E10
02018:  MOVLB  3
0201A:  BCF    x8C.3
0201C:  BTFSC  01.0
0201E:  BSF    x8C.3
....................    oldTRIS1=output_drive_variable(pin1); 
02020:  MOVLW  0F
02022:  MOVWF  x8F
02024:  MOVLW  92
02026:  MOVWF  x8E
02028:  MOVFF  380,391
0202C:  MOVFF  37F,390
02030:  CLRF   x92
02032:  MOVLB  0
02034:  RCALL  1E10
02036:  MOVLB  3
02038:  BCF    x8C.0
0203A:  BTFSC  01.0
0203C:  BSF    x8C.0
....................    oldTRIS2=output_float_variable(pin2); 
0203E:  MOVLW  0F
02040:  MOVWF  x8F
02042:  MOVLW  92
02044:  MOVWF  x8E
02046:  MOVFF  382,391
0204A:  MOVFF  381,390
0204E:  MOVLW  01
02050:  MOVWF  x92
02052:  MOVLB  0
02054:  RCALL  1E10
02056:  MOVLB  3
02058:  BCF    x8C.1
0205A:  BTFSC  01.0
0205C:  BSF    x8C.1
....................    delay_us(100); 
0205E:  MOVLW  64
02060:  MOVWF  xBD
02062:  MOVLB  0
02064:  RCALL  1EAC
....................    if (input_variable(pin2)) 
02066:  MOVLW  0F
02068:  MOVLB  3
0206A:  MOVWF  x8E
0206C:  MOVLW  80
0206E:  MOVWF  x8D
02070:  MOVFF  382,390
02074:  MOVFF  381,38F
02078:  MOVLB  0
0207A:  RCALL  1ED0
0207C:  MOVF   01,F
0207E:  BZ    2084
....................       fail |= 1; 
02080:  MOVLB  3
02082:  BSF    x83.0
....................  
....................    output_high_variable(pin1); 
02084:  MOVLW  0F
02086:  MOVLB  3
02088:  MOVWF  x8F
0208A:  MOVLW  89
0208C:  MOVWF  x8E
0208E:  MOVFF  380,391
02092:  MOVFF  37F,390
02096:  MOVLW  01
02098:  MOVWF  x92
0209A:  MOVLB  0
0209C:  RCALL  1E10
....................    delay_us(100); 
0209E:  MOVLW  64
020A0:  MOVLB  3
020A2:  MOVWF  xBD
020A4:  MOVLB  0
020A6:  RCALL  1EAC
....................    if (!input_variable(pin2)) 
020A8:  MOVLW  0F
020AA:  MOVLB  3
020AC:  MOVWF  x8E
020AE:  MOVLW  80
020B0:  MOVWF  x8D
020B2:  MOVFF  382,390
020B6:  MOVFF  381,38F
020BA:  MOVLB  0
020BC:  RCALL  1ED0
020BE:  MOVF   01,F
020C0:  BNZ   20C6
....................       fail |= 2; 
020C2:  MOVLB  3
020C4:  BSF    x83.1
....................  
....................    output_low_variable(pin2); 
020C6:  MOVLW  0F
020C8:  MOVLB  3
020CA:  MOVWF  x8F
020CC:  MOVLW  89
020CE:  MOVWF  x8E
020D0:  MOVFF  382,391
020D4:  MOVFF  381,390
020D8:  CLRF   x92
020DA:  MOVLB  0
020DC:  RCALL  1E10
....................    output_float_variable(pin1); 
020DE:  MOVLW  0F
020E0:  MOVLB  3
020E2:  MOVWF  x8F
020E4:  MOVLW  92
020E6:  MOVWF  x8E
020E8:  MOVFF  380,391
020EC:  MOVFF  37F,390
020F0:  MOVLW  01
020F2:  MOVWF  x92
020F4:  MOVLB  0
020F6:  RCALL  1E10
....................    output_drive_variable(pin2); 
020F8:  MOVLW  0F
020FA:  MOVLB  3
020FC:  MOVWF  x8F
020FE:  MOVLW  92
02100:  MOVWF  x8E
02102:  MOVFF  382,391
02106:  MOVFF  381,390
0210A:  CLRF   x92
0210C:  MOVLB  0
0210E:  RCALL  1E10
....................    delay_us(100); 
02110:  MOVLW  64
02112:  MOVLB  3
02114:  MOVWF  xBD
02116:  MOVLB  0
02118:  RCALL  1EAC
....................    if (input_variable(pin1)) 
0211A:  MOVLW  0F
0211C:  MOVLB  3
0211E:  MOVWF  x8E
02120:  MOVLW  80
02122:  MOVWF  x8D
02124:  MOVFF  380,390
02128:  MOVFF  37F,38F
0212C:  MOVLB  0
0212E:  RCALL  1ED0
02130:  MOVF   01,F
02132:  BZ    2138
....................       fail |= 4; 
02134:  MOVLB  3
02136:  BSF    x83.2
....................  
....................    output_high_variable(pin2); 
02138:  MOVLW  0F
0213A:  MOVLB  3
0213C:  MOVWF  x8F
0213E:  MOVLW  89
02140:  MOVWF  x8E
02142:  MOVFF  382,391
02146:  MOVFF  381,390
0214A:  MOVLW  01
0214C:  MOVWF  x92
0214E:  MOVLB  0
02150:  RCALL  1E10
....................    delay_us(100); 
02152:  MOVLW  64
02154:  MOVLB  3
02156:  MOVWF  xBD
02158:  MOVLB  0
0215A:  RCALL  1EAC
....................    if (!input_variable(pin1)) 
0215C:  MOVLW  0F
0215E:  MOVLB  3
02160:  MOVWF  x8E
02162:  MOVLW  80
02164:  MOVWF  x8D
02166:  MOVFF  380,390
0216A:  MOVFF  37F,38F
0216E:  MOVLB  0
02170:  RCALL  1ED0
02172:  MOVF   01,F
02174:  BNZ   217A
....................       fail |= 8; 
02176:  MOVLB  3
02178:  BSF    x83.3
....................  
....................    set_lat_variable(pin1, oldLAT1); 
0217A:  MOVLW  00
0217C:  MOVLB  3
0217E:  BTFSC  x8C.2
02180:  MOVLW  01
02182:  MOVWF  x8D
02184:  MOVLW  0F
02186:  MOVWF  x8F
02188:  MOVLW  89
0218A:  MOVWF  x8E
0218C:  MOVFF  380,391
02190:  MOVFF  37F,390
02194:  MOVFF  38D,392
02198:  MOVLB  0
0219A:  RCALL  1E10
....................    set_lat_variable(pin2, oldLAT2); 
0219C:  MOVLW  00
0219E:  MOVLB  3
021A0:  BTFSC  x8C.3
021A2:  MOVLW  01
021A4:  MOVWF  x8D
021A6:  MOVLW  0F
021A8:  MOVWF  x8F
021AA:  MOVLW  89
021AC:  MOVWF  x8E
021AE:  MOVFF  382,391
021B2:  MOVFF  381,390
021B6:  MOVFF  38D,392
021BA:  MOVLB  0
021BC:  RCALL  1E10
....................    set_tris_variable(pin1, oldTRIS1); 
021BE:  MOVLW  00
021C0:  MOVLB  3
021C2:  BTFSC  x8C.0
021C4:  MOVLW  01
021C6:  MOVWF  x8D
021C8:  MOVLW  0F
021CA:  MOVWF  x8F
021CC:  MOVLW  92
021CE:  MOVWF  x8E
021D0:  MOVFF  380,391
021D4:  MOVFF  37F,390
021D8:  MOVFF  38D,392
021DC:  MOVLB  0
021DE:  RCALL  1E10
....................    set_tris_variable(pin2, oldTRIS2); 
021E0:  MOVLW  00
021E2:  MOVLB  3
021E4:  BTFSC  x8C.1
021E6:  MOVLW  01
021E8:  MOVWF  x8D
021EA:  MOVLW  0F
021EC:  MOVWF  x8F
021EE:  MOVLW  92
021F0:  MOVWF  x8E
021F2:  MOVFF  382,391
021F6:  MOVFF  381,390
021FA:  MOVFF  38D,392
021FE:  MOVLB  0
02200:  RCALL  1E10
....................  
....................  #if STACK_USE_SERIAL 
....................    if (fail) 
02202:  MOVLB  3
02204:  MOVF   x83,F
02206:  BZ    22B4
....................    { 
....................       get_pin_string(pin1, str); 
02208:  MOVFF  380,38E
0220C:  MOVFF  37F,38D
02210:  MOVLW  03
02212:  MOVWF  x90
02214:  MOVLW  84
02216:  MOVWF  x8F
02218:  MOVLB  0
0221A:  RCALL  1F56
....................       fprintf(USER,"%s <-> ", str); 
0221C:  MOVLW  03
0221E:  MOVWF  FEA
02220:  MOVLW  84
02222:  MOVWF  FE9
02224:  RCALL  1FCA
02226:  MOVLW  4C
02228:  MOVWF  FF6
0222A:  MOVLW  02
0222C:  MOVWF  FF7
0222E:  MOVLW  05
02230:  MOVLB  3
02232:  MOVWF  x8D
02234:  MOVLB  0
02236:  RCALL  1AD8
....................       get_pin_string(pin2, str); 
02238:  MOVFF  382,38E
0223C:  MOVFF  381,38D
02240:  MOVLW  03
02242:  MOVLB  3
02244:  MOVWF  x90
02246:  MOVLW  84
02248:  MOVWF  x8F
0224A:  MOVLB  0
0224C:  RCALL  1F56
....................       fprintf(USER,"%s ", str); 
0224E:  MOVLW  03
02250:  MOVWF  FEA
02252:  MOVLW  84
02254:  MOVWF  FE9
02256:  RCALL  1FCA
02258:  MOVLW  20
0225A:  BTFSS  F9E.4
0225C:  BRA    225A
0225E:  MOVWF  FAD
....................       if (fail) 
02260:  MOVLB  3
02262:  MOVF   x83,F
02264:  BZ    2290
....................          fprintf(USER,"FAIL [%X]", fail); 
02266:  MOVLW  52
02268:  MOVWF  FF6
0226A:  MOVLW  02
0226C:  MOVWF  FF7
0226E:  MOVLW  06
02270:  MOVWF  x8D
02272:  MOVLB  0
02274:  RCALL  1AD8
02276:  MOVFF  383,38D
0227A:  MOVLW  37
0227C:  MOVLB  3
0227E:  MOVWF  x8E
02280:  MOVLB  0
02282:  RCALL  1AF2
02284:  MOVLW  5D
02286:  BTFSS  F9E.4
02288:  BRA    2286
0228A:  MOVWF  FAD
....................       else 
0228C:  BRA    22A2
0228E:  MOVLB  3
....................          fprintf(USER,"OK"); 
02290:  MOVLW  4F
02292:  BTFSS  F9E.4
02294:  BRA    2292
02296:  MOVWF  FAD
02298:  MOVLW  4B
0229A:  BTFSS  F9E.4
0229C:  BRA    229A
0229E:  MOVWF  FAD
022A0:  MOVLB  0
....................       fprintf(USER,"\r\n"); 
022A2:  MOVLW  0D
022A4:  BTFSS  F9E.4
022A6:  BRA    22A4
022A8:  MOVWF  FAD
022AA:  MOVLW  0A
022AC:  BTFSS  F9E.4
022AE:  BRA    22AC
022B0:  MOVWF  FAD
022B2:  MOVLB  3
....................    } 
....................  #endif 
....................  
....................    return(fail != 0); 
022B4:  MOVF   x83,F
022B6:  BNZ   22BC
022B8:  MOVLW  00
022BA:  BRA    22BE
022BC:  MOVLW  01
022BE:  MOVWF  01
.................... } 
022C0:  MOVLB  0
022C2:  RETLW  00
....................  
.................... #if STACK_USE_SERIAL 
.................... #if STACK_USE_CCS_PICENS 
.................... void hardware_test(void) 
.................... { 
....................    int1 fail_nic=0,fail_ee=0; 
022C4:  MOVLB  3
022C6:  BCF    x7D.0
022C8:  BCF    x7D.1
....................    int1 fail_pins=0; 
022CA:  BCF    x7D.2
....................  
....................    fprintf(USER,"\r\n\n\nENC28J60 Test: "); 
022CC:  MOVLW  5C
022CE:  MOVWF  FF6
022D0:  MOVLW  02
022D2:  MOVWF  FF7
022D4:  MOVLB  0
022D6:  CALL   0D10
....................    SPISelectEthernet(); 
022DA:  BCF    F95.1
022DC:  BCF    F8C.1
....................    BankSel(MAADR1); 
022DE:  MOVLW  03
022E0:  MOVLB  4
022E2:  MOVWF  x2E
022E4:  MOVLW  04
022E6:  MOVWF  x2D
022E8:  MOVLB  0
022EA:  CALL   10B2
....................    WriteReg(MAADR1 + 0, 0x15); 
022EE:  MOVLW  04
022F0:  MOVLB  4
022F2:  MOVWF  x30
022F4:  MOVLW  15
022F6:  MOVWF  x31
022F8:  MOVLB  0
022FA:  CALL   1058
....................    WriteReg(MAADR1 + 1, 0x26); 
022FE:  MOVLW  05
02300:  MOVLB  4
02302:  MOVWF  x30
02304:  MOVLW  26
02306:  MOVWF  x31
02308:  MOVLB  0
0230A:  CALL   1058
....................    WriteReg(MAADR1 + 2, 0x37); 
0230E:  MOVLW  06
02310:  MOVLB  4
02312:  MOVWF  x30
02314:  MOVLW  37
02316:  MOVWF  x31
02318:  MOVLB  0
0231A:  CALL   1058
....................    if (ReadMACReg(MAADR1 + 1).Val != 0x26) 
0231E:  MOVLW  05
02320:  MOVLB  3
02322:  MOVWF  x85
02324:  MOVLB  0
02326:  CALL   10E8
0232A:  MOVFF  01,37E
0232E:  MOVLB  3
02330:  MOVF   01,W
02332:  SUBLW  26
02334:  BZ    2338
....................       fail_nic = TRUE; 
02336:  BSF    x7D.0
....................    SPIUnselectEthernet(); 
02338:  BCF    F95.1
0233A:  BSF    F8C.1
....................    if (fail_nic) 
0233C:  BTFSS  x7D.0
0233E:  BRA    2352
....................       fprintf(USER,"FAIL"); 
02340:  MOVLW  70
02342:  MOVWF  FF6
02344:  MOVLW  02
02346:  MOVWF  FF7
02348:  MOVLB  0
0234A:  CALL   0D10
....................    else 
0234E:  BRA    2360
02350:  MOVLB  3
....................       fprintf(USER,"PASS"); 
02352:  MOVLW  76
02354:  MOVWF  FF6
02356:  MOVLW  02
02358:  MOVWF  FF7
0235A:  MOVLB  0
0235C:  CALL   0D10
....................  
....................    write_ext_eeprom(5000,0x55); 
02360:  MOVLW  13
02362:  MOVLB  3
02364:  MOVWF  x93
02366:  MOVLW  88
02368:  MOVWF  x92
0236A:  MOVLW  55
0236C:  MOVWF  x94
0236E:  MOVLB  0
02370:  CALL   0D22
....................    write_ext_eeprom(5001,0x66); 
02374:  MOVLW  13
02376:  MOVLB  3
02378:  MOVWF  x93
0237A:  MOVLW  89
0237C:  MOVWF  x92
0237E:  MOVLW  66
02380:  MOVWF  x94
02382:  MOVLB  0
02384:  CALL   0D22
....................    write_ext_eeprom(5002,0x77); 
02388:  MOVLW  13
0238A:  MOVLB  3
0238C:  MOVWF  x93
0238E:  MOVLW  8A
02390:  MOVWF  x92
02392:  MOVLW  77
02394:  MOVWF  x94
02396:  MOVLB  0
02398:  CALL   0D22
....................    fprintf(USER,"\r\nAT25256 Test: "); 
0239C:  MOVLW  7C
0239E:  MOVWF  FF6
023A0:  MOVLW  02
023A2:  MOVWF  FF7
023A4:  CALL   0D10
....................    if (read_ext_eeprom(5001)==0x66) 
023A8:  MOVLW  13
023AA:  MOVLB  3
023AC:  MOVWF  x93
023AE:  MOVLW  89
023B0:  MOVWF  x92
023B2:  MOVLB  0
023B4:  CALL   0C16
023B8:  MOVF   01,W
023BA:  SUBLW  66
023BC:  BNZ   23CC
....................       fprintf(USER,"PASS"); 
023BE:  MOVLW  8E
023C0:  MOVWF  FF6
023C2:  MOVLW  02
023C4:  MOVWF  FF7
023C6:  CALL   0D10
....................    else 
023CA:  BRA    23DC
....................    { 
....................       fprintf(USER,"FAIL !!!"); 
023CC:  MOVLW  94
023CE:  MOVWF  FF6
023D0:  MOVLW  02
023D2:  MOVWF  FF7
023D4:  CALL   0D10
....................       fail_ee=TRUE; 
023D8:  MOVLB  3
023DA:  BSF    x7D.1
....................    } 
....................  
....................    if (fail_nic && fail_ee) 
023DC:  MOVLB  3
023DE:  BTFSS  x7D.0
023E0:  BRA    23F6
023E2:  BTFSS  x7D.1
023E4:  BRA    23F6
....................       fprintf(USER,"\r\nBoth ENC28J60 and AT25256 fail!!!"); 
023E6:  MOVLW  9E
023E8:  MOVWF  FF6
023EA:  MOVLW  02
023EC:  MOVWF  FF7
023EE:  MOVLB  0
023F0:  CALL   0D10
023F4:  MOVLB  3
....................  
....................    fprintf(USER,"\r\n\nBlinking LEDs. Press A4 when LEDs are verified working.\r\n"); 
023F6:  MOVLW  C2
023F8:  MOVWF  FF6
023FA:  MOVLW  02
023FC:  MOVWF  FF7
023FE:  MOVLB  0
02400:  CALL   0D10
....................    output_high(USER_LED1); 
02404:  BSF    F89.5
....................    output_high(USER_LED2); 
02406:  BSF    F8A.4
....................    output_high(USER_LED3); 
02408:  BSF    F8A.5
....................    while(input(PIN_A4)) 
....................    { 
0240A:  BTFSS  F80.4
0240C:  BRA    2422
....................       output_toggle(USER_LED1); 
0240E:  BTG    F89.5
....................       output_toggle(USER_LED2); 
02410:  BTG    F8A.4
....................       output_toggle(USER_LED3); 
02412:  BTG    F8A.5
....................       delay_ms(250); 
02414:  MOVLW  FA
02416:  MOVLB  3
02418:  MOVWF  xA7
0241A:  MOVLB  0
0241C:  CALL   0A04
....................    } 
02420:  BRA    240A
....................  
....................    fprintf(USER, "\r\nTurn the POT completely to the right."); 
02422:  MOVLW  00
02424:  MOVWF  FF6
02426:  MOVLW  03
02428:  MOVWF  FF7
0242A:  CALL   0D10
....................    set_adc_channel(ADC_CHAN_0); 
0242E:  MOVLW  00
02430:  MOVWF  01
02432:  MOVF   FC2,W
02434:  ANDLW  C3
02436:  IORWF  01,W
02438:  MOVWF  FC2
....................    delay_ms(1); 
0243A:  MOVLW  01
0243C:  MOVLB  3
0243E:  MOVWF  xA7
02440:  MOVLB  0
02442:  CALL   0A04
....................    while (read_adc() < 0xF8) { } 
02446:  BSF    FC2.1
02448:  BTFSC  FC2.1
0244A:  BRA    2448
0244C:  MOVF   FC4,W
0244E:  SUBLW  F7
02450:  BNC   2454
02452:  BRA    2446
....................    fprintf(USER, "\r\nTurn the POT completely to the left."); 
02454:  MOVLW  28
02456:  MOVWF  FF6
02458:  MOVLW  03
0245A:  MOVWF  FF7
0245C:  CALL   0D10
....................    while (read_adc() > 0x08) { } 
02460:  BSF    FC2.1
02462:  BTFSC  FC2.1
02464:  BRA    2462
02466:  MOVF   FC4,W
02468:  SUBLW  08
0246A:  BC    246E
0246C:  BRA    2460
....................    fprintf(USER, "\r\nPOT Test: PASS\r\n"); 
0246E:  MOVLW  50
02470:  MOVWF  FF6
02472:  MOVLW  03
02474:  MOVWF  FF7
02476:  CALL   0D10
....................  
....................    setup_adc_ports(NO_ANALOGS); 
0247A:  MOVF   FC1,W
0247C:  ANDLW  C0
0247E:  IORLW  0F
02480:  MOVWF  FC1
....................    setup_spi(SPI_SS_DISABLED); 
02482:  BCF    FC6.5
02484:  MOVLW  01
02486:  MOVWF  FC6
02488:  MOVLW  00
0248A:  MOVWF  FC7
....................  
....................    fprintf(USER, "\r\nInsert test header now.  Press T when ready."); 
0248C:  MOVLW  64
0248E:  MOVWF  FF6
02490:  MOVLW  03
02492:  MOVWF  FF7
02494:  CALL   0D10
....................    while(toupper(fgetc(USER))!='T') { } 
02498:  BTFSS  F9E.5
0249A:  BRA    2498
0249C:  MOVF   FAE,W
0249E:  MOVLB  3
024A0:  MOVWF  x7E
024A2:  SUBLW  60
024A4:  BC    24B2
024A6:  MOVF   x7E,W
024A8:  SUBLW  7A
024AA:  BNC   24B2
024AC:  MOVF   x7E,W
024AE:  ANDLW  DF
024B0:  BRA    24B4
024B2:  MOVF   x7E,W
024B4:  SUBLW  54
024B6:  BZ    24BE
024B8:  MOVLB  0
024BA:  BRA    2498
024BC:  MOVLB  3
....................  
....................    fprintf(USER, "\r\nTesting I/O header: \r\n"); 
024BE:  MOVLW  94
024C0:  MOVWF  FF6
024C2:  MOVLW  03
024C4:  MOVWF  FF7
024C6:  MOVLB  0
024C8:  CALL   0D10
....................    fail_pins |= hardware_io_test_pin(PIN_B7, PIN_B6); 
024CC:  MOVLW  00
024CE:  MOVLB  3
024D0:  BTFSC  x7D.2
024D2:  MOVLW  01
024D4:  MOVWF  x7E
024D6:  MOVLW  7C
024D8:  MOVWF  x80
024DA:  MOVLW  0F
024DC:  MOVWF  x7F
024DE:  MOVLW  7C
024E0:  MOVWF  x82
024E2:  MOVLW  0E
024E4:  MOVWF  x81
024E6:  MOVLB  0
024E8:  RCALL  1FE0
024EA:  MOVLB  3
024EC:  MOVF   x7E,W
024EE:  IORWF  01,W
024F0:  BCF    x7D.2
024F2:  BTFSC  FE8.0
024F4:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_B5, PIN_B4); 
024F6:  MOVLW  00
024F8:  BTFSC  x7D.2
024FA:  MOVLW  01
024FC:  MOVWF  x7E
024FE:  MOVLW  7C
02500:  MOVWF  x80
02502:  MOVLW  0D
02504:  MOVWF  x7F
02506:  MOVLW  7C
02508:  MOVWF  x82
0250A:  MOVLW  0C
0250C:  MOVWF  x81
0250E:  MOVLB  0
02510:  RCALL  1FE0
02512:  MOVLB  3
02514:  MOVF   x7E,W
02516:  IORWF  01,W
02518:  BCF    x7D.2
0251A:  BTFSC  FE8.0
0251C:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_B3, PIN_B2); 
0251E:  MOVLW  00
02520:  BTFSC  x7D.2
02522:  MOVLW  01
02524:  MOVWF  x7E
02526:  MOVLW  7C
02528:  MOVWF  x80
0252A:  MOVLW  0B
0252C:  MOVWF  x7F
0252E:  MOVLW  7C
02530:  MOVWF  x82
02532:  MOVLW  0A
02534:  MOVWF  x81
02536:  MOVLB  0
02538:  RCALL  1FE0
0253A:  MOVLB  3
0253C:  MOVF   x7E,W
0253E:  IORWF  01,W
02540:  BCF    x7D.2
02542:  BTFSC  FE8.0
02544:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_B1, PIN_B0); 
02546:  MOVLW  00
02548:  BTFSC  x7D.2
0254A:  MOVLW  01
0254C:  MOVWF  x7E
0254E:  MOVLW  7C
02550:  MOVWF  x80
02552:  MOVLW  09
02554:  MOVWF  x7F
02556:  MOVLW  7C
02558:  MOVWF  x82
0255A:  MOVLW  08
0255C:  MOVWF  x81
0255E:  MOVLB  0
02560:  RCALL  1FE0
02562:  MOVLB  3
02564:  MOVF   x7E,W
02566:  IORWF  01,W
02568:  BCF    x7D.2
0256A:  BTFSC  FE8.0
0256C:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_D7, PIN_D6); 
0256E:  MOVLW  00
02570:  BTFSC  x7D.2
02572:  MOVLW  01
02574:  MOVWF  x7E
02576:  MOVLW  7C
02578:  MOVWF  x80
0257A:  MOVLW  1F
0257C:  MOVWF  x7F
0257E:  MOVLW  7C
02580:  MOVWF  x82
02582:  MOVLW  1E
02584:  MOVWF  x81
02586:  MOVLB  0
02588:  RCALL  1FE0
0258A:  MOVLB  3
0258C:  MOVF   x7E,W
0258E:  IORWF  01,W
02590:  BCF    x7D.2
02592:  BTFSC  FE8.0
02594:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_D5, PIN_D4); 
02596:  MOVLW  00
02598:  BTFSC  x7D.2
0259A:  MOVLW  01
0259C:  MOVWF  x7E
0259E:  MOVLW  7C
025A0:  MOVWF  x80
025A2:  MOVLW  1D
025A4:  MOVWF  x7F
025A6:  MOVLW  7C
025A8:  MOVWF  x82
025AA:  MOVLW  1C
025AC:  MOVWF  x81
025AE:  MOVLB  0
025B0:  RCALL  1FE0
025B2:  MOVLB  3
025B4:  MOVF   x7E,W
025B6:  IORWF  01,W
025B8:  BCF    x7D.2
025BA:  BTFSC  FE8.0
025BC:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_D3, PIN_D2); 
025BE:  MOVLW  00
025C0:  BTFSC  x7D.2
025C2:  MOVLW  01
025C4:  MOVWF  x7E
025C6:  MOVLW  7C
025C8:  MOVWF  x80
025CA:  MOVLW  1B
025CC:  MOVWF  x7F
025CE:  MOVLW  7C
025D0:  MOVWF  x82
025D2:  MOVLW  1A
025D4:  MOVWF  x81
025D6:  MOVLB  0
025D8:  RCALL  1FE0
025DA:  MOVLB  3
025DC:  MOVF   x7E,W
025DE:  IORWF  01,W
025E0:  BCF    x7D.2
025E2:  BTFSC  FE8.0
025E4:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_D1, PIN_D0); 
025E6:  MOVLW  00
025E8:  BTFSC  x7D.2
025EA:  MOVLW  01
025EC:  MOVWF  x7E
025EE:  MOVLW  7C
025F0:  MOVWF  x80
025F2:  MOVLW  19
025F4:  MOVWF  x7F
025F6:  MOVLW  7C
025F8:  MOVWF  x82
025FA:  MOVLW  18
025FC:  MOVWF  x81
025FE:  MOVLB  0
02600:  RCALL  1FE0
02602:  MOVLB  3
02604:  MOVF   x7E,W
02606:  IORWF  01,W
02608:  BCF    x7D.2
0260A:  BTFSC  FE8.0
0260C:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_C5, PIN_C4); 
0260E:  MOVLW  00
02610:  BTFSC  x7D.2
02612:  MOVLW  01
02614:  MOVWF  x7E
02616:  MOVLW  7C
02618:  MOVWF  x80
0261A:  MOVLW  15
0261C:  MOVWF  x7F
0261E:  MOVLW  7C
02620:  MOVWF  x82
02622:  MOVLW  14
02624:  MOVWF  x81
02626:  MOVLB  0
02628:  RCALL  1FE0
0262A:  MOVLB  3
0262C:  MOVF   x7E,W
0262E:  IORWF  01,W
02630:  BCF    x7D.2
02632:  BTFSC  FE8.0
02634:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_C3, PIN_C2); 
02636:  MOVLW  00
02638:  BTFSC  x7D.2
0263A:  MOVLW  01
0263C:  MOVWF  x7E
0263E:  MOVLW  7C
02640:  MOVWF  x80
02642:  MOVLW  13
02644:  MOVWF  x7F
02646:  MOVLW  7C
02648:  MOVWF  x82
0264A:  MOVLW  12
0264C:  MOVWF  x81
0264E:  MOVLB  0
02650:  RCALL  1FE0
02652:  MOVLB  3
02654:  MOVF   x7E,W
02656:  IORWF  01,W
02658:  BCF    x7D.2
0265A:  BTFSC  FE8.0
0265C:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_C1, PIN_C0); 
0265E:  MOVLW  00
02660:  BTFSC  x7D.2
02662:  MOVLW  01
02664:  MOVWF  x7E
02666:  MOVLW  7C
02668:  MOVWF  x80
0266A:  MOVLW  11
0266C:  MOVWF  x7F
0266E:  MOVLW  7C
02670:  MOVWF  x82
02672:  MOVLW  10
02674:  MOVWF  x81
02676:  MOVLB  0
02678:  RCALL  1FE0
0267A:  MOVLB  3
0267C:  MOVF   x7E,W
0267E:  IORWF  01,W
02680:  BCF    x7D.2
02682:  BTFSC  FE8.0
02684:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_A5, PIN_A4); 
02686:  MOVLW  00
02688:  BTFSC  x7D.2
0268A:  MOVLW  01
0268C:  MOVWF  x7E
0268E:  MOVLW  7C
02690:  MOVWF  x80
02692:  MOVLW  05
02694:  MOVWF  x7F
02696:  MOVLW  7C
02698:  MOVWF  x82
0269A:  MOVLW  04
0269C:  MOVWF  x81
0269E:  MOVLB  0
026A0:  RCALL  1FE0
026A2:  MOVLB  3
026A4:  MOVF   x7E,W
026A6:  IORWF  01,W
026A8:  BCF    x7D.2
026AA:  BTFSC  FE8.0
026AC:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_A3, PIN_A2); 
026AE:  MOVLW  00
026B0:  BTFSC  x7D.2
026B2:  MOVLW  01
026B4:  MOVWF  x7E
026B6:  MOVLW  7C
026B8:  MOVWF  x80
026BA:  MOVLW  03
026BC:  MOVWF  x7F
026BE:  MOVLW  7C
026C0:  MOVWF  x82
026C2:  MOVLW  02
026C4:  MOVWF  x81
026C6:  MOVLB  0
026C8:  RCALL  1FE0
026CA:  MOVLB  3
026CC:  MOVF   x7E,W
026CE:  IORWF  01,W
026D0:  BCF    x7D.2
026D2:  BTFSC  FE8.0
026D4:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_A1, PIN_E2); 
026D6:  MOVLW  00
026D8:  BTFSC  x7D.2
026DA:  MOVLW  01
026DC:  MOVWF  x7E
026DE:  MOVLW  7C
026E0:  MOVWF  x80
026E2:  MOVLW  01
026E4:  MOVWF  x7F
026E6:  MOVLW  7C
026E8:  MOVWF  x82
026EA:  MOVLW  22
026EC:  MOVWF  x81
026EE:  MOVLB  0
026F0:  RCALL  1FE0
026F2:  MOVLB  3
026F4:  MOVF   x7E,W
026F6:  IORWF  01,W
026F8:  BCF    x7D.2
026FA:  BTFSC  FE8.0
026FC:  BSF    x7D.2
....................    fail_pins |= hardware_io_test_pin(PIN_E1, PIN_E0); 
026FE:  MOVLW  00
02700:  BTFSC  x7D.2
02702:  MOVLW  01
02704:  MOVWF  x7E
02706:  MOVLW  7C
02708:  MOVWF  x80
0270A:  MOVLW  21
0270C:  MOVWF  x7F
0270E:  MOVLW  7C
02710:  MOVWF  x82
02712:  MOVLW  20
02714:  MOVWF  x81
02716:  MOVLB  0
02718:  RCALL  1FE0
0271A:  MOVLB  3
0271C:  MOVF   x7E,W
0271E:  IORWF  01,W
02720:  BCF    x7D.2
02722:  BTFSC  FE8.0
02724:  BSF    x7D.2
....................    if (fail_pins) 
02726:  BTFSS  x7D.2
02728:  BRA    273C
....................       fprintf(USER, "\r\nI/O header FAIL !!!"); 
0272A:  MOVLW  AE
0272C:  MOVWF  FF6
0272E:  MOVLW  03
02730:  MOVWF  FF7
02732:  MOVLB  0
02734:  CALL   0D10
....................    else 
02738:  BRA    274A
0273A:  MOVLB  3
....................       fprintf(USER, "PASS"); 
0273C:  MOVLW  C4
0273E:  MOVWF  FF6
02740:  MOVLW  03
02742:  MOVWF  FF7
02744:  MOVLB  0
02746:  CALL   0D10
....................  
....................    fprintf(USER, "\r\n\nRemove test header.  Press T when ready."); 
0274A:  MOVLW  CA
0274C:  MOVWF  FF6
0274E:  MOVLW  03
02750:  MOVWF  FF7
02752:  CALL   0D10
....................    while(toupper(fgetc(USER))!='T') { } 
02756:  BTFSS  F9E.5
02758:  BRA    2756
0275A:  MOVF   FAE,W
0275C:  MOVLB  3
0275E:  MOVWF  x7E
02760:  SUBLW  60
02762:  BC    2770
02764:  MOVF   x7E,W
02766:  SUBLW  7A
02768:  BNC   2770
0276A:  MOVF   x7E,W
0276C:  ANDLW  DF
0276E:  BRA    2772
02770:  MOVF   x7E,W
02772:  SUBLW  54
02774:  BZ    277C
02776:  MOVLB  0
02778:  BRA    2756
0277A:  MOVLB  3
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
0277C:  MOVLW  F6
0277E:  MOVWF  FF6
02780:  MOVLW  03
02782:  MOVWF  FF7
02784:  MOVLB  0
02786:  CALL   0D10
....................    reset_cpu(); 
0278A:  RESET
.................... } 
0278C:  GOTO   2EFC (RETURN)
.................... #elif STACK_USE_CCS_PICNET 
.................... void hardware_test(void) 
.................... { 
....................    char modemStr[]="AT"; 
....................  
....................    fprintf(USER, "\r\n\n"); 
....................  
.................... #if STACK_USE_MAC 
....................    fprintf(USER, "\r\nNIC RTL8019AS (U603) TEST: "); 
....................    NICPut(CMDR, 0x61); // CMDR = ; Select Page 1 
....................    NICPut(PAR0, 0x15);  //PAR0 = 0x01 
....................    NICPut(PAR0+1, 0x26); 
....................    NICPut(PAR0+2, 0x37); 
....................    NICPut(PAR0+3, 0x48); 
....................    NICPut(PAR0+4, 0x59); 
....................    NICPut(PAR0+5, 0x6A); 
....................    if (NICGet(0x01+3) == 0x48) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nMODEM (U1 & U7) TEST: "); 
....................    if (modem_at_command(modemStr, 2000) == MODEM_OK) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
....................    fprintf(USER,"\r\n24LC256 (U103) TEST: "); 
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
....................  
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B0 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B0)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B1 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B1)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
....................    reset_cpu(); 
.................... } 
.................... #elif STACK_USE_CCS_PICEEC   //PICEEC 
.................... void hardware_test(void) 
.................... { 
....................    int8 i; 
....................    int1 fail_ee=0; 
....................    int1 fail_pins=0; 
....................  
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    fprintf(USER,"\r\n\n\nAT25256 (U7) TEST: "); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................    { 
....................       fprintf(USER,"FAIL"); 
....................       fail_ee=TRUE; 
....................    } 
....................  
....................    set_adc_channel(ADC_CHAN_0); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE LEFT."); 
....................    while(read_adc() > 0x08); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE RIGHT."); 
....................    while(read_adc() < 0xF8); 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL A4 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    output_high(USER_LED3); 
....................    while(input(PIN_A4)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       output_toggle(USER_LED3); 
....................       delay_ms(250); 
....................    } 
....................    while(!input(PIN_A4)); 
....................    delay_ms(250); 
....................  
....................    fprintf(USER, "\r\nTESTING I/O HEADER (J4):\r\n"); 
....................    fail_pins |= hardware_io_test_pin(PIN_D1, PIN_D0); 
....................    fail_pins |= hardware_io_test_pin(PIN_G4, PIN_D2); 
....................    fail_pins |= hardware_io_test_pin(PIN_E1, PIN_E0); 
....................    fail_pins |= hardware_io_test_pin(PIN_E3, PIN_E2); 
....................    fail_pins |= hardware_io_test_pin(PIN_E5, PIN_E4); 
....................    fail_pins |= hardware_io_test_pin(PIN_B1, PIN_B0); 
....................    fail_pins |= hardware_io_test_pin(PIN_B3, PIN_B2); 
....................    fail_pins |= hardware_io_test_pin(PIN_B5, PIN_B4); 
....................    fail_pins |= hardware_io_test_pin(PIN_A5, PIN_A4); 
....................    //fail_pins |= hardware_io_test_pin(PIN_A3, PIN_C0); 
....................    if (fail_pins) 
....................       fprintf(USER, "\r\nI/O HEADER (J4): FAIL!!!"); 
....................    else 
....................       fprintf(USER, "PASS"); 
....................  
....................    if (fail_ee || fail_pins) 
....................       fprintf(USER,"\r\n\n!!!! BOARD DOES NOT PASS !!!!"); 
....................    else 
....................       fprintf(USER,"\r\n\n++++ BOARD PASS ++++"); 
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
....................    delay_ms(15); 
....................    reset_cpu(); 
.................... } 
.................... #else 
.................... void hardware_test(void) 
.................... { 
....................    fprintf(USER,"\r\n\nNO HARDWARE TEST!\r\n\nRESETTING BOARD\r\n\n"); 
....................    delay_ms(15); 
....................    reset_cpu(); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include "ccshelperui.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                       CCSHELPERUI.C                               //// 
.................... ////                                                                   //// 
.................... //// More Helper functions and definitions for using CCS's example     //// 
.................... //// programs   These routines are more focused on the user interface  //// 
.................... //// needed to get and save setting from the user.                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if STACK_USE_SERIAL 
....................  
.................... void ui_disp_ip_user(IP_ADDR *ip) { 
....................    fprintf(USER,"%U.%U.%U.%U",ip->v[0],ip->v[1],ip->v[2],ip->v[3]); 
*
01BE2:  MOVLB  3
01BE4:  MOVFF  37E,FE9
01BE8:  MOVFF  37F,FEA
01BEC:  MOVFF  FEF,380
01BF0:  MOVLW  01
01BF2:  ADDWF  x7E,W
01BF4:  MOVWF  FE9
01BF6:  MOVLW  00
01BF8:  ADDWFC x7F,W
01BFA:  MOVWF  FEA
01BFC:  MOVFF  FEF,381
01C00:  MOVLW  02
01C02:  ADDWF  x7E,W
01C04:  MOVWF  FE9
01C06:  MOVLW  00
01C08:  ADDWFC x7F,W
01C0A:  MOVWF  FEA
01C0C:  MOVFF  FEF,382
01C10:  MOVLW  03
01C12:  ADDWF  x7E,W
01C14:  MOVWF  FE9
01C16:  MOVLW  00
01C18:  ADDWFC x7F,W
01C1A:  MOVWF  FEA
01C1C:  MOVFF  FEF,383
01C20:  MOVFF  380,388
01C24:  MOVLW  1B
01C26:  MOVWF  x89
01C28:  MOVLB  0
01C2A:  RCALL  1B64
01C2C:  MOVLW  2E
01C2E:  BTFSS  F9E.4
01C30:  BRA    1C2E
01C32:  MOVWF  FAD
01C34:  MOVFF  381,388
01C38:  MOVLW  1B
01C3A:  MOVLB  3
01C3C:  MOVWF  x89
01C3E:  MOVLB  0
01C40:  RCALL  1B64
01C42:  MOVLW  2E
01C44:  BTFSS  F9E.4
01C46:  BRA    1C44
01C48:  MOVWF  FAD
01C4A:  MOVFF  382,388
01C4E:  MOVLW  1B
01C50:  MOVLB  3
01C52:  MOVWF  x89
01C54:  MOVLB  0
01C56:  RCALL  1B64
01C58:  MOVLW  2E
01C5A:  BTFSS  F9E.4
01C5C:  BRA    1C5A
01C5E:  MOVWF  FAD
01C60:  MOVFF  383,388
01C64:  MOVLW  1B
01C66:  MOVLB  3
01C68:  MOVWF  x89
01C6A:  MOVLB  0
01C6C:  RCALL  1B64
.................... } 
01C6E:  RETLW  00
....................  
.................... void ui_disp_mac_user(MAC_ADDR *mac) 
.................... { 
....................    fprintf(USER,"%X:%X:%X:%X:%X:%X", 
....................          mac->v[0], 
....................          mac->v[1], 
....................          mac->v[2], 
....................          mac->v[3], 
....................          mac->v[4], 
....................          mac->v[5] 
....................       ); 
.................... } 
....................  
.................... void ui_settings(void) { 
.................... #if STACK_USE_MAC 
....................    int1 disp=TRUE; 
01C70:  MOVLB  3
01C72:  BSF    x7D.0
.................... #endif 
.................... #if STACK_USE_TELNET 
....................    int8 i; 
.................... #endif 
.................... #ifdef CCS_UDP_EXAMPLE 
....................    IP_ADDR scratchIP; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    if (ppp_is_connected()) 
....................    { 
....................       fprintf(USER,"\r\n\nIP Address: "); ui_disp_ip_user(&AppConfig.MyIPAddr); 
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
....................      #endif 
....................       fprintf(USER,"\r\nBaud Rate: %LU",connected_baudrate); 
....................    } 
....................    else { 
....................       fprintf(USER,"\r\n\nNot connected to ISP"); 
....................    } 
....................    fprintf(USER,"\r\nISP Username: %s",ppp_username); 
....................    fprintf(USER,"\r\nISP Password: %s",ppp_password); 
....................    fprintf(USER,"\r\nISP Phonenumber: %s", ppp_phonenumber); 
.................... #elif STACK_USE_MAC 
....................    fprintf(USER,"\r\n\nMAC Address: %X:%X:%X:%X:%X:%X",AppConfig.MyMACAddr.v[0],AppConfig.MyMACAddr.v[1],AppConfig.MyMACAddr.v[2],AppConfig.MyMACAddr.v[3],AppConfig.MyMACAddr.v[4],AppConfig.MyMACAddr.v[5]); 
01C74:  MOVLW  0C
01C76:  MOVWF  FF6
01C78:  MOVLW  04
01C7A:  MOVWF  FF7
01C7C:  MOVLW  10
01C7E:  MOVWF  x8D
01C80:  MOVLB  0
01C82:  RCALL  1AD8
01C84:  MOVFF  1A,38D
01C88:  MOVLW  37
01C8A:  MOVLB  3
01C8C:  MOVWF  x8E
01C8E:  MOVLB  0
01C90:  RCALL  1AF2
01C92:  MOVLW  3A
01C94:  BTFSS  F9E.4
01C96:  BRA    1C94
01C98:  MOVWF  FAD
01C9A:  MOVFF  1B,38D
01C9E:  MOVLW  37
01CA0:  MOVLB  3
01CA2:  MOVWF  x8E
01CA4:  MOVLB  0
01CA6:  RCALL  1AF2
01CA8:  MOVLW  3A
01CAA:  BTFSS  F9E.4
01CAC:  BRA    1CAA
01CAE:  MOVWF  FAD
01CB0:  MOVFF  1C,38D
01CB4:  MOVLW  37
01CB6:  MOVLB  3
01CB8:  MOVWF  x8E
01CBA:  MOVLB  0
01CBC:  RCALL  1AF2
01CBE:  MOVLW  3A
01CC0:  BTFSS  F9E.4
01CC2:  BRA    1CC0
01CC4:  MOVWF  FAD
01CC6:  MOVFF  1D,38D
01CCA:  MOVLW  37
01CCC:  MOVLB  3
01CCE:  MOVWF  x8E
01CD0:  MOVLB  0
01CD2:  RCALL  1AF2
01CD4:  MOVLW  3A
01CD6:  BTFSS  F9E.4
01CD8:  BRA    1CD6
01CDA:  MOVWF  FAD
01CDC:  MOVFF  1E,38D
01CE0:  MOVLW  37
01CE2:  MOVLB  3
01CE4:  MOVWF  x8E
01CE6:  MOVLB  0
01CE8:  RCALL  1AF2
01CEA:  MOVLW  3A
01CEC:  BTFSS  F9E.4
01CEE:  BRA    1CEC
01CF0:  MOVWF  FAD
01CF2:  MOVFF  1F,38D
01CF6:  MOVLW  37
01CF8:  MOVLB  3
01CFA:  MOVWF  x8E
01CFC:  MOVLB  0
01CFE:  RCALL  1AF2
....................   #if STACK_USE_DHCP 
....................    fprintf(USER,"\r\nDHCP Enabled: "); 
01D00:  MOVLW  2E
01D02:  MOVWF  FF6
01D04:  MOVLW  04
01D06:  MOVWF  FF7
01D08:  CALL   0D10
....................   #if STACK_USE_EEPROM 
....................    if (read_ext_eeprom(EE_NIC_DHCP)) 
01D0C:  MOVLB  3
01D0E:  CLRF   x93
01D10:  MOVLW  C0
01D12:  MOVWF  x92
01D14:  MOVLB  0
01D16:  CALL   0C16
01D1A:  MOVF   01,F
01D1C:  BZ    1D5C
....................   #else 
....................    if (TRUE) 
....................   #endif 
....................    { 
....................       fprintf(USER,"TRUE"); 
01D1E:  MOVLW  40
01D20:  MOVWF  FF6
01D22:  MOVLW  04
01D24:  MOVWF  FF7
01D26:  CALL   0D10
....................       fprintf(USER,"\r\nDHCP Bound: "); 
01D2A:  MOVLW  46
01D2C:  MOVWF  FF6
01D2E:  MOVLW  04
01D30:  MOVWF  FF7
01D32:  CALL   0D10
....................       if (DHCPIsBound()) {fprintf(USER,"TRUE");} 
01D36:  BTFSS  x86.0
01D38:  BRA    1D48
01D3A:  MOVLW  56
01D3C:  MOVWF  FF6
01D3E:  MOVLW  04
01D40:  MOVWF  FF7
01D42:  CALL   0D10
....................       else {fprintf(USER,"FALSE"); disp=FALSE;} 
01D46:  BRA    1D5A
01D48:  MOVLW  5C
01D4A:  MOVWF  FF6
01D4C:  MOVLW  04
01D4E:  MOVWF  FF7
01D50:  CALL   0D10
01D54:  MOVLB  3
01D56:  BCF    x7D.0
01D58:  MOVLB  0
....................    } 
....................    else { 
01D5A:  BRA    1D68
....................       fprintf(USER,"FALSE"); 
01D5C:  MOVLW  62
01D5E:  MOVWF  FF6
01D60:  MOVLW  04
01D62:  MOVWF  FF7
01D64:  CALL   0D10
....................    } 
....................   #else 
....................    disp=TRUE; 
....................   #endif 
....................    if (disp) { 
01D68:  MOVLB  3
01D6A:  BTFSS  x7D.0
01D6C:  BRA    1DBA
....................       fprintf(USER,"\r\nIP Address: ");  ui_disp_ip_user(&AppConfig.MyIPAddr); 
01D6E:  MOVLW  68
01D70:  MOVWF  FF6
01D72:  MOVLW  04
01D74:  MOVWF  FF7
01D76:  MOVLB  0
01D78:  CALL   0D10
01D7C:  MOVLB  3
01D7E:  CLRF   x7F
01D80:  MOVLW  16
01D82:  MOVWF  x7E
01D84:  MOVLB  0
01D86:  RCALL  1BE2
....................       fprintf(USER,"\r\nGateway: ");  ui_disp_ip_user(&AppConfig.MyGateway); 
01D88:  MOVLW  78
01D8A:  MOVWF  FF6
01D8C:  MOVLW  04
01D8E:  MOVWF  FF7
01D90:  CALL   0D10
01D94:  MOVLB  3
01D96:  CLRF   x7F
01D98:  MOVLW  24
01D9A:  MOVWF  x7E
01D9C:  MOVLB  0
01D9E:  RCALL  1BE2
....................       fprintf(USER,"\r\nNetmask: "); ui_disp_ip_user(&AppConfig.MyMask); 
01DA0:  MOVLW  84
01DA2:  MOVWF  FF6
01DA4:  MOVLW  04
01DA6:  MOVWF  FF7
01DA8:  CALL   0D10
01DAC:  MOVLB  3
01DAE:  CLRF   x7F
01DB0:  MOVLW  20
01DB2:  MOVWF  x7E
01DB4:  MOVLB  0
01DB6:  RCALL  1BE2
01DB8:  MOVLB  3
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
....................      #endif 
....................    } 
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................   fprintf(USER,"\r\nSMTP Server Hostname: %s", SMTP_HOST_NAME); 
....................   fprintf(USER,"\r\nSMTP Server Port: %LU",SMTP_PORT); 
....................   fprintf(USER,"\r\nE-Mail To: %s", SMTP_TO_ADDR); 
....................   fprintf(USER,"\r\nE-Mail From: %s", SMTP_FROM_ADDR); 
....................   fprintf(USER,"\r\nE-Mail Subject: %s", SMTP_SUBJECT); 
....................   fprintf(USER,"\r\nE-Mail Body: %s", SMTP_BODY); 
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
....................    read_ext_eeprom_ip(EE_UDP_DEST_IP, &scratchIP); 
....................    fprintf(USER,"\r\nUDP Destination IP: ");  ui_disp_ip_user(&scratchIP); 
....................    fprintf(USER,"\r\nUDP Destination Port: %LU", read_ext_eeprom16(EE_UDP_DEST_PORT)); 
....................    fprintf(USER,"\r\nUDP Source Port: %LU", read_ext_eeprom16(EE_UDP_SRC_PORT)); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    for (i=0;i<TELNET_MAX_CONNECTIONS;i++) { 
....................       fprintf(USER,"\r\nTelnet %U: ",i); 
....................       if (TelnetIsOpen(i)) { 
....................          fprintf(USER,"OPEN ST=%X S=%U IP=",TCB[telnet_active_socket[i]].smState,telnet_active_socket[i]); 
....................          ui_disp_ip_user(&TCB[telnet_active_socket[i]].remote.IPAddr); 
....................          fprintf(USER," RP=%LU",TCB[telnet_active_socket[i]].remotePort); 
....................       } 
....................       else { 
....................          fprintf(USER,"LISTENING ST=%X",TCB[telnet_active_socket[i]].smState); 
....................       } 
....................    } 
.................... #endif 
.................... } 
01DBA:  MOVLB  0
01DBC:  RETLW  00
....................  
.................... void fget_string(char* s, int max) { 
....................    int len=0; 
*
027E2:  MOVLB  3
027E4:  CLRF   x94
....................    char c; 
....................  
....................    --max; 
027E6:  DECF   x93,F
....................  
....................    while ((c=*s)!=0) 
....................    { 
027E8:  MOVFF  392,03
027EC:  MOVFF  391,FE9
027F0:  MOVFF  392,FEA
027F4:  MOVFF  FEF,395
027F8:  MOVF   x95,F
027FA:  BZ    280E
....................       fputc(c, USER); 
027FC:  MOVF   x95,W
027FE:  MOVLB  0
02800:  RCALL  27DA
....................       len++; 
02802:  MOVLB  3
02804:  INCF   x94,F
....................       s++; 
02806:  INCF   x91,F
02808:  BTFSC  FD8.2
0280A:  INCF   x92,F
....................    } 
0280C:  BRA    27E8
....................  
....................    do { 
....................      c=fgetc(USER); 
0280E:  BTFSS  F9E.5
02810:  BRA    280E
02812:  MOVFF  FAE,395
....................      if(c==8) {  // Backspace 
02816:  MOVF   x95,W
02818:  SUBLW  08
0281A:  BNZ   2840
....................         if(len>0) { 
0281C:  MOVF   x94,F
0281E:  BZ    283E
....................           len--; 
02820:  DECF   x94,F
....................           s--; 
02822:  MOVF   x91,W
02824:  BTFSC  FD8.2
02826:  DECF   x92,F
02828:  DECF   x91,F
....................           fputc(c,USER); 
0282A:  MOVF   x95,W
0282C:  MOVLB  0
0282E:  RCALL  27DA
....................           fputc(' ',USER); 
02830:  MOVLW  20
02832:  RCALL  27DA
....................           fputc(c,USER); 
02834:  MOVLB  3
02836:  MOVF   x95,W
02838:  MOVLB  0
0283A:  RCALL  27DA
0283C:  MOVLB  3
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0283E:  BRA    2872
02840:  MOVF   x95,W
02842:  SUBLW  1F
02844:  BC    2872
02846:  MOVF   x95,W
02848:  SUBLW  7E
0284A:  BNC   2872
....................        if(len<max) { 
0284C:  MOVF   x93,W
0284E:  SUBWF  x94,W
02850:  BC    2872
....................          *s++ = c; 
02852:  MOVFF  392,03
02856:  MOVF   x91,W
02858:  INCF   x91,F
0285A:  BTFSC  FD8.2
0285C:  INCF   x92,F
0285E:  MOVWF  FE9
02860:  MOVFF  03,FEA
02864:  MOVFF  395,FEF
....................          len++; 
02868:  INCF   x94,F
....................          fputc(c,USER); 
0286A:  MOVF   x95,W
0286C:  MOVLB  0
0286E:  RCALL  27DA
02870:  MOVLB  3
....................        } 
....................    } while(c!=13); 
02872:  MOVF   x95,W
02874:  SUBLW  0D
02876:  BNZ   280E
....................    *s = 0; 
02878:  MOVFF  391,FE9
0287C:  MOVFF  392,FEA
02880:  CLRF   FEF
.................... } 
02882:  MOVLB  0
02884:  RETLW  00
....................  
.................... int fget_int(int8 initial) { 
....................   char s[4]; 
....................   signed int i; 
....................  
....................   sprintf(s, "%U", initial); 
*
02B9E:  MOVLW  03
02BA0:  MOVLB  3
02BA2:  MOVWF  x30
02BA4:  MOVLW  8C
02BA6:  MOVWF  x2F
02BA8:  MOVFF  38B,3BD
02BAC:  MOVLW  1B
02BAE:  MOVWF  xBE
02BB0:  MOVLB  0
02BB2:  RCALL  2B18
....................  
....................   fget_string(s, 4); 
02BB4:  MOVLW  03
02BB6:  MOVLB  3
02BB8:  MOVWF  x92
02BBA:  MOVLW  8C
02BBC:  MOVWF  x91
02BBE:  MOVLW  04
02BC0:  MOVWF  x93
02BC2:  MOVLB  0
02BC4:  RCALL  27E2
....................  
....................   i=atol(s); 
02BC6:  MOVLW  03
02BC8:  MOVLB  3
02BCA:  MOVWF  x92
02BCC:  MOVLW  8C
02BCE:  MOVWF  x91
02BD0:  MOVLB  0
02BD2:  RCALL  28DA
02BD4:  MOVFF  01,390
....................   return(i); 
02BD8:  MOVLB  3
02BDA:  MOVFF  390,01
.................... } 
02BDE:  MOVLB  0
02BE0:  GOTO   2D10 (RETURN)
....................  
.................... int16 fget_long(int16 initial) { 
....................    char s[6]; 
....................    int16 i; 
....................  
....................    sprintf(s, "%LU", initial); 
....................  
....................    fget_string(s, 6); 
....................  
....................    i=atol(s); 
....................    return(i); 
.................... } 
....................  
.................... BYTE fgethex(int initial) { 
....................    char hex[5]; 
....................    int8 ret; 
....................  
....................    hex[0]='0'; 
*
02ACA:  MOVLW  30
02ACC:  MOVLB  3
02ACE:  MOVWF  x83
....................    hex[1]='x'; 
02AD0:  MOVLW  78
02AD2:  MOVWF  x84
....................  
....................    sprintf(&hex[2], "%X", initial); 
02AD4:  MOVLW  03
02AD6:  MOVWF  x30
02AD8:  MOVLW  85
02ADA:  MOVWF  x2F
02ADC:  MOVFF  382,3BD
02AE0:  MOVLW  37
02AE2:  MOVWF  xBE
02AE4:  MOVLB  0
02AE6:  RCALL  2790
....................  
....................    fget_string(&hex[2],3); 
02AE8:  MOVLW  03
02AEA:  MOVLB  3
02AEC:  MOVWF  x92
02AEE:  MOVLW  85
02AF0:  MOVWF  x91
02AF2:  MOVLW  03
02AF4:  MOVWF  x93
02AF6:  MOVLB  0
02AF8:  RCALL  27E2
....................    ret=atol(hex); 
02AFA:  MOVLW  03
02AFC:  MOVLB  3
02AFE:  MOVWF  x92
02B00:  MOVLW  83
02B02:  MOVWF  x91
02B04:  MOVLB  0
02B06:  RCALL  28DA
02B08:  MOVFF  01,388
....................    return(ret); 
02B0C:  MOVLB  3
02B0E:  MOVFF  388,01
.................... } 
02B12:  MOVLB  0
02B14:  GOTO   2DAC (RETURN)
....................  
.................... void ui_ip_to_ee(int16 address) { 
....................    IP_ADDR ip; 
....................    int i; 
....................  #if STACK_USE_EEPROM 
....................    read_ext_eeprom_ip(address, &ip); 
*
02C8C:  MOVFF  382,389
02C90:  MOVFF  381,388
02C94:  MOVLW  03
02C96:  MOVLB  3
02C98:  MOVWF  x8B
02C9A:  MOVLW  83
02C9C:  MOVWF  x8A
02C9E:  MOVLB  0
02CA0:  CALL   0F10
....................  #endif 
....................    for (i=0;i<4;i++) { 
02CA4:  MOVLB  3
02CA6:  CLRF   x87
02CA8:  MOVF   x87,W
02CAA:  SUBLW  03
02CAC:  BNC   2D32
....................       fprintf(USER, "  BYTE%U: ",i); 
02CAE:  MOVLW  90
02CB0:  MOVWF  FF6
02CB2:  MOVLW  04
02CB4:  MOVWF  FF7
02CB6:  MOVLW  06
02CB8:  MOVWF  x8D
02CBA:  MOVLB  0
02CBC:  CALL   1AD8
02CC0:  MOVFF  387,388
02CC4:  MOVLW  1B
02CC6:  MOVLB  3
02CC8:  MOVWF  x89
02CCA:  MOVLB  0
02CCC:  CALL   1B64
02CD0:  MOVLW  3A
02CD2:  BTFSS  F9E.4
02CD4:  BRA    2CD2
02CD6:  MOVWF  FAD
02CD8:  MOVLW  20
02CDA:  BTFSS  F9E.4
02CDC:  BRA    2CDA
02CDE:  MOVWF  FAD
....................       ip.v[i]=fget_int(ip.v[i]); 
02CE0:  CLRF   03
02CE2:  MOVLB  3
02CE4:  MOVF   x87,W
02CE6:  ADDLW  83
02CE8:  MOVWF  01
02CEA:  MOVLW  03
02CEC:  ADDWFC 03,F
02CEE:  MOVFF  01,388
02CF2:  MOVFF  03,389
02CF6:  CLRF   03
02CF8:  MOVF   x87,W
02CFA:  ADDLW  83
02CFC:  MOVWF  FE9
02CFE:  MOVLW  03
02D00:  ADDWFC 03,W
02D02:  MOVWF  FEA
02D04:  MOVFF  FEF,38A
02D08:  MOVFF  38A,38B
02D0C:  MOVLB  0
02D0E:  BRA    2B9E
02D10:  MOVFF  389,FEA
02D14:  MOVFF  388,FE9
02D18:  MOVFF  01,FEF
....................       fprintf(USER,"\r\n"); 
02D1C:  MOVLW  0D
02D1E:  BTFSS  F9E.4
02D20:  BRA    2D1E
02D22:  MOVWF  FAD
02D24:  MOVLW  0A
02D26:  BTFSS  F9E.4
02D28:  BRA    2D26
02D2A:  MOVWF  FAD
....................    } 
....................  #if STACK_USE_EEPROM 
02D2C:  MOVLB  3
02D2E:  INCF   x87,F
02D30:  BRA    2CA8
....................    write_ext_eeprom_ip(address, &ip); 
02D32:  MOVFF  382,389
02D36:  MOVFF  381,388
02D3A:  MOVLW  03
02D3C:  MOVWF  x8B
02D3E:  MOVLW  83
02D40:  MOVWF  x8A
02D42:  MOVLB  0
02D44:  BRA    2BE4
....................  #endif 
.................... } 
02D46:  RETLW  00
....................  
.................... #if STACK_USE_PPP 
.................... void ui_setup(void) { 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nISP USERNAME: "); 
....................    read_ext_eeprom_string(EE_ISP_USERNAME, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_USERNAME, str); 
....................  
....................    fprintf(USER,"\r\nISP PASSWORD: "); 
....................    read_ext_eeprom_string(EE_ISP_PASSWORD, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PASSWORD,str); 
....................  
....................    fprintf(USER,"\r\nISP PHONENUMBER: "); 
....................    read_ext_eeprom_string(EE_ISP_PHONENUMBER, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PHONENUMBER,str); 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
....................  
....................    reset_cpu(); 
.................... } 
.................... #elif STACK_USE_MAC 
.................... void ui_setup(void) { 
....................    char dhcp; 
....................    int8 i; 
....................    int16 addy; 
....................  
....................  #if STACK_USE_EEPROM 
....................  
....................    fprintf(USER,"\r\n\nMAC ADDRESS:"); 
02D48:  MOVLW  9C
02D4A:  MOVWF  FF6
02D4C:  MOVLW  04
02D4E:  MOVWF  FF7
02D50:  CALL   0D10
....................    addy=EE_NIC_MAC; 
02D54:  MOVLB  3
02D56:  CLRF   x80
02D58:  MOVLW  CD
02D5A:  MOVWF  x7F
....................    for(i=0;i<6;i++) { 
02D5C:  CLRF   x7E
02D5E:  MOVF   x7E,W
02D60:  SUBLW  05
02D62:  BNC   2DDA
....................      fprintf(USER, "\r\n  BYTE%U: ",i); 
02D64:  MOVLW  AC
02D66:  MOVWF  FF6
02D68:  MOVLW  04
02D6A:  MOVWF  FF7
02D6C:  MOVLW  08
02D6E:  MOVWF  x8D
02D70:  MOVLB  0
02D72:  CALL   1AD8
02D76:  MOVFF  37E,388
02D7A:  MOVLW  1B
02D7C:  MOVLB  3
02D7E:  MOVWF  x89
02D80:  MOVLB  0
02D82:  CALL   1B64
02D86:  MOVLW  3A
02D88:  BTFSS  F9E.4
02D8A:  BRA    2D88
02D8C:  MOVWF  FAD
02D8E:  MOVLW  20
02D90:  BTFSS  F9E.4
02D92:  BRA    2D90
02D94:  MOVWF  FAD
....................      dhcp=fgethex(read_ext_eeprom(addy)); 
02D96:  MOVFF  380,393
02D9A:  MOVFF  37F,392
02D9E:  CALL   0C16
02DA2:  MOVFF  01,381
02DA6:  MOVFF  01,382
02DAA:  BRA    2ACA
02DAC:  MOVFF  01,37D
....................      write_ext_eeprom(addy++,dhcp); 
02DB0:  MOVLB  3
02DB2:  MOVFF  380,03
02DB6:  MOVF   x7F,W
02DB8:  INCF   x7F,F
02DBA:  BTFSC  FD8.2
02DBC:  INCF   x80,F
02DBE:  MOVWF  x81
02DC0:  MOVFF  03,382
02DC4:  MOVFF  03,393
02DC8:  MOVWF  x92
02DCA:  MOVFF  37D,394
02DCE:  MOVLB  0
02DD0:  CALL   0D22
....................    } 
02DD4:  MOVLB  3
02DD6:  INCF   x7E,F
02DD8:  BRA    2D5E
....................  
....................  
....................    fprintf(USER,"\r\n\nUSE DHCP? (Y/N): "); 
02DDA:  MOVLW  BA
02DDC:  MOVWF  FF6
02DDE:  MOVLW  04
02DE0:  MOVWF  FF7
02DE2:  MOVLB  0
02DE4:  CALL   0D10
....................    do { 
....................       dhcp=fgetc(USER); 
02DE8:  BTFSS  F9E.5
02DEA:  BRA    2DE8
02DEC:  MOVFF  FAE,37D
02DF0:  MOVLB  3
....................       dhcp=toupper(dhcp); 
02DF2:  MOVF   x7D,W
02DF4:  SUBLW  60
02DF6:  BC    2E04
02DF8:  MOVF   x7D,W
02DFA:  SUBLW  7A
02DFC:  BNC   2E04
02DFE:  MOVF   x7D,W
02E00:  ANDLW  DF
02E02:  BRA    2E06
02E04:  MOVF   x7D,W
02E06:  MOVWF  x7D
....................    } while ((dhcp!='Y')&&(dhcp!='N')); 
02E08:  MOVF   x7D,W
02E0A:  SUBLW  59
02E0C:  BZ    2E1A
02E0E:  MOVF   x7D,W
02E10:  SUBLW  4E
02E12:  BTFSC  FD8.2
02E14:  BRA    2E1A
02E16:  MOVLB  0
02E18:  BRA    2DE8
....................    fputc(dhcp,USER); 
02E1A:  MOVF   x7D,W
02E1C:  MOVLB  0
02E1E:  RCALL  27DA
....................  
....................    if (dhcp=='N') { 
02E20:  MOVLB  3
02E22:  MOVF   x7D,W
02E24:  SUBLW  4E
02E26:  BNZ   2E82
....................       write_ext_eeprom(EE_NIC_DHCP,0); 
02E28:  CLRF   x93
02E2A:  MOVLW  C0
02E2C:  MOVWF  x92
02E2E:  CLRF   x94
02E30:  MOVLB  0
02E32:  CALL   0D22
....................  
....................       fprintf(USER,"\r\n\nIP ADDRESS:\r\n"); 
02E36:  MOVLW  D0
02E38:  MOVWF  FF6
02E3A:  MOVLW  04
02E3C:  MOVWF  FF7
02E3E:  CALL   0D10
....................       ui_ip_to_ee(EE_NIC_IP); 
02E42:  MOVLB  3
02E44:  CLRF   x82
02E46:  MOVLW  C5
02E48:  MOVWF  x81
02E4A:  MOVLB  0
02E4C:  RCALL  2C8C
....................  
....................       fprintf(USER,"\r\nGATEWAY:\r\n"); 
02E4E:  MOVLW  E2
02E50:  MOVWF  FF6
02E52:  MOVLW  04
02E54:  MOVWF  FF7
02E56:  CALL   0D10
....................       ui_ip_to_ee(EE_NIC_GATEWAY); 
02E5A:  MOVLB  3
02E5C:  CLRF   x82
02E5E:  MOVLW  C1
02E60:  MOVWF  x81
02E62:  MOVLB  0
02E64:  RCALL  2C8C
....................  
....................       fprintf(USER,"\r\nNETMASK:\r\n"); 
02E66:  MOVLW  F0
02E68:  MOVWF  FF6
02E6A:  MOVLW  04
02E6C:  MOVWF  FF7
02E6E:  CALL   0D10
....................       ui_ip_to_ee(EE_NIC_NETMASK); 
02E72:  MOVLB  3
02E74:  CLRF   x82
02E76:  MOVLW  C9
02E78:  MOVWF  x81
02E7A:  MOVLB  0
02E7C:  RCALL  2C8C
....................  
....................      #if STACK_USE_DNS 
....................       fprintf(USER, "\r\nDNS:\r\n"); 
....................       ui_ip_to_ee(EE_DNS); 
....................      #endif 
....................    } 
....................    else { 
02E7E:  BRA    2E92
02E80:  MOVLB  3
....................       write_ext_eeprom(EE_NIC_DHCP,1); 
02E82:  CLRF   x93
02E84:  MOVLW  C0
02E86:  MOVWF  x92
02E88:  MOVLW  01
02E8A:  MOVWF  x94
02E8C:  MOVLB  0
02E8E:  CALL   0D22
....................    } 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
02E92:  MOVLW  FE
02E94:  MOVWF  FF6
02E96:  MOVLW  04
02E98:  MOVWF  FF7
02E9A:  CALL   0D10
....................  
....................    reset_cpu(); 
02E9E:  RESET
.................... #endif 
.................... } 
02EA0:  GOTO   2EFC (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... void ui_mail_settings(void) { 
....................    int16 port; 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nSMTP HOST NAME: "); 
....................    read_ext_eeprom_string(EE_SMTP_HOSTNAME, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_HOSTNAME, str); 
....................  
....................    fprintf(USER,"\r\nSMTP PORT (USUALLY 25): "); 
....................    port=fget_long(read_ext_eeprom16(EE_SMTP_PORT)); 
....................    write_ext_eeprom16(EE_SMTP_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\nTo: "); 
....................    read_ext_eeprom_string(EE_SMTP_TO, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_TO,str); 
....................  
....................    fprintf(USER,"\r\nFrom: "); 
....................    read_ext_eeprom_string(EE_SMTP_FROM, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_FROM,str); 
....................  
....................    fprintf(USER,"\r\nSubject: "); 
....................    read_ext_eeprom_string(EE_SMTP_SUBJECT, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_SUBJECT,str); 
....................  
....................    fprintf(USER,"\r\nBody: "); 
....................    read_ext_eeprom_string(EE_SMTP_BODY, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_BODY,str); 
....................  
....................    init_smtp_settings(); 
.................... } 
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
.................... void ui_udp_settings(void) 
.................... { 
....................    int16 port; 
....................  
....................    fprintf(USER,"\r\n\nUDP Destination IP:\r\n"); 
....................    ui_ip_to_ee(EE_UDP_DEST_IP); 
....................  
....................    fprintf(USER,"\r\nUDP Destination Port (I will transmit to this port): "); 
....................    port=fget_long(read_ext_eeprom16(EE_UDP_DEST_PORT)); 
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\nUDP Source Port (I will listen to this port): "); 
....................    port=fget_long(read_ext_eeprom16(EE_UDP_SRC_PORT)); 
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
....................  
....................    reset_cpu(); 
.................... } 
.................... #endif 
....................  
.................... void ui_menu(void) { 
....................    fprintf(USER,"\r\n\nD) Display Settings"); 
*
01DBE:  MOVLW  20
01DC0:  MOVWF  FF6
01DC2:  MOVLW  05
01DC4:  MOVWF  FF7
01DC6:  CALL   0D10
....................    #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nC) Connect Modem / PPP"); 
....................    fprintf(USER,"\r\nH) Hangup Modem / PPP"); 
....................    fprintf(USER,"\r\nA) AT Command Mode"); 
....................    #endif 
....................    fprintf(USER,"\r\nS) Configure TCP/IP (Reset)"); 
01DCA:  MOVLW  38
01DCC:  MOVWF  FF6
01DCE:  MOVLW  05
01DD0:  MOVWF  FF7
01DD2:  CALL   0D10
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................    fprintf(USER,"\r\nM) Configure SMTP"); 
....................    fprintf(USER,"\r\nE) Send E-Mail"); 
....................    #endif 
....................    #ifdef CCS_UDP_EXAMPLE 
....................    fprintf(USER,"\r\nU) Configure UDP"); 
....................    #endif 
....................    fprintf(USER,"\r\nZ) Clear EEPROM (!!!)"); 
01DD6:  MOVLW  56
01DD8:  MOVWF  FF6
01DDA:  MOVLW  05
01DDC:  MOVWF  FF7
01DDE:  CALL   0D10
.................... } 
01DE2:  RETLW  00
....................  
.................... #if STACK_USE_PPP 
.................... void ATCommandMode(void) 
.................... { 
....................    char c; 
....................     
....................    fprintf(USER,"\r\n\nAT Command Mode\r\n(power cycle to stop)\r\n\n"); 
....................     
....................    while(TRUE) 
....................    { 
....................       restart_wdt(); 
....................       if (kbhit(USER))  
....................       { 
....................          c = fgetc(USER); 
....................          fputc(c, MODEM); 
....................       } 
....................       if (modem_kbhit) 
....................       { 
....................          c = modem_getb(); 
....................          fputc(c, USER); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... void ui_handle(void) 
.................... { 
....................    char c; 
....................     
....................    c=fgetc(USER); 
*
02EA4:  BTFSS  F9E.5
02EA6:  BRA    2EA4
02EA8:  MOVFF  FAE,37C
02EAC:  MOVLB  3
....................    c=toupper(c); 
02EAE:  MOVF   x7C,W
02EB0:  SUBLW  60
02EB2:  BC    2EC0
02EB4:  MOVF   x7C,W
02EB6:  SUBLW  7A
02EB8:  BNC   2EC0
02EBA:  MOVF   x7C,W
02EBC:  ANDLW  DF
02EBE:  BRA    2EC2
02EC0:  MOVF   x7C,W
02EC2:  MOVWF  x7C
....................     
....................    switch(c) {      
02EC4:  MOVF   x7C,W
02EC6:  XORLW  54
02EC8:  MOVLB  0
02ECA:  BZ    2EDA
02ECC:  XORLW  10
02ECE:  BZ    2EE0
02ED0:  XORLW  17
02ED2:  BZ    2EE6
02ED4:  XORLW  09
02ED6:  BZ    2EEA
02ED8:  BRA    2EFC
....................       #if STACK_USE_PPP 
....................       case 'H':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nHanging up\r\n"); 
....................                      ppp_init(); //ppp_init() will reset the PPP and the MODEM forcing a hangup 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nNot Connected\r\n"); 
....................                   } 
....................                   break; 
....................  
....................       case 'C':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nAlready connected!\r\n"); 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nConnecting\r\n"); 
....................                      picdem_ppp_connect(); 
....................                   } 
....................                   break; 
....................       case 'A':   ATCommandMode(); 
....................                   break; 
....................       #endif 
....................  
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................       case 'M':   ui_mail_settings(); 
....................                   break; 
....................  
....................       case 'E':   my_smtp_send(); 
....................                   fprintf(USER, "\r\n\nSending E-Mail.  Watch LCD for status.\r\n\n"); 
....................                   break; 
....................    #endif 
....................  
....................    #ifdef CCS_UDP_EXAMPLE 
....................       case 'U':   ui_udp_settings(); 
....................                   break; 
....................    #endif 
....................  
....................  
....................       case 'T':   hardware_test(); 
02EDA:  GOTO   22C4
....................                   break; 
02EDE:  BRA    2EFC
....................  
....................       case 'D':   ui_settings(); 
02EE0:  CALL   1C70
....................                   break; 
02EE4:  BRA    2EFC
....................  
....................       case 'S':   ui_setup(); 
02EE6:  BRA    2D48
....................                   break; 
02EE8:  BRA    2EFC
....................  
....................   #if STACK_USE_EEPROM 
....................       case 'Z':   clear_ee(); 
02EEA:  CALL   0DCC
....................                   fprintf(USER,"\r\nEEPROM Cleared\r\n"); 
02EEE:  MOVLW  6E
02EF0:  MOVWF  FF6
02EF2:  MOVLW  05
02EF4:  MOVWF  FF7
02EF6:  CALL   0D10
....................                   break; 
02EFA:  BRA    2EFC
....................   #endif 
....................    } 
....................    ui_menu(); 
02EFC:  CALL   1DBE
.................... } 
02F00:  GOTO   A88E (RETURN)
.................... #endif 
....................  
....................  
.................... /////***** WEB PAGES STORED INTO PROGRAM MEMORY *****///// 
....................  
.................... //The following escape characters are used: 
.................... //  %0 - AN0 
.................... //  %1 - AN1 
.................... //  %2 - BUTTON0 
.................... //  %3 - BUTTON1 
.................... //  %4 - Current LCD Message 
.................... //  %5 - CHECKED if LED1 is ON 
.................... //  %6 - CHECKED if LED1 is OFF 
.................... //  %7 - CHECKED if LED2 is ON 
.................... //  %8 - CHECKED if LED2 is OFF 
.................... //  %9 - Temperature (EWL ONLY) 
.................... //  %F - Message stack 
....................  
.................... //here is this examples / page 
.................... const char  HTML_INDEX_PAGE[]= 
.................... "<html><body bgcolor=#FFFFFF text=#000000> 
.................... <img src=\"http://www.ccsinfo.com/images/CCSlogotiny.gif\"> 
.................... <br/> 
.................... <h1>CCS HTTP/CGI EXAMPLE</h1> 
.................... <p><b><i>%F</i></b></p> 
.................... <form method=post> 
.................... <table border=0> 
.................... <tr><th>LCD:</th><td colspan=4><input type=\"text\" name=\"lcd\" size=20 maxlength=16 value=\"%4\"></td></tr> 
.................... <tr><th>LED1:</th><td><input type=\"radio\" name=\"led1\" value=1 %5></td><td>ON</td> 
....................    <td><input type=\"radio\" name=\"led1\" value=0 %6></td><td>OFF</td></tr> 
.................... <tr><th>LED2:</th><td><input type=\"radio\" name=\"led2\" value=1 %7></td><td>ON</td> 
....................    <td><input type=\"radio\" name=\"led2\" value=0 %8></td><td>OFF</td></tr> 
.................... </table> 
.................... <input type=\"hidden\" name=\"msgStack\" value=\"LCD/LEDs changed!\"> 
.................... <br/><input type=\"submit\"></form> 
.................... <p><a href=\"/analog\">Analog Readings</a></p> 
.................... </body></html>"; 
....................  
.................... const char  HTML_ANALOG_PAGE[]= 
.................... "<html><body bgcolor=#ffffff text=#000000> 
.................... <img src=\"http://www.ccsinfo.com/images/CCSlogotiny.gif\"> 
.................... <h1>PICNET ADC READINGS</h1> 
.................... <p>%0</p> 
.................... <br/>%1 
.................... <p>%2</p> 
.................... <br/>%3 
.................... <p>%9</p> 
.................... <p><a href=\"/\">Change LCD/LEDs</a></p> 
.................... </body></html>"; 
....................  
.................... /////***** END OF WEB PAGES STORED INTO PROGRAM MEMORY *****///// 
....................  
.................... char g_HTTPMessageStack[20]=""; 
.................... char g_HTTPLCDMessage[20]="CCS Webserver"; 
.................... int8 g_LEDState[2]={0,0}; 
....................  
.................... //this is a callback function to the HTTP stack.  see http.c 
.................... //this demo provides to web "pages", an index (/) and an about page (/about) 
.................... int32 http_get_page(char *file_str) 
.................... { 
....................    int32 file_loc=0; 
*
07256:  MOVLB  3
07258:  CLRF   x8E
0725A:  CLRF   x8F
0725C:  CLRF   x90
0725E:  CLRF   x91
....................    static char index[]="/"; 
....................    static char about[]="/analog"; 
....................  
....................    if (stricmp(file_str,index)==0) 
07260:  MOVFF  38D,3A5
07264:  MOVFF  38C,3A4
07268:  MOVLW  03
0726A:  MOVWF  xA7
0726C:  MOVLW  5B
0726E:  MOVWF  xA6
07270:  MOVLB  0
07272:  RCALL  714E
07274:  MOVF   01,F
07276:  BNZ   7296
....................       file_loc=label_address(HTML_INDEX_PAGE); 
07278:  MOVLW  00
0727A:  MOVWF  02
0727C:  MOVLW  05
0727E:  MOVWF  01
07280:  MOVLW  82
07282:  CLRF   03
07284:  MOVFF  03,391
07288:  MOVFF  02,390
0728C:  MOVFF  01,38F
07290:  MOVFF  FE8,38E
....................  
....................    else if (stricmp(file_str,about)==0) 
07294:  BRA    72CC
07296:  MOVFF  38D,3A5
0729A:  MOVFF  38C,3A4
0729E:  MOVLW  03
072A0:  MOVLB  3
072A2:  MOVWF  xA7
072A4:  MOVLW  5D
072A6:  MOVWF  xA6
072A8:  MOVLB  0
072AA:  RCALL  714E
072AC:  MOVF   01,F
072AE:  BNZ   72CC
....................       file_loc=label_address(HTML_ANALOG_PAGE); 
072B0:  MOVLW  00
072B2:  MOVWF  02
072B4:  MOVLW  08
072B6:  MOVWF  01
072B8:  MOVLW  9C
072BA:  CLRF   03
072BC:  MOVFF  03,391
072C0:  MOVFF  02,390
072C4:  MOVFF  01,38F
072C8:  MOVFF  FE8,38E
....................  
....................    return(file_loc); 
072CC:  MOVFF  38E,00
072D0:  MOVFF  38F,01
072D4:  MOVFF  390,02
072D8:  MOVFF  391,03
.................... } 
072DC:  GOTO   8B64 (RETURN)
....................  
.................... //this isn't a required callback, this is an application function being 
.................... //used by http_format_char. 
.................... int http_format_char_checked(int8 flag, char *str) 
.................... { 
....................    int len=0; 
*
080DA:  MOVLB  3
080DC:  CLRF   xC1
....................  
....................    if (flag) 
080DE:  MOVF   xBE,F
080E0:  BZ    80FE
....................    { 
....................       sprintf(str,"checked=\"checked\""); 
080E2:  MOVFF  3C0,330
080E6:  MOVFF  3BF,32F
080EA:  MOVLW  8A
080EC:  MOVWF  FF6
080EE:  MOVLW  09
080F0:  MOVWF  FF7
080F2:  MOVLB  0
080F4:  CALL   1F46
....................       len = 7; 
080F8:  MOVLW  07
080FA:  MOVLB  3
080FC:  MOVWF  xC1
....................    } 
....................  
....................    return(len); 
080FE:  MOVFF  3C1,01
.................... } 
08102:  MOVLB  0
08104:  RETLW  00
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... //The following escape characters are used: 
.................... //  %0 - AN0 
.................... //  %1 - AN1 
.................... //  %2 - BUTTON0 
.................... //  %3 - BUTTON1 
.................... //  %4 - Current LCD Message 
.................... //  %5 - CHECKED if LED1 is ON 
.................... //  %6 - CHECKED if LED1 is OFF 
.................... //  %7 - CHECKED if LED2 is ON 
.................... //  %8 - CHECKED if LED2 is OFF 
.................... //  %F - Message stack 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) { 
....................    char new_str[25]; 
....................    int8 len=0; 
08106:  MOVLB  3
08108:  CLRF   xBB
....................    int8 i; 
....................  
....................   switch(id) { 
0810A:  MOVF   x9E,W
0810C:  XORLW  30
0810E:  MOVLB  0
08110:  BZ    813C
08112:  XORLW  02
08114:  BZ    81BE
08116:  XORLW  06
08118:  BTFSC  FD8.2
0811A:  BRA    822A
0811C:  XORLW  01
0811E:  BTFSC  FD8.2
08120:  BRA    825E
08122:  XORLW  03
08124:  BTFSC  FD8.2
08126:  BRA    8276
08128:  XORLW  01
0812A:  BTFSC  FD8.2
0812C:  BRA    8296
0812E:  XORLW  0F
08130:  BTFSC  FD8.2
08132:  BRA    82AE
08134:  XORLW  7E
08136:  BTFSC  FD8.2
08138:  BRA    82CE
0813A:  BRA    8308
.................... #if defined(ADC_CHAN_0)   
....................       case '0': 
....................          set_adc_channel(ADC_CHAN_0); 
0813C:  MOVLW  00
0813E:  MOVWF  01
08140:  MOVF   FC2,W
08142:  ANDLW  C3
08144:  IORWF  01,W
08146:  MOVWF  FC2
....................          delay_us(100); 
08148:  MOVLW  64
0814A:  MOVLB  3
0814C:  MOVWF  xBD
0814E:  MOVLB  0
08150:  CALL   1EAC
....................          i=read_adc(); 
08154:  BSF    FC2.1
08156:  BTFSC  FC2.1
08158:  BRA    8156
0815A:  MOVFF  FC4,3BC
0815E:  MOVLB  3
....................          sprintf(new_str,"<B>AN%U = </B>0x%X",ADC_CHAN_0,i); 
08160:  MOVLW  03
08162:  MOVWF  x30
08164:  MOVLW  A2
08166:  MOVWF  x2F
08168:  MOVLW  9C
0816A:  MOVWF  FF6
0816C:  MOVLW  09
0816E:  MOVWF  FF7
08170:  MOVLW  05
08172:  MOVWF  xBD
08174:  MOVLB  0
08176:  RCALL  80B0
08178:  MOVLB  3
0817A:  CLRF   xBD
0817C:  MOVLW  1B
0817E:  MOVWF  xBE
08180:  MOVLB  0
08182:  CALL   2B18
08186:  MOVLW  A3
08188:  MOVWF  FF6
0818A:  MOVLW  09
0818C:  MOVWF  FF7
0818E:  MOVLW  09
08190:  MOVLB  3
08192:  MOVWF  xBD
08194:  MOVLB  0
08196:  RCALL  80B0
08198:  MOVFF  3BC,3BD
0819C:  MOVLW  37
0819E:  MOVLB  3
081A0:  MOVWF  xBE
081A2:  MOVLB  0
081A4:  CALL   2790
....................          len=strlen(new_str); 
081A8:  MOVLW  03
081AA:  MOVLB  3
081AC:  MOVWF  xBE
081AE:  MOVLW  A2
081B0:  MOVWF  xBD
081B2:  MOVLB  0
081B4:  CALL   6F5E
081B8:  MOVFF  01,3BB
....................          break; 
081BC:  BRA    8308
.................... #endif 
.................... #if defined(ADC_CHAN_1) 
....................       case '1': 
....................          set_adc_channel(ADC_CHAN_1); 
....................          delay_us(100); 
....................          i=read_adc(); 
....................          sprintf(new_str,"<B>AN%U = </B>0x%X",ADC_CHAN_1,i); 
....................          len=strlen(new_str); 
....................          break; 
.................... #endif 
.................... #if defined(USER_BUTTON1) 
....................       case '2': 
....................          sprintf(new_str,"<B>BTN1 = </B>"); 
081BE:  MOVLW  03
081C0:  MOVLB  3
081C2:  MOVWF  x30
081C4:  MOVLW  A2
081C6:  MOVWF  x2F
081C8:  MOVLW  B0
081CA:  MOVWF  FF6
081CC:  MOVLW  09
081CE:  MOVWF  FF7
081D0:  MOVLB  0
081D2:  CALL   1F46
....................          if (!BUTTON_PRESSED(USER_BUTTON1)) 
081D6:  BTFSS  F80.4
081D8:  BRA    81FC
....................             sprintf(&new_str[14], "UP"); 
081DA:  MOVLW  03
081DC:  MOVLB  3
081DE:  MOVWF  x30
081E0:  MOVLW  B0
081E2:  MOVWF  x2F
081E4:  MOVLW  55
081E6:  MOVWF  xC2
081E8:  MOVLB  0
081EA:  CALL   1F26
081EE:  MOVLW  50
081F0:  MOVLB  3
081F2:  MOVWF  xC2
081F4:  MOVLB  0
081F6:  CALL   1F26
....................          else 
081FA:  BRA    8214
....................             sprintf(&new_str[14], "DOWN"); 
081FC:  MOVLW  03
081FE:  MOVLB  3
08200:  MOVWF  x30
08202:  MOVLW  B0
08204:  MOVWF  x2F
08206:  MOVLW  C0
08208:  MOVWF  FF6
0820A:  MOVLW  09
0820C:  MOVWF  FF7
0820E:  MOVLB  0
08210:  CALL   1F46
....................          len=strlen(new_str); 
08214:  MOVLW  03
08216:  MOVLB  3
08218:  MOVWF  xBE
0821A:  MOVLW  A2
0821C:  MOVWF  xBD
0821E:  MOVLB  0
08220:  CALL   6F5E
08224:  MOVFF  01,3BB
....................          break; 
08228:  BRA    8308
.................... #endif 
.................... #if defined(USER_BUTTON2) 
....................       case '3': 
....................          sprintf(new_str,"<B>BTN2 = </B>"); 
....................          if (!BUTTON_PRESSED(USER_BUTTON2)) 
....................             sprintf(&new_str[14], "UP"); 
....................          else 
....................             sprintf(&new_str[14], "DOWN"); 
....................          len=strlen(new_str); 
....................          break; 
.................... #endif 
....................  
....................       case '4': 
....................          strncpy(new_str, g_HTTPLCDMessage, sizeof(new_str)); 
0822A:  MOVLW  03
0822C:  MOVLB  3
0822E:  MOVWF  xBE
08230:  MOVLW  A2
08232:  MOVWF  xBD
08234:  MOVLW  03
08236:  MOVWF  xC0
08238:  MOVLW  45
0823A:  MOVWF  xBF
0823C:  MOVLW  19
0823E:  MOVWF  xC1
08240:  MOVLB  0
08242:  CALL   74D2
....................          new_str[sizeof(new_str)-1] = 0; 
08246:  MOVLB  3
08248:  CLRF   xBA
....................          len = strlen(new_str); 
0824A:  MOVLW  03
0824C:  MOVWF  xBE
0824E:  MOVLW  A2
08250:  MOVWF  xBD
08252:  MOVLB  0
08254:  CALL   6F5E
08258:  MOVFF  01,3BB
....................          break; 
0825C:  BRA    8308
....................  
....................       case '5': 
....................          len = http_format_char_checked(g_LEDState[0], new_str); 
0825E:  MOVFF  359,3BE
08262:  MOVLW  03
08264:  MOVLB  3
08266:  MOVWF  xC0
08268:  MOVLW  A2
0826A:  MOVWF  xBF
0826C:  MOVLB  0
0826E:  RCALL  80DA
08270:  MOVFF  01,3BB
....................          break; 
08274:  BRA    8308
....................  
....................       case '6': 
....................          len = http_format_char_checked(!g_LEDState[0], new_str); 
08276:  MOVLB  3
08278:  MOVF   x59,F
0827A:  BZ    8280
0827C:  MOVLW  00
0827E:  BRA    8282
08280:  MOVLW  01
08282:  MOVWF  xBE
08284:  MOVLW  03
08286:  MOVWF  xC0
08288:  MOVLW  A2
0828A:  MOVWF  xBF
0828C:  MOVLB  0
0828E:  RCALL  80DA
08290:  MOVFF  01,3BB
....................          break; 
08294:  BRA    8308
....................  
....................       case '7': 
....................          len = http_format_char_checked(g_LEDState[1], new_str); 
08296:  MOVFF  35A,3BE
0829A:  MOVLW  03
0829C:  MOVLB  3
0829E:  MOVWF  xC0
082A0:  MOVLW  A2
082A2:  MOVWF  xBF
082A4:  MOVLB  0
082A6:  RCALL  80DA
082A8:  MOVFF  01,3BB
....................          break; 
082AC:  BRA    8308
....................  
....................       case '8': 
....................          len = http_format_char_checked(!g_LEDState[1], new_str); 
082AE:  MOVLB  3
082B0:  MOVF   x5A,F
082B2:  BZ    82B8
082B4:  MOVLW  00
082B6:  BRA    82BA
082B8:  MOVLW  01
082BA:  MOVWF  xBE
082BC:  MOVLW  03
082BE:  MOVWF  xC0
082C0:  MOVLW  A2
082C2:  MOVWF  xBF
082C4:  MOVLB  0
082C6:  RCALL  80DA
082C8:  MOVFF  01,3BB
....................          break; 
082CC:  BRA    8308
....................  
.................... #if STACK_USE_TEMP 
....................       case '9': 
....................          sprintf(new_str, "Temp: %6.2w&ordm F", read_full_temp()); 
....................          len=strlen(new_str); 
....................          new_str[len]=0; 
....................          break; 
.................... #endif          
....................       case 'F': 
....................          strncpy(new_str, g_HTTPMessageStack, sizeof(new_str)); 
082CE:  MOVLW  03
082D0:  MOVLB  3
082D2:  MOVWF  xBE
082D4:  MOVLW  A2
082D6:  MOVWF  xBD
082D8:  MOVLW  03
082DA:  MOVWF  xC0
082DC:  MOVLW  31
082DE:  MOVWF  xBF
082E0:  MOVLW  19
082E2:  MOVWF  xC1
082E4:  MOVLB  0
082E6:  CALL   74D2
....................          new_str[sizeof(new_str)-1] = 0; 
082EA:  MOVLB  3
082EC:  CLRF   xBA
....................          len = strlen(new_str); 
082EE:  MOVLW  03
082F0:  MOVWF  xBE
082F2:  MOVLW  A2
082F4:  MOVWF  xBD
082F6:  MOVLB  0
082F8:  CALL   6F5E
082FC:  MOVFF  01,3BB
....................          g_HTTPMessageStack[0] = 0; 
08300:  MOVLB  3
08302:  CLRF   x31
....................          break; 
08304:  MOVLB  0
08306:  BRA    8308
....................    } 
....................  
....................    if (len){ 
08308:  MOVLB  3
0830A:  MOVF   xBB,F
0830C:  BZ    832C
....................       strncpy(str, new_str, max_ret); 
0830E:  MOVFF  3A0,3BE
08312:  MOVFF  39F,3BD
08316:  MOVLW  03
08318:  MOVWF  xC0
0831A:  MOVLW  A2
0831C:  MOVWF  xBF
0831E:  MOVFF  3A1,3C1
08322:  MOVLB  0
08324:  CALL   74D2
....................    }else 
08328:  BRA    8336
0832A:  MOVLB  3
....................       *str=0; 
0832C:  MOVFF  39F,FE9
08330:  MOVFF  3A0,FEA
08334:  CLRF   FEF
....................  
....................    return(len); 
08336:  MOVLB  3
08338:  MOVFF  3BB,01
.................... } 
0833C:  MOVLB  0
0833E:  GOTO   85DE (RETURN)
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... //in this example it verifies that "pwd" is "master", if it is 
.................... //then it sets led1 and led2 ("led1" and "led2") based on their value 
.................... //and changes the lcd screen ("lcd"). 
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
....................    static char led1_key[]="led1"; 
....................    static char led2_key[]="led2"; 
....................    static char lcd_key[]="lcd"; 
....................    static char msgStack_key[]="msgStack"; 
....................    int8 v; 
....................  
.................... // #if defined(USER_LED1) 
....................    if (stricmp(key,led1_key)==0) { 
*
07578:  MOVFF  3A0,3A5
0757C:  MOVFF  39F,3A4
07580:  MOVLW  03
07582:  MOVLB  3
07584:  MOVWF  xA7
07586:  MOVLW  65
07588:  MOVWF  xA6
0758A:  MOVLB  0
0758C:  RCALL  714E
0758E:  MOVF   01,F
07590:  BNZ   75A4
....................       v=atoi(val); 
07592:  MOVFF  3A2,3A5
07596:  MOVFF  3A1,3A4
0759A:  RCALL  7330
0759C:  MOVFF  01,3A3
....................       g_LEDState[0]=v; 
075A0:  MOVFF  3A3,359
....................    } 
.................... // #endif 
....................  
.................... // #if defined(USER_LED2) 
....................    if (stricmp(key,led2_key)==0) { 
075A4:  MOVFF  3A0,3A5
075A8:  MOVFF  39F,3A4
075AC:  MOVLW  03
075AE:  MOVLB  3
075B0:  MOVWF  xA7
075B2:  MOVLW  6A
075B4:  MOVWF  xA6
075B6:  MOVLB  0
075B8:  RCALL  714E
075BA:  MOVF   01,F
075BC:  BNZ   75D0
....................       v=atoi(val); 
075BE:  MOVFF  3A2,3A5
075C2:  MOVFF  3A1,3A4
075C6:  RCALL  7330
075C8:  MOVFF  01,3A3
....................       g_LEDState[1]=v; 
075CC:  MOVFF  3A3,35A
....................    } 
.................... // #endif 
....................  
....................    if (stricmp(key, msgStack_key)==0) 
075D0:  MOVFF  3A0,3A5
075D4:  MOVFF  39F,3A4
075D8:  MOVLW  03
075DA:  MOVLB  3
075DC:  MOVWF  xA7
075DE:  MOVLW  73
075E0:  MOVWF  xA6
075E2:  MOVLB  0
075E4:  RCALL  714E
075E6:  MOVF   01,F
075E8:  BNZ   7608
....................    { 
....................       strncpy(g_HTTPMessageStack, val, sizeof(g_HTTPMessageStack)); 
075EA:  MOVLW  03
075EC:  MOVLB  3
075EE:  MOVWF  xBE
075F0:  MOVLW  31
075F2:  MOVWF  xBD
075F4:  MOVFF  3A2,3C0
075F8:  MOVFF  3A1,3BF
075FC:  MOVLW  14
075FE:  MOVWF  xC1
07600:  MOVLB  0
07602:  RCALL  74D2
....................       g_HTTPMessageStack[sizeof(g_HTTPMessageStack)-1] = 0; 
07604:  MOVLB  3
07606:  CLRF   x44
....................    } 
....................  
....................    if (stricmp(key,lcd_key)==0) { 
07608:  MOVFF  3A0,3A5
0760C:  MOVFF  39F,3A4
07610:  MOVLW  03
07612:  MOVLB  3
07614:  MOVWF  xA7
07616:  MOVLW  6F
07618:  MOVWF  xA6
0761A:  MOVLB  0
0761C:  RCALL  714E
0761E:  MOVF   01,F
07620:  BNZ   7654
....................       strncpy(g_HTTPLCDMessage, val, sizeof(g_HTTPLCDMessage)); 
07622:  MOVLW  03
07624:  MOVLB  3
07626:  MOVWF  xBE
07628:  MOVLW  45
0762A:  MOVWF  xBD
0762C:  MOVFF  3A2,3C0
07630:  MOVFF  3A1,3BF
07634:  MOVLW  14
07636:  MOVWF  xC1
07638:  MOVLB  0
0763A:  RCALL  74D2
....................       g_HTTPLCDMessage[sizeof(g_HTTPLCDMessage)-1] = 0; 
0763C:  MOVLB  3
0763E:  CLRF   x58
.................... #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\f%s",val); 
07640:  MOVLW  0C
07642:  MOVWF  xA6
07644:  MOVLB  0
07646:  CALL   0CA4
0764A:  MOVFF  3A2,FEA
0764E:  MOVFF  3A1,FE9
07652:  BRA    7550
.................... #endif 
....................    } 
.................... } 
07654:  GOTO   76BE (RETURN)
....................  
.................... void splash(void) { 
....................   #IF STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\fCCS Webserver"); 
*
01DE4:  MOVLW  C6
01DE6:  MOVWF  FF6
01DE8:  MOVLW  09
01DEA:  MOVWF  FF7
01DEC:  CALL   0D00
....................   #ENDIF 
....................  #if STACK_USE_ANNOUNCE 
....................    InitAnnounce(" - EX_ST_WEBSERVER"); 
01DF0:  MOVLW  D6
01DF2:  MOVWF  FF6
01DF4:  MOVLW  09
01DF6:  MOVWF  FF7
01DF8:  CALL   0FE2
....................  #endif 
....................  #if STACK_USE_SERIAL 
....................    fprintf(USER,"\r\n\r\nCCS ex_st_webserver\r\n"); 
01DFC:  MOVLW  EA
01DFE:  MOVWF  FF6
01E00:  MOVLW  09
01E02:  MOVWF  FF7
01E04:  CALL   0D10
....................    ui_settings(); 
01E08:  RCALL  1C70
....................    ui_menu(); 
01E0A:  RCALL  1DBE
....................  #endif 
.................... } 
01E0C:  GOTO   A884 (RETURN)
....................  
.................... void main(void) 
.................... { 
*
0A37A:  CLRF   FF8
0A37C:  BCF    FD0.7
0A37E:  BSF    07.7
0A380:  CLRF   FEA
0A382:  CLRF   FE9
0A384:  BSF    FB8.3
0A386:  MOVLW  11
0A388:  MOVWF  FAF
0A38A:  MOVLW  04
0A38C:  MOVWF  FB0
0A38E:  MOVLW  A6
0A390:  MOVWF  FAC
0A392:  MOVLW  90
0A394:  MOVWF  FAB
0A396:  MOVF   FC1,W
0A398:  ANDLW  C0
0A39A:  IORLW  0F
0A39C:  MOVWF  FC1
0A39E:  MOVLW  07
0A3A0:  MOVWF  FB4
0A3A2:  CLRF   47
0A3A4:  CLRF   48
0A3A6:  CLRF   4E
0A3A8:  CLRF   4F
0A3AA:  CLRF   50
0A3AC:  CLRF   51
0A3AE:  CLRF   x85
0A3B0:  CLRF   x86
0A3B2:  CLRF   x87
0A3B4:  CLRF   x88
0A3B6:  CLRF   x89
0A3B8:  CLRF   x8A
0A3BA:  MOVLW  04
0A3BC:  MOVWF  x8B
0A3BE:  MOVLW  FF
0A3C0:  MOVLB  1
0A3C2:  MOVWF  x42
0A3C4:  CLRF   x43
0A3C6:  CLRF   x44
0A3C8:  CLRF   x45
0A3CA:  CLRF   x46
0A3CC:  CLRF   x47
0A3CE:  CLRF   x48
0A3D0:  CLRF   x49
0A3D2:  CLRF   x4A
0A3D4:  CLRF   x4B
0A3D6:  CLRF   x4C
0A3D8:  CLRF   x4D
0A3DA:  CLRF   x4E
0A3DC:  CLRF   x4F
0A3DE:  CLRF   x50
0A3E0:  CLRF   x51
0A3E2:  CLRF   x52
0A3E4:  CLRF   x53
0A3E6:  CLRF   x54
0A3E8:  CLRF   x55
0A3EA:  CLRF   x56
0A3EC:  CLRF   x57
0A3EE:  CLRF   x58
0A3F0:  CLRF   x59
0A3F2:  CLRF   x5A
0A3F4:  BCF    56.1
0A3F6:  CLRF   x5B
0A3F8:  CLRF   x5C
0A3FA:  CLRF   x5D
0A3FC:  CLRF   x5E
0A3FE:  CLRF   x5F
0A400:  CLRF   x60
0A402:  CLRF   x61
0A404:  CLRF   x62
0A406:  CLRF   x63
0A408:  CLRF   x64
0A40A:  CLRF   x66
0A40C:  MOVLW  FE
0A40E:  MOVWF  x65
0A410:  CLRF   x66
0A412:  MOVLW  01
0A414:  MOVWF  x67
0A416:  CLRF   x6F
0A418:  CLRF   x70
0A41A:  CLRF   x71
0A41C:  CLRF   x72
0A41E:  CLRF   x73
0A420:  CLRF   x74
0A422:  CLRF   x75
0A424:  CLRF   x76
0A426:  CLRF   x77
0A428:  CLRF   x78
0A42A:  CLRF   x79
0A42C:  CLRF   x7A
0A42E:  CLRF   x7B
0A430:  CLRF   x7C
0A432:  CLRF   x7D
0A434:  CLRF   x7E
0A436:  CLRF   x7F
0A438:  CLRF   x80
0A43A:  CLRF   x81
0A43C:  CLRF   x82
0A43E:  CLRF   x83
0A440:  CLRF   x84
0A442:  CLRF   x85
0A444:  CLRF   x86
0A446:  CLRF   x87
0A448:  CLRF   x88
0A44A:  CLRF   x89
0A44C:  CLRF   x8A
0A44E:  CLRF   x8B
0A450:  CLRF   x8C
0A452:  CLRF   x8D
0A454:  CLRF   x8E
0A456:  CLRF   x8F
0A458:  CLRF   x90
0A45A:  CLRF   x91
0A45C:  CLRF   x92
0A45E:  CLRF   x93
0A460:  CLRF   x94
0A462:  CLRF   x95
0A464:  CLRF   x96
0A466:  CLRF   x97
0A468:  MOVLW  20
0A46A:  MOVWF  x98
0A46C:  CLRF   x99
0A46E:  MOVLW  3F
0A470:  MOVWF  x9A
0A472:  CLRF   x9B
0A474:  MOVLW  47
0A476:  MOVWF  x9C
0A478:  MOVLW  45
0A47A:  MOVWF  x9D
0A47C:  MOVLW  54
0A47E:  MOVWF  x9E
0A480:  CLRF   x9F
0A482:  MOVLW  50
0A484:  MOVWF  xA0
0A486:  MOVLW  4F
0A488:  MOVWF  xA1
0A48A:  MOVLW  53
0A48C:  MOVWF  xA2
0A48E:  MOVLW  54
0A490:  MOVWF  xA3
0A492:  CLRF   xA4
0A494:  MOVLW  43
0A496:  MOVWF  xA5
0A498:  MOVLW  6F
0A49A:  MOVWF  xA6
0A49C:  MOVLW  6E
0A49E:  MOVWF  xA7
0A4A0:  MOVLW  74
0A4A2:  MOVWF  xA8
0A4A4:  MOVLW  65
0A4A6:  MOVWF  xA9
0A4A8:  MOVLW  6E
0A4AA:  MOVWF  xAA
0A4AC:  MOVLW  74
0A4AE:  MOVWF  xAB
0A4B0:  MOVLW  2D
0A4B2:  MOVWF  xAC
0A4B4:  MOVLW  4C
0A4B6:  MOVWF  xAD
0A4B8:  MOVLW  65
0A4BA:  MOVWF  xAE
0A4BC:  MOVLW  6E
0A4BE:  MOVWF  xAF
0A4C0:  MOVLW  67
0A4C2:  MOVWF  xB0
0A4C4:  MOVLW  74
0A4C6:  MOVWF  xB1
0A4C8:  MOVLW  68
0A4CA:  MOVWF  xB2
0A4CC:  MOVLW  3A
0A4CE:  MOVWF  xB3
0A4D0:  CLRF   xB4
0A4D2:  CLRF   xB5
0A4D4:  CLRF   xB6
0A4D6:  CLRF   xB7
0A4D8:  CLRF   xB8
0A4DA:  CLRF   xB9
0A4DC:  CLRF   xBA
0A4DE:  CLRF   xBB
0A4E0:  CLRF   xBC
0A4E2:  CLRF   xBD
0A4E4:  CLRF   xBE
0A4E6:  CLRF   xBF
0A4E8:  CLRF   xC0
0A4EA:  CLRF   xC1
0A4EC:  CLRF   xC2
0A4EE:  CLRF   xC3
0A4F0:  CLRF   xC4
0A4F2:  CLRF   xC5
0A4F4:  CLRF   xC6
0A4F6:  CLRF   xC7
0A4F8:  CLRF   xC8
0A4FA:  CLRF   xC9
0A4FC:  CLRF   xCA
0A4FE:  CLRF   xCB
0A500:  CLRF   xCC
0A502:  CLRF   xCD
0A504:  CLRF   xCE
0A506:  CLRF   xCF
0A508:  CLRF   xD0
0A50A:  CLRF   xD1
0A50C:  CLRF   xD2
0A50E:  CLRF   xD3
0A510:  CLRF   xD4
0A512:  CLRF   xD5
0A514:  CLRF   xD6
0A516:  CLRF   xD7
0A518:  CLRF   xD8
0A51A:  CLRF   xD9
0A51C:  CLRF   xDA
0A51E:  CLRF   xDB
0A520:  CLRF   xDC
0A522:  CLRF   xDD
0A524:  CLRF   xDE
0A526:  CLRF   xDF
0A528:  CLRF   xE0
0A52A:  CLRF   xE1
0A52C:  CLRF   xE2
0A52E:  CLRF   xE3
0A530:  CLRF   xE4
0A532:  CLRF   xE5
0A534:  CLRF   xE6
0A536:  CLRF   xE7
0A538:  CLRF   xE8
0A53A:  CLRF   xE9
0A53C:  CLRF   xEA
0A53E:  CLRF   xEB
0A540:  CLRF   xEC
0A542:  CLRF   xED
0A544:  CLRF   xEE
0A546:  CLRF   xEF
0A548:  CLRF   xF0
0A54A:  CLRF   xF1
0A54C:  CLRF   xF2
0A54E:  CLRF   xF3
0A550:  CLRF   xF4
0A552:  CLRF   xF5
0A554:  CLRF   xF6
0A556:  CLRF   xF7
0A558:  CLRF   xF8
0A55A:  CLRF   xF9
0A55C:  CLRF   xFA
0A55E:  CLRF   xFB
0A560:  CLRF   xFC
0A562:  CLRF   xFD
0A564:  CLRF   xFE
0A566:  CLRF   xFF
0A568:  MOVLB  2
0A56A:  CLRF   x00
0A56C:  CLRF   x01
0A56E:  CLRF   x02
0A570:  CLRF   x03
0A572:  CLRF   x04
0A574:  CLRF   x05
0A576:  CLRF   x06
0A578:  CLRF   x07
0A57A:  CLRF   x08
0A57C:  CLRF   x09
0A57E:  CLRF   x0A
0A580:  CLRF   x0B
0A582:  CLRF   x0C
0A584:  CLRF   x0D
0A586:  CLRF   x0E
0A588:  CLRF   x0F
0A58A:  CLRF   x10
0A58C:  CLRF   x11
0A58E:  CLRF   x12
0A590:  CLRF   x13
0A592:  CLRF   x14
0A594:  CLRF   x15
0A596:  CLRF   x16
0A598:  CLRF   x17
0A59A:  CLRF   x18
0A59C:  CLRF   x19
0A59E:  CLRF   x1A
0A5A0:  CLRF   x1B
0A5A2:  CLRF   x1C
0A5A4:  CLRF   x1D
0A5A6:  CLRF   x1E
0A5A8:  CLRF   x1F
0A5AA:  CLRF   x20
0A5AC:  CLRF   x21
0A5AE:  CLRF   x22
0A5B0:  CLRF   x23
0A5B2:  CLRF   x24
0A5B4:  CLRF   x25
0A5B6:  CLRF   x26
0A5B8:  CLRF   x27
0A5BA:  CLRF   x28
0A5BC:  CLRF   x29
0A5BE:  CLRF   x2A
0A5C0:  CLRF   x2B
0A5C2:  CLRF   x2C
0A5C4:  CLRF   x2D
0A5C6:  CLRF   x2E
0A5C8:  CLRF   x2F
0A5CA:  CLRF   x30
0A5CC:  CLRF   x31
0A5CE:  CLRF   x32
0A5D0:  CLRF   x33
0A5D2:  CLRF   x34
0A5D4:  CLRF   x35
0A5D6:  CLRF   x36
0A5D8:  CLRF   x37
0A5DA:  CLRF   x38
0A5DC:  CLRF   x39
0A5DE:  CLRF   x3A
0A5E0:  CLRF   x3B
0A5E2:  CLRF   x3C
0A5E4:  CLRF   x3D
0A5E6:  CLRF   x3E
0A5E8:  CLRF   x3F
0A5EA:  CLRF   x40
0A5EC:  CLRF   x41
0A5EE:  CLRF   x42
0A5F0:  CLRF   x43
0A5F2:  CLRF   x44
0A5F4:  CLRF   x45
0A5F6:  CLRF   x46
0A5F8:  CLRF   x47
0A5FA:  CLRF   x48
0A5FC:  CLRF   x49
0A5FE:  CLRF   x4A
0A600:  CLRF   x4B
0A602:  CLRF   x4C
0A604:  CLRF   x4D
0A606:  CLRF   x4E
0A608:  CLRF   x4F
0A60A:  CLRF   x50
0A60C:  CLRF   x51
0A60E:  CLRF   x52
0A610:  CLRF   x53
0A612:  CLRF   x54
0A614:  CLRF   x55
0A616:  CLRF   x56
0A618:  CLRF   x57
0A61A:  CLRF   x58
0A61C:  CLRF   x59
0A61E:  CLRF   x5A
0A620:  CLRF   x5B
0A622:  CLRF   x5C
0A624:  CLRF   x5D
0A626:  CLRF   x5E
0A628:  CLRF   x5F
0A62A:  CLRF   x60
0A62C:  CLRF   x61
0A62E:  CLRF   x62
0A630:  CLRF   x63
0A632:  CLRF   x64
0A634:  CLRF   x65
0A636:  CLRF   x66
0A638:  CLRF   x67
0A63A:  CLRF   x68
0A63C:  CLRF   x69
0A63E:  CLRF   x6A
0A640:  CLRF   x6B
0A642:  CLRF   x6C
0A644:  CLRF   x6D
0A646:  CLRF   x6E
0A648:  CLRF   x6F
0A64A:  CLRF   x70
0A64C:  CLRF   x71
0A64E:  CLRF   x72
0A650:  CLRF   x73
0A652:  CLRF   x74
0A654:  CLRF   x75
0A656:  CLRF   x76
0A658:  CLRF   x77
0A65A:  CLRF   x78
0A65C:  CLRF   x79
0A65E:  CLRF   x7A
0A660:  CLRF   x7B
0A662:  CLRF   x7C
0A664:  CLRF   x7D
0A666:  CLRF   x7E
0A668:  CLRF   x7F
0A66A:  CLRF   x80
0A66C:  CLRF   x81
0A66E:  CLRF   x82
0A670:  CLRF   x83
0A672:  CLRF   x84
0A674:  CLRF   x85
0A676:  CLRF   x86
0A678:  CLRF   x87
0A67A:  CLRF   x88
0A67C:  CLRF   x89
0A67E:  CLRF   x8A
0A680:  CLRF   x8B
0A682:  CLRF   x8C
0A684:  CLRF   x8D
0A686:  CLRF   x8E
0A688:  CLRF   x8F
0A68A:  CLRF   x90
0A68C:  CLRF   x91
0A68E:  CLRF   x92
0A690:  CLRF   x93
0A692:  CLRF   x94
0A694:  CLRF   x95
0A696:  CLRF   x96
0A698:  CLRF   x97
0A69A:  CLRF   x98
0A69C:  CLRF   x99
0A69E:  CLRF   x9A
0A6A0:  CLRF   x9B
0A6A2:  CLRF   x9C
0A6A4:  CLRF   x9D
0A6A6:  CLRF   x9E
0A6A8:  CLRF   x9F
0A6AA:  CLRF   xA0
0A6AC:  CLRF   xA1
0A6AE:  CLRF   xA2
0A6B0:  CLRF   xA3
0A6B2:  CLRF   xA4
0A6B4:  CLRF   xA5
0A6B6:  CLRF   xA6
0A6B8:  CLRF   xA7
0A6BA:  CLRF   xA8
0A6BC:  CLRF   xA9
0A6BE:  CLRF   xAA
0A6C0:  CLRF   xAB
0A6C2:  CLRF   xAC
0A6C4:  CLRF   xAD
0A6C6:  CLRF   xAE
0A6C8:  CLRF   xAF
0A6CA:  CLRF   xB0
0A6CC:  CLRF   xB1
0A6CE:  CLRF   xB2
0A6D0:  CLRF   xB4
0A6D2:  CLRF   xB3
0A6D4:  CLRF   xB5
0A6D6:  CLRF   xB4
0A6D8:  CLRF   xB5
0A6DA:  CLRF   xB6
0A6DC:  CLRF   xB7
0A6DE:  CLRF   xB8
0A6E0:  CLRF   xB9
0A6E2:  CLRF   xBA
0A6E4:  CLRF   xBB
0A6E6:  CLRF   xBC
0A6E8:  CLRF   xBD
0A6EA:  CLRF   xBE
0A6EC:  CLRF   xBF
0A6EE:  CLRF   xC0
0A6F0:  CLRF   xC1
0A6F2:  CLRF   xC2
0A6F4:  CLRF   xC3
0A6F6:  CLRF   xC4
0A6F8:  CLRF   xC5
0A6FA:  CLRF   xC6
0A6FC:  CLRF   xC7
0A6FE:  CLRF   xC8
0A700:  CLRF   xC9
0A702:  CLRF   xCA
0A704:  CLRF   xCB
0A706:  CLRF   xCC
0A708:  CLRF   xCD
0A70A:  CLRF   xCE
0A70C:  CLRF   xCF
0A70E:  CLRF   xD0
0A710:  CLRF   xD1
0A712:  CLRF   xD2
0A714:  CLRF   xD3
0A716:  CLRF   xD4
0A718:  CLRF   xD5
0A71A:  CLRF   xD6
0A71C:  CLRF   xD7
0A71E:  CLRF   xD8
0A720:  CLRF   xD9
0A722:  CLRF   xDA
0A724:  BCF    56.2
0A726:  CLRF   xDD
0A728:  CLRF   xE9
0A72A:  CLRF   xEA
0A72C:  CLRF   xEB
0A72E:  CLRF   xEC
0A730:  CLRF   xED
0A732:  CLRF   xEE
0A734:  CLRF   xEF
0A736:  CLRF   xF0
0A738:  CLRF   xF1
0A73A:  CLRF   xF2
0A73C:  CLRF   xF3
0A73E:  CLRF   xF4
0A740:  CLRF   xF5
0A742:  CLRF   xF6
0A744:  CLRF   xF7
0A746:  CLRF   xF8
0A748:  CLRF   xF9
0A74A:  CLRF   xFA
0A74C:  CLRF   xFB
0A74E:  CLRF   xFC
0A750:  CLRF   xFD
0A752:  CLRF   xFE
0A754:  CLRF   xFF
0A756:  MOVLB  3
0A758:  CLRF   x00
0A75A:  CLRF   x01
0A75C:  CLRF   x02
0A75E:  CLRF   x03
0A760:  CLRF   x04
0A762:  CLRF   x05
0A764:  CLRF   x06
0A766:  CLRF   x07
0A768:  CLRF   x08
0A76A:  CLRF   x09
0A76C:  CLRF   x0A
0A76E:  CLRF   x0B
0A770:  CLRF   x0C
0A772:  CLRF   x0D
0A774:  CLRF   x0E
0A776:  CLRF   x0F
0A778:  CLRF   x10
0A77A:  CLRF   x11
0A77C:  CLRF   x12
0A77E:  CLRF   x13
0A780:  CLRF   x14
0A782:  CLRF   x15
0A784:  CLRF   x16
0A786:  CLRF   x17
0A788:  CLRF   x18
0A78A:  CLRF   x19
0A78C:  CLRF   x1A
0A78E:  CLRF   x1B
0A790:  CLRF   x1C
0A792:  CLRF   x1D
0A794:  CLRF   x1E
0A796:  CLRF   x1F
0A798:  CLRF   x20
0A79A:  CLRF   x21
0A79C:  CLRF   x22
0A79E:  CLRF   x23
0A7A0:  CLRF   x24
0A7A2:  CLRF   x25
0A7A4:  CLRF   x26
0A7A6:  CLRF   x27
0A7A8:  CLRF   x28
0A7AA:  CLRF   x29
0A7AC:  CLRF   x2A
0A7AE:  CLRF   x2B
0A7B0:  CLRF   x2C
0A7B2:  CLRF   x2D
0A7B4:  CLRF   x2E
0A7B6:  CLRF   x2F
0A7B8:  CLRF   x30
0A7BA:  CLRF   x31
0A7BC:  MOVLW  43
0A7BE:  MOVWF  x45
0A7C0:  MOVWF  x46
0A7C2:  MOVLW  53
0A7C4:  MOVWF  x47
0A7C6:  MOVLW  20
0A7C8:  MOVWF  x48
0A7CA:  MOVLW  57
0A7CC:  MOVWF  x49
0A7CE:  MOVLW  65
0A7D0:  MOVWF  x4A
0A7D2:  MOVLW  62
0A7D4:  MOVWF  x4B
0A7D6:  MOVLW  73
0A7D8:  MOVWF  x4C
0A7DA:  MOVLW  65
0A7DC:  MOVWF  x4D
0A7DE:  MOVLW  72
0A7E0:  MOVWF  x4E
0A7E2:  MOVLW  76
0A7E4:  MOVWF  x4F
0A7E6:  MOVLW  65
0A7E8:  MOVWF  x50
0A7EA:  MOVLW  72
0A7EC:  MOVWF  x51
0A7EE:  CLRF   x52
0A7F0:  CLRF   x59
0A7F2:  CLRF   x5A
0A7F4:  MOVLW  2F
0A7F6:  MOVWF  x5B
0A7F8:  CLRF   x5C
0A7FA:  MOVWF  x5D
0A7FC:  MOVLW  61
0A7FE:  MOVWF  x5E
0A800:  MOVLW  6E
0A802:  MOVWF  x5F
0A804:  MOVLW  61
0A806:  MOVWF  x60
0A808:  MOVLW  6C
0A80A:  MOVWF  x61
0A80C:  MOVLW  6F
0A80E:  MOVWF  x62
0A810:  MOVLW  67
0A812:  MOVWF  x63
0A814:  CLRF   x64
0A816:  MOVLW  6C
0A818:  MOVWF  x65
0A81A:  MOVLW  65
0A81C:  MOVWF  x66
0A81E:  MOVLW  64
0A820:  MOVWF  x67
0A822:  MOVLW  31
0A824:  MOVWF  x68
0A826:  CLRF   x69
0A828:  MOVLW  6C
0A82A:  MOVWF  x6A
0A82C:  MOVLW  65
0A82E:  MOVWF  x6B
0A830:  MOVLW  64
0A832:  MOVWF  x6C
0A834:  MOVLW  32
0A836:  MOVWF  x6D
0A838:  CLRF   x6E
0A83A:  MOVLW  6C
0A83C:  MOVWF  x6F
0A83E:  MOVLW  63
0A840:  MOVWF  x70
0A842:  MOVLW  64
0A844:  MOVWF  x71
0A846:  CLRF   x72
0A848:  MOVLW  6D
0A84A:  MOVWF  x73
0A84C:  MOVLW  73
0A84E:  MOVWF  x74
0A850:  MOVLW  67
0A852:  MOVWF  x75
0A854:  MOVLW  53
0A856:  MOVWF  x76
0A858:  MOVLW  74
0A85A:  MOVWF  x77
0A85C:  MOVLW  61
0A85E:  MOVWF  x78
0A860:  MOVLW  63
0A862:  MOVWF  x79
0A864:  MOVLW  6B
0A866:  MOVWF  x7A
0A868:  CLRF   x7B
....................    output_high(PIN_D0); 
0A86A:  BCF    F95.0
0A86C:  BSF    F8C.0
....................    delay_ms(250); 
0A86E:  MOVLW  FA
0A870:  MOVWF  xA7
0A872:  MOVLB  0
0A874:  CALL   0A04
....................    output_low(PIN_D0); 
0A878:  BCF    F95.0
0A87A:  BCF    F8C.0
....................    init(); 
0A87C:  GOTO   199A
....................    splash(); 
0A880:  GOTO   1DE4
....................     
....................  
....................    while (TRUE) { 
....................  
....................       restart_wdt(); 
0A884:  CLRWDT
....................  
....................      #if STACK_USE_SERIAL 
....................       if (kbhit(USER)) { 
0A886:  BTFSS  F9E.5
0A888:  BRA    A88E
....................          ui_handle(); 
0A88A:  GOTO   2EA4
....................       } 
....................      #endif 
....................  
....................       //every second: refresh current IP, blink LED 
....................       if (second_counter>=1) { 
0A88E:  MOVF   50,W
0A890:  SUBLW  00
0A892:  BC    A89C
....................          display_ip_lcd(); 
0A894:  GOTO   2FA8
....................         #if defined(USER_LED3) 
....................          output_toggle(USER_LED3); 
0A898:  BTG    F8A.5
....................         #endif 
....................          second_counter=0; 
0A89A:  CLRF   50
....................       } 
....................  
....................       //just something to test the buttons 
....................      #if STACK_USE_CCS_PICNET 
....................       if (BUTTON_PRESSED(USER_BUTTON1)) 
....................       { 
....................          output_low(USER_LED1); 
....................       } 
....................       else 
....................       { 
....................          if (g_LEDState[0]) 
....................             output_low(USER_LED1); 
....................          else 
....................             output_high(USER_LED1); 
....................       } 
....................       if (BUTTON_PRESSED(USER_BUTTON2)) 
....................       { 
....................          output_low(USER_LED2); 
....................       } 
....................       else 
....................       { 
....................          if (g_LEDState[1]) 
....................             output_low(USER_LED2); 
....................          else 
....................             output_high(USER_LED2); 
....................       } 
....................      #elif STACK_USE_CCS_PICENS 
....................       if (g_LEDState[0]) 
0A89C:  MOVLB  3
0A89E:  MOVF   x59,F
0A8A0:  BZ    A8A6
....................          output_low(USER_LED1); 
0A8A2:  BCF    F89.5
....................       else 
0A8A4:  BRA    A8A8
....................          output_high(USER_LED1); 
0A8A6:  BSF    F89.5
....................       if (g_LEDState[1]) 
0A8A8:  MOVF   x5A,F
0A8AA:  BZ    A8B0
....................          output_low(USER_LED2); 
0A8AC:  BCF    F8A.4
....................       else 
0A8AE:  BRA    A8B2
....................          output_high(USER_LED2); 
0A8B0:  BSF    F8A.4
....................       if (BUTTON_PRESSED(USER_BUTTON1)) output_low(USER_LED3); 
0A8B2:  BTFSS  F80.4
0A8B4:  BCF    F8A.5
....................      #endif 
....................  
....................       #if STACK_USE_PPP 
....................       if (ppp_is_connected()) { 
....................       #endif 
....................       StackTask();            //Microchip's TCP/IP stack handler.  Must be called routinely. 
0A8B6:  MOVLB  0
0A8B8:  BRA    A118
....................       #if STACK_USE_PPP 
....................       } 
....................       #endif 
....................    } 
0A8BA:  BRA    A884
.................... } 
....................  
0A8BC:  SLEEP 

Configuration Fuses:
   Word  1: 0600   H4 NOIESO NOFCMEN
   Word  2: 1E18   NOBROWNOUT NOWDT BORV21 PUT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: A000   WRT NOWRTD NOWRTC WRTB
   Word  7: 400F   NOEBTR NOEBTRB
